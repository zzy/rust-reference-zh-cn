<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>表达式 - Rust 参考手册 - The Rust Language Reference</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Rust 参考手册, Rust 编程手册, Rust 编程语言, Rust 开发手册, Rust 开发指南">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        <script>
            var _hmt = _hmt || [];
            (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?5770bc327c3554e341930729aa8f9eb2";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
            })();
        </script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="introduction.html">介绍</a></li><li class="expanded "><a href="notation.html"><strong aria-hidden="true">1.</strong> 标记法</a></li><li class="expanded "><a href="lexical-structure.html"><strong aria-hidden="true">2.</strong> 词法结构</a></li><li><ol class="section"><li class="expanded "><a href="input-format.html"><strong aria-hidden="true">2.1.</strong> 输入格式</a></li><li class="expanded "><a href="keywords.html"><strong aria-hidden="true">2.2.</strong> 关键字</a></li><li class="expanded "><a href="identifiers.html"><strong aria-hidden="true">2.3.</strong> 标识符</a></li><li class="expanded "><a href="comments.html"><strong aria-hidden="true">2.4.</strong> 注释</a></li><li class="expanded "><a href="whitespace.html"><strong aria-hidden="true">2.5.</strong> 空白</a></li><li class="expanded "><a href="tokens.html"><strong aria-hidden="true">2.6.</strong> 记号</a></li><li class="expanded "><a href="paths.html"><strong aria-hidden="true">2.7.</strong> 路径</a></li></ol></li><li class="expanded "><a href="macros.html"><strong aria-hidden="true">3.</strong> 宏</a></li><li><ol class="section"><li class="expanded "><a href="macros-by-example.html"><strong aria-hidden="true">3.1.</strong> 声明宏</a></li><li class="expanded "><a href="procedural-macros.html"><strong aria-hidden="true">3.2.</strong> 过程宏</a></li></ol></li><li class="expanded "><a href="crates-and-source-files.html"><strong aria-hidden="true">4.</strong> crate 和源文件</a></li><li class="expanded "><a href="conditional-compilation.html"><strong aria-hidden="true">5.</strong> 条件编译</a></li><li class="expanded "><a href="items.html"><strong aria-hidden="true">6.</strong> 项</a></li><li><ol class="section"><li class="expanded "><a href="items/modules.html"><strong aria-hidden="true">6.1.</strong> 模块</a></li><li class="expanded "><a href="items/extern-crates.html"><strong aria-hidden="true">6.2.</strong> extern crate 声明</a></li><li class="expanded "><a href="items/use-declarations.html"><strong aria-hidden="true">6.3.</strong> use 声明</a></li><li class="expanded "><a href="items/functions.html"><strong aria-hidden="true">6.4.</strong> 函数</a></li><li class="expanded "><a href="items/type-aliases.html"><strong aria-hidden="true">6.5.</strong> 类型别名</a></li><li class="expanded "><a href="items/structs.html"><strong aria-hidden="true">6.6.</strong> 结构体</a></li><li class="expanded "><a href="items/enumerations.html"><strong aria-hidden="true">6.7.</strong> 枚举</a></li><li class="expanded "><a href="items/unions.html"><strong aria-hidden="true">6.8.</strong> 联合体</a></li><li class="expanded "><a href="items/constant-items.html"><strong aria-hidden="true">6.9.</strong> 常量项</a></li><li class="expanded "><a href="items/static-items.html"><strong aria-hidden="true">6.10.</strong> 静态项</a></li><li class="expanded "><a href="items/traits.html"><strong aria-hidden="true">6.11.</strong> trait</a></li><li class="expanded "><a href="items/implementations.html"><strong aria-hidden="true">6.12.</strong> 实现</a></li><li class="expanded "><a href="items/external-blocks.html"><strong aria-hidden="true">6.13.</strong> 外部块</a></li><li class="expanded "><a href="items/generics.html"><strong aria-hidden="true">6.14.</strong> 泛型：类型和生命周期参数</a></li><li class="expanded "><a href="items/associated-items.html"><strong aria-hidden="true">6.15.</strong> 关联项</a></li><li class="expanded "><a href="visibility-and-privacy.html"><strong aria-hidden="true">6.16.</strong> 可见性和私有性</a></li></ol></li><li class="expanded "><a href="attributes.html"><strong aria-hidden="true">7.</strong> 属性</a></li><li><ol class="section"><li class="expanded "><a href="attributes/testing.html"><strong aria-hidden="true">7.1.</strong> 测试属性</a></li><li class="expanded "><a href="attributes/derive.html"><strong aria-hidden="true">7.2.</strong> 派生属性</a></li><li class="expanded "><a href="attributes/diagnostics.html"><strong aria-hidden="true">7.3.</strong> 诊断属性</a></li><li class="expanded "><a href="attributes/codegen.html"><strong aria-hidden="true">7.4.</strong> 代码生成属性</a></li><li class="expanded "><a href="attributes/limits.html"><strong aria-hidden="true">7.5.</strong> limit 属性</a></li><li class="expanded "><a href="attributes/type_system.html"><strong aria-hidden="true">7.6.</strong> 类型系统属性</a></li></ol></li><li class="expanded "><a href="statements-and-expressions.html"><strong aria-hidden="true">8.</strong> 语句和表达式</a></li><li><ol class="section"><li class="expanded "><a href="statements.html"><strong aria-hidden="true">8.1.</strong> 语句</a></li><li class="expanded "><a href="expressions.html" class="active"><strong aria-hidden="true">8.2.</strong> 表达式</a></li><li><ol class="section"><li class="expanded "><a href="expressions/literal-expr.html"><strong aria-hidden="true">8.2.1.</strong> 字面量表达式</a></li><li class="expanded "><a href="expressions/path-expr.html"><strong aria-hidden="true">8.2.2.</strong> 路径表达式</a></li><li class="expanded "><a href="expressions/block-expr.html"><strong aria-hidden="true">8.2.3.</strong> 块表达式</a></li><li class="expanded "><a href="expressions/operator-expr.html"><strong aria-hidden="true">8.2.4.</strong> 运算符表达式</a></li><li class="expanded "><a href="expressions/grouped-expr.html"><strong aria-hidden="true">8.2.5.</strong> 组合表达式</a></li><li class="expanded "><a href="expressions/array-expr.html"><strong aria-hidden="true">8.2.6.</strong> 数组和索引表达式</a></li><li class="expanded "><a href="expressions/tuple-expr.html"><strong aria-hidden="true">8.2.7.</strong> 元组和索引表达式</a></li><li class="expanded "><a href="expressions/struct-expr.html"><strong aria-hidden="true">8.2.8.</strong> 结构体表达式</a></li><li class="expanded "><a href="expressions/enum-variant-expr.html"><strong aria-hidden="true">8.2.9.</strong> 枚举变量表达式</a></li><li class="expanded "><a href="expressions/call-expr.html"><strong aria-hidden="true">8.2.10.</strong> 调用表达式</a></li><li class="expanded "><a href="expressions/method-call-expr.html"><strong aria-hidden="true">8.2.11.</strong> 方法调用表达式</a></li><li class="expanded "><a href="expressions/field-expr.html"><strong aria-hidden="true">8.2.12.</strong> 字段存取表达式</a></li><li class="expanded "><a href="expressions/closure-expr.html"><strong aria-hidden="true">8.2.13.</strong> 闭包表达式</a></li><li class="expanded "><a href="expressions/loop-expr.html"><strong aria-hidden="true">8.2.14.</strong> 循环表达式</a></li><li class="expanded "><a href="expressions/range-expr.html"><strong aria-hidden="true">8.2.15.</strong> 区间表达式</a></li><li class="expanded "><a href="expressions/if-expr.html"><strong aria-hidden="true">8.2.16.</strong> if 和 if let 表达式</a></li><li class="expanded "><a href="expressions/match-expr.html"><strong aria-hidden="true">8.2.17.</strong> match 表达式</a></li><li class="expanded "><a href="expressions/return-expr.html"><strong aria-hidden="true">8.2.18.</strong> return 表达式</a></li><li class="expanded "><a href="expressions/await-expr.html"><strong aria-hidden="true">8.2.19.</strong> await 表达式</a></li></ol></li></ol></li><li class="expanded "><a href="patterns.html"><strong aria-hidden="true">9.</strong> 模式</a></li><li class="expanded "><a href="type-system.html"><strong aria-hidden="true">10.</strong> 类型系统</a></li><li><ol class="section"><li class="expanded "><a href="types.html"><strong aria-hidden="true">10.1.</strong> 类型</a></li><li><ol class="section"><li class="expanded "><a href="types/boolean.html"><strong aria-hidden="true">10.1.1.</strong> 布尔型</a></li><li class="expanded "><a href="types/numeric.html"><strong aria-hidden="true">10.1.2.</strong> 数值型</a></li><li class="expanded "><a href="types/textual.html"><strong aria-hidden="true">10.1.3.</strong> 字符型</a></li><li class="expanded "><a href="types/never.html"><strong aria-hidden="true">10.1.4.</strong> never 型</a></li><li class="expanded "><a href="types/tuple.html"><strong aria-hidden="true">10.1.5.</strong> 元组</a></li><li class="expanded "><a href="types/array.html"><strong aria-hidden="true">10.1.6.</strong> 数组</a></li><li class="expanded "><a href="types/slice.html"><strong aria-hidden="true">10.1.7.</strong> 切片</a></li><li class="expanded "><a href="types/struct.html"><strong aria-hidden="true">10.1.8.</strong> 结构体</a></li><li class="expanded "><a href="types/enum.html"><strong aria-hidden="true">10.1.9.</strong> 枚举</a></li><li class="expanded "><a href="types/union.html"><strong aria-hidden="true">10.1.10.</strong> union 型</a></li><li class="expanded "><a href="types/function-item.html"><strong aria-hidden="true">10.1.11.</strong> 函数项</a></li><li class="expanded "><a href="types/closure.html"><strong aria-hidden="true">10.1.12.</strong> 闭包</a></li><li class="expanded "><a href="types/pointer.html"><strong aria-hidden="true">10.1.13.</strong> 指针</a></li><li class="expanded "><a href="types/function-pointer.html"><strong aria-hidden="true">10.1.14.</strong> 函数指针</a></li><li class="expanded "><a href="types/trait-object.html"><strong aria-hidden="true">10.1.15.</strong> trait 对象</a></li><li class="expanded "><a href="types/impl-trait.html"><strong aria-hidden="true">10.1.16.</strong> impl trait</a></li><li class="expanded "><a href="types/parameters.html"><strong aria-hidden="true">10.1.17.</strong> 类型参数</a></li><li class="expanded "><a href="types/inferred.html"><strong aria-hidden="true">10.1.18.</strong> 推导型</a></li></ol></li><li class="expanded "><a href="dynamically-sized-types.html"><strong aria-hidden="true">10.2.</strong> Dynamically Sized Types</a></li><li class="expanded "><a href="type-layout.html"><strong aria-hidden="true">10.3.</strong> Type layout</a></li><li class="expanded "><a href="interior-mutability.html"><strong aria-hidden="true">10.4.</strong> Interior mutability</a></li><li class="expanded "><a href="subtyping.html"><strong aria-hidden="true">10.5.</strong> Subtyping and Variance</a></li><li class="expanded "><a href="trait-bounds.html"><strong aria-hidden="true">10.6.</strong> Trait and lifetime bounds</a></li><li class="expanded "><a href="type-coercions.html"><strong aria-hidden="true">10.7.</strong> Type coercions</a></li><li class="expanded "><a href="destructors.html"><strong aria-hidden="true">10.8.</strong> Destructors</a></li><li class="expanded "><a href="lifetime-elision.html"><strong aria-hidden="true">10.9.</strong> Lifetime elision</a></li></ol></li><li class="expanded "><a href="special-types-and-traits.html"><strong aria-hidden="true">11.</strong> Special types and traits</a></li><li class="expanded "><a href="memory-model.html"><strong aria-hidden="true">12.</strong> Memory model</a></li><li><ol class="section"><li class="expanded "><a href="memory-allocation-and-lifetime.html"><strong aria-hidden="true">12.1.</strong> Memory allocation and lifetime</a></li><li class="expanded "><a href="memory-ownership.html"><strong aria-hidden="true">12.2.</strong> Memory ownership</a></li><li class="expanded "><a href="variables.html"><strong aria-hidden="true">12.3.</strong> Variables</a></li></ol></li><li class="expanded "><a href="linkage.html"><strong aria-hidden="true">13.</strong> Linkage</a></li><li class="expanded "><a href="unsafety.html"><strong aria-hidden="true">14.</strong> Unsafety</a></li><li><ol class="section"><li class="expanded "><a href="unsafe-functions.html"><strong aria-hidden="true">14.1.</strong> Unsafe functions</a></li><li class="expanded "><a href="unsafe-blocks.html"><strong aria-hidden="true">14.2.</strong> Unsafe blocks</a></li><li class="expanded "><a href="behavior-considered-undefined.html"><strong aria-hidden="true">14.3.</strong> Behavior considered undefined</a></li><li class="expanded "><a href="behavior-not-considered-unsafe.html"><strong aria-hidden="true">14.4.</strong> Behavior not considered unsafe</a></li></ol></li><li class="expanded "><a href="const_eval.html"><strong aria-hidden="true">15.</strong> Constant Evaluation</a></li><li class="expanded "><a href="abi.html"><strong aria-hidden="true">16.</strong> Application Binary Interface</a></li><li class="expanded "><a href="runtime.html"><strong aria-hidden="true">17.</strong> The Rust runtime</a></li><li class="expanded "><a href="appendices.html"><strong aria-hidden="true">18.</strong> Appendices</a></li><li><ol class="section"><li class="expanded "><a href="macro-ambiguity.html"><strong aria-hidden="true">18.1.</strong> Macro Follow-Set Ambiguity Formal Specification</a></li><li class="expanded "><a href="influences.html"><strong aria-hidden="true">18.2.</strong> Influences</a></li><li class="expanded "><a href="glossary.html"><strong aria-hidden="true">18.3.</strong> Glossary</a></li></ol></li><li class="expanded "><a href="rust-glossary.html">Rust 语言术语中英文对照表</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust 参考手册 - The Rust Language Reference</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                            <a href="https://github.com/zzy/rust-reference-zh" title="Git repository" aria-label="Git repository">
                                <i id="git-repository-button" class="fa fa-github"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#expressions" id="expressions">Expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Expression</em> :<br />
      <em>ExpressionWithoutBlock</em><br />
   | <em>ExpressionWithBlock</em></p>
<p><em>ExpressionWithoutBlock</em> :<br />
   <a href="attributes.html"><em>OuterAttribute</em></a><sup>*</sup><a href="#expression-attributes">†</a><br />
   (<br />
         <a href="expressions/literal-expr.html"><em>LiteralExpression</em></a><br />
      | <a href="expressions/path-expr.html"><em>PathExpression</em></a><br />
      | <a href="expressions/operator-expr.html"><em>OperatorExpression</em></a><br />
      | <a href="expressions/grouped-expr.html"><em>GroupedExpression</em></a><br />
      | <a href="expressions/array-expr.html"><em>ArrayExpression</em></a><br />
      | <a href="expressions/await-expr.html"><em>AwaitExpression</em></a><br />
      | <a href="expressions/array-expr.html#array-and-slice-indexing-expressions"><em>IndexExpression</em></a><br />
      | <a href="expressions/tuple-expr.html"><em>TupleExpression</em></a><br />
      | <a href="expressions/tuple-expr.html#tuple-indexing-expressions"><em>TupleIndexingExpression</em></a><br />
      | <a href="expressions/struct-expr.html"><em>StructExpression</em></a><br />
      | <a href="expressions/enum-variant-expr.html"><em>EnumerationVariantExpression</em></a><br />
      | <a href="expressions/call-expr.html"><em>CallExpression</em></a><br />
      | <a href="expressions/method-call-expr.html"><em>MethodCallExpression</em></a><br />
      | <a href="expressions/field-expr.html"><em>FieldExpression</em></a><br />
      | <a href="expressions/closure-expr.html"><em>ClosureExpression</em></a><br />
      | <a href="expressions/loop-expr.html#continue-expressions"><em>ContinueExpression</em></a><br />
      | <a href="expressions/loop-expr.html#break-expressions"><em>BreakExpression</em></a><br />
      | <a href="expressions/range-expr.html"><em>RangeExpression</em></a><br />
      | <a href="expressions/return-expr.html"><em>ReturnExpression</em></a><br />
      | <a href="macros.html#macro-invocation"><em>MacroInvocation</em></a><br />
   )</p>
<p><em>ExpressionWithBlock</em> :<br />
   <a href="attributes.html"><em>OuterAttribute</em></a><sup>*</sup><a href="#expression-attributes">†</a><br />
   (<br />
         <a href="expressions/block-expr.html"><em>BlockExpression</em></a><br />
      | <a href="expressions/block-expr.html#async-blocks"><em>AsyncBlockExpression</em></a><br />
      | <a href="expressions/block-expr.html#unsafe-blocks"><em>UnsafeBlockExpression</em></a><br />
      | <a href="expressions/loop-expr.html"><em>LoopExpression</em></a><br />
      | <a href="expressions/if-expr.html#if-expressions"><em>IfExpression</em></a><br />
      | <a href="expressions/if-expr.html#if-let-expressions"><em>IfLetExpression</em></a><br />
      | <a href="expressions/match-expr.html"><em>MatchExpression</em></a><br />
   )</p>
</blockquote>
<p>An expression may have two roles: it always produces a <em>value</em>, and it may have
<em>effects</em> (otherwise known as “side effects”). An expression <em>evaluates to</em> a
value, and has effects during <em>evaluation</em>. Many expressions contain
sub-expressions (operands). The meaning of each kind of expression dictates
several things:</p>
<ul>
<li>Whether or not to evaluate the sub-expressions when evaluating the expression</li>
<li>The order in which to evaluate the sub-expressions</li>
<li>How to combine the sub-expressions’ values to obtain the value of the
expression</li>
</ul>
<p>In this way, the structure of expressions dictates the structure of execution.
Blocks are just another kind of expression, so blocks, statements, expressions,
and blocks again can recursively nest inside each other to an arbitrary depth.</p>
<h2><a class="header" href="#expression-precedence" id="expression-precedence">Expression precedence</a></h2>
<p>The precedence of Rust operators and expressions is ordered as follows, going
from strong to weak. Binary Operators at the same precedence level are grouped
in the order given by their associativity.</p>
<table><thead><tr><th>Operator/Expression</th><th>Associativity</th></tr></thead><tbody>
<tr><td>Paths</td><td></td></tr>
<tr><td>Method calls</td><td></td></tr>
<tr><td>Field expressions</td><td>left to right</td></tr>
<tr><td>Function calls, array indexing</td><td></td></tr>
<tr><td><code>?</code></td><td></td></tr>
<tr><td>Unary <code>-</code> <code>*</code> <code>!</code> <code>&amp;</code> <code>&amp;mut</code></td><td></td></tr>
<tr><td><code>as</code></td><td>left to right</td></tr>
<tr><td><code>*</code> <code>/</code> <code>%</code></td><td>left to right</td></tr>
<tr><td><code>+</code> <code>-</code></td><td>left to right</td></tr>
<tr><td><code>&lt;&lt;</code> <code>&gt;&gt;</code></td><td>left to right</td></tr>
<tr><td><code>&amp;</code></td><td>left to right</td></tr>
<tr><td><code>^</code></td><td>left to right</td></tr>
<tr><td><code>|</code></td><td>left to right</td></tr>
<tr><td><code>==</code> <code>!=</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code></td><td>Require parentheses</td></tr>
<tr><td><code>&amp;&amp;</code></td><td>left to right</td></tr>
<tr><td><code>||</code></td><td>left to right</td></tr>
<tr><td><code>..</code> <code>..=</code></td><td>Require parentheses</td></tr>
<tr><td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <br> <code>&amp;=</code> <code>|=</code> <code>^=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code></td><td>right to left</td></tr>
<tr><td><code>return</code> <code>break</code> closures</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#place-expressions-and-value-expressions" id="place-expressions-and-value-expressions">Place Expressions and Value Expressions</a></h2>
<p>Expressions are divided into two main categories: place expressions and
value expressions. Likewise within each expression, sub-expressions may occur
in either place context or value context. The evaluation of an expression
depends both on its own category and the context it occurs within.</p>
<p>A <em>place expression</em> is an expression that represents a memory location. These
expressions are <a href="expressions/path-expr.html">paths</a> which refer to local variables, <a href="items/static-items.html">static variables</a>,
<a href="expressions/operator-expr.html#the-dereference-operator">dereferences</a> (<code>*expr</code>), <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">array indexing</a> expressions (<code>expr[expr]</code>),
<a href="expressions/field-expr.html">field</a> references (<code>expr.f</code>) and parenthesized place expressions. All other
expressions are value expressions.</p>
<p>A <em>value expression</em> is an expression that represents an actual value.</p>
<p>The following contexts are <em>place expression</em> contexts:</p>
<ul>
<li>The left operand of an <a href="expressions/operator-expr.html#assignment-expressions">assignment</a> or <a href="expressions/operator-expr.html#compound-assignment-expressions">compound assignment</a>
expression.</li>
<li>The operand of a unary <a href="expressions/operator-expr.html#borrow-operators">borrow</a> or <a href="expressions/operator-expr.html#the-dereference-operator">dereference</a> operator.</li>
<li>The operand of a field expression.</li>
<li>The indexed operand of an array indexing expression.</li>
<li>The operand of any <a href="#implicit-borrows">implicit borrow</a>.</li>
<li>The initializer of a <a href="statements.html#let-statements">let statement</a>.</li>
<li>The <a href="glossary.html#scrutinee">scrutinee</a> of an <a href="expressions/if-expr.html#if-let-expressions"><code>if let</code></a>, <a href="expressions/match-expr.html"><code>match</code></a>, or <a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a>
expression.</li>
<li>The base of a <a href="expressions/struct-expr.html#functional-update-syntax">functional update</a> struct expression.</li>
</ul>
<blockquote>
<p>Note: Historically, place expressions were called <em>lvalues</em> and value
expressions were called <em>rvalues</em>.</p>
</blockquote>
<h3><a class="header" href="#moved-and-copied-types" id="moved-and-copied-types">Moved and copied types</a></h3>
<p>When a place expression is evaluated in a value expression context, or is bound
by value in a pattern, it denotes the value held <em>in</em> that memory location. If
the type of that value implements <a href="special-types-and-traits.html#copy"><code>Copy</code></a>, then the value will be copied. In
the remaining situations if that type is <a href="special-types-and-traits.html#sized"><code>Sized</code></a>, then it may be possible to
move the value. Only the following place expressions may be moved out of:</p>
<ul>
<li><a href="variables.html">Variables</a> which are not currently borrowed.</li>
<li><a href="#temporary-lifetimes">Temporary values</a>.</li>
<li><a href="expressions/field-expr.html">Fields</a> of a place expression which can be moved out of and
doesn’t implement <a href="special-types-and-traits.html#drop"><code>Drop</code></a>.</li>
<li>The result of <a href="expressions/operator-expr.html#the-dereference-operator">dereferencing</a> an expression with type <a href="../std/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> and
that can also be moved out of.</li>
</ul>
<p>Moving out of a place expression that evaluates to a local variable, the
location is deinitialized and cannot be read from again until it is
reinitialized. In all other cases, trying to use a place expression in a value
expression context is an error.</p>
<h3><a class="header" href="#mutability" id="mutability">Mutability</a></h3>
<p>For a place expression to be <a href="expressions/operator-expr.html#assignment-expressions">assigned</a> to, mutably <a href="expressions/operator-expr.html#borrow-operators">borrowed</a>,
<a href="#implicit-borrows">implicitly mutably borrowed</a>, or bound to a pattern containing <code>ref mut</code> it
must be <em>mutable</em>. We call these <em>mutable place expressions</em>. In contrast,
other place expressions are called <em>immutable place expressions</em>.</p>
<p>The following expressions can be mutable place expression contexts:</p>
<ul>
<li>Mutable <a href="variables.html">variables</a>, which are not currently borrowed.</li>
<li><a href="items/static-items.html#mutable-statics">Mutable <code>static</code> items</a>.</li>
<li><a href="#temporary-lifetimes">Temporary values</a>.</li>
<li><a href="expressions/field-expr.html">Fields</a>, this evaluates the subexpression in a mutable place
expression context.</li>
<li><a href="expressions/operator-expr.html#the-dereference-operator">Dereferences</a> of a <code>*mut T</code> pointer.</li>
<li>Dereference of a variable, or field of a variable, with type <code>&amp;mut T</code>. Note:
This is an exception to the requirement of the next rule.</li>
<li>Dereferences of a type that implements <code>DerefMut</code>, this then requires that
the value being dereferenced is evaluated is a mutable place expression context.</li>
<li><a href="expressions/array-expr.html#array-and-slice-indexing-expressions">Array indexing</a> of a type that implements <code>DerefMut</code>, this
then evaluates the value being indexed, but not the index, in mutable place
expression context.</li>
</ul>
<h3><a class="header" href="#temporary-lifetimes" id="temporary-lifetimes">Temporary lifetimes</a></h3>
<p>When using a value expression in most place expression contexts, a temporary
unnamed memory location is created initialized to that value and the expression
evaluates to that location instead, except if promoted to <code>'static</code>. Promotion
of a value expression to a <code>'static</code> slot occurs when the expression could be
written in a constant, borrowed, and dereferencing that borrow where the
expression was originally written, without changing the runtime behavior. That
is, the promoted expression can be evaluated at compile-time and the resulting
value does not contain <a href="interior-mutability.html">interior mutability</a> or <a href="destructors.html">destructors</a> (these properties
are determined based on the value where possible, e.g. <code>&amp;None</code> always has the
type <code>&amp;'static Option&lt;_&gt;</code>, as it contains nothing disallowed). Otherwise, the
lifetime of temporary values is typically</p>
<ul>
<li>the innermost enclosing statement; the tail expression of a block is
considered part of the statement that encloses the block, or</li>
<li>the condition expression or the loop conditional expression if the
temporary is created in the condition expression of an <code>if</code> or in the loop
conditional expression of a <code>while</code> expression.</li>
</ul>
<p>When a temporary value expression is being created that is assigned into a
<a href="statements.html#let-statements"><code>let</code> declaration</a>, however, the temporary is created with the lifetime of
the enclosing block instead, as using the enclosing <a href="statements.html#let-statements"><code>let</code> declaration</a>
would be a guaranteed error (since a pointer to the temporary
would be stored into a variable, but the temporary would be freed before the
variable could be used). The compiler uses simple syntactic rules to decide
which values are being assigned into a <code>let</code> binding, and therefore deserve a
longer temporary lifetime.</p>
<p>Here are some examples:</p>
<ul>
<li><code>let x = foo(&amp;temp())</code>. The expression <code>temp()</code> is a value expression. As it
is being borrowed, a temporary is created which will be freed after
the innermost enclosing statement; in this case, the <code>let</code> declaration.</li>
<li><code>let x = temp().foo()</code>. This is the same as the previous example,
except that the value of <code>temp()</code> is being borrowed via autoref on a
method-call. Here we are assuming that <code>foo()</code> is an <code>&amp;self</code> method
defined in some trait, say <code>Foo</code>. In other words, the expression
<code>temp().foo()</code> is equivalent to <code>Foo::foo(&amp;temp())</code>.</li>
<li><code>let x = if foo(&amp;temp()) {bar()} else {baz()};</code>. The expression <code>temp()</code> is
a value expression. As the temporary is created in the condition expression
of an <code>if</code>, it will be freed at the end of the condition expression;
in this example before the call to <code>bar</code> or <code>baz</code> is made.</li>
<li><code>let x = if temp().must_run_bar {bar()} else {baz()};</code>.
Here we assume the type of <code>temp()</code> is a struct with a boolean field
<code>must_run_bar</code>. As the previous example, the temporary corresponding to
<code>temp()</code> will be freed at the end of the condition expression.</li>
<li><code>while foo(&amp;temp()) {bar();}</code>. The temporary containing the return value from
the call to <code>temp()</code> is created in the loop conditional expression. Hence it
will be freed at the end of the loop conditional expression; in this example
before the call to <code>bar</code> if the loop body is executed.</li>
<li><code>let x = &amp;temp()</code>. Here, the same temporary is being assigned into
<code>x</code>, rather than being passed as a parameter, and hence the
temporary’s lifetime is considered to be the enclosing block.</li>
<li><code>let x = SomeStruct { foo: &amp;temp() }</code>. As in the previous case, the
temporary is assigned into a struct which is then assigned into a
binding, and hence it is given the lifetime of the enclosing block.</li>
<li><code>let x = [ &amp;temp() ]</code>. As in the previous case, the
temporary is assigned into an array which is then assigned into a
binding, and hence it is given the lifetime of the enclosing block.</li>
<li><code>let ref x = temp()</code>. In this case, the temporary is created using a ref
binding, but the result is the same: the lifetime is extended to the enclosing
block.</li>
</ul>
<h3><a class="header" href="#implicit-borrows" id="implicit-borrows">Implicit Borrows</a></h3>
<p>Certain expressions will treat an expression as a place expression by implicitly
borrowing it. For example, it is possible to compare two unsized <a href="types/slice.html">slices</a> for
equality directly, because the <code>==</code> operator implicitly borrows it’s operands:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let c = [1, 2, 3];
</span><span class="boring">let d = vec![1, 2, 3];
</span>let a: &amp;[i32];
let b: &amp;[i32];
<span class="boring">a = &amp;c;
</span><span class="boring">b = &amp;d;
</span>// ...
*a == *b;
// Equivalent form:
::std::cmp::PartialEq::eq(&amp;*a, &amp;*b);
<span class="boring">}
</span></code></pre></pre>
<p>Implicit borrows may be taken in the following expressions:</p>
<ul>
<li>Left operand in <a href="expressions/method-call-expr.html">method-call</a> expressions.</li>
<li>Left operand in <a href="expressions/field-expr.html">field</a> expressions.</li>
<li>Left operand in <a href="expressions/call-expr.html">call expressions</a>.</li>
<li>Left operand in <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">array indexing</a> expressions.</li>
<li>Operand of the <a href="expressions/operator-expr.html#the-dereference-operator">dereference operator</a> (<code>*</code>).</li>
<li>Operands of <a href="expressions/operator-expr.html#comparison-operators">comparison</a>.</li>
<li>Left operands of the <a href="expressions/operator-expr.html#compound-assignment-expressions">compound assignment</a>.</li>
</ul>
<h2><a class="header" href="#overloading-traits" id="overloading-traits">Overloading Traits</a></h2>
<p>Many of the following operators and expressions can also be overloaded for
other types using traits in <code>std::ops</code> or <code>std::cmp</code>. These traits also
exist in <code>core::ops</code> and <code>core::cmp</code> with the same names.</p>
<h2><a class="header" href="#expression-attributes" id="expression-attributes">Expression Attributes</a></h2>
<p><a href="attributes.html">Outer attributes</a> before an expression are allowed only in
a few specific cases:</p>
<ul>
<li>Before an expression used as a <a href="statements.html">statement</a>.</li>
<li>Elements of <a href="expressions/array-expr.html">array expressions</a>, <a href="expressions/tuple-expr.html">tuple expressions</a>, <a href="expressions/call-expr.html">call expressions</a>,
and tuple-style <a href="expressions/struct-expr.html">struct</a> and <a href="expressions/enum-variant-expr.html">enum variant</a> expressions.<!--
  These were likely stabilized inadvertently.
  See https://github.com/rust-lang/rust/issues/32796 and
      https://github.com/rust-lang/rust/issues/15701
-->
</li>
<li>The tail expression of <a href="expressions/block-expr.html">block expressions</a>.</li>
</ul>
<!-- Keep list in sync with block-expr.md -->
<p>They are never allowed before:</p>
<ul>
<li><a href="expressions/if-expr.html#if-expressions"><code>if</code></a> and <a href="expressions/if-expr.html#if-let-expressions"><code>if let</code></a> expressions.</li>
<li><a href="expressions/range-expr.html">Range</a> expressions.</li>
<li>Binary operator expressions (<a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators"><em>ArithmeticOrLogicalExpression</em></a>,
<a href="expressions/operator-expr.html#comparison-operators"><em>ComparisonExpression</em></a>, <a href="expressions/operator-expr.html#lazy-boolean-operators"><em>LazyBooleanExpression</em></a>, <a href="expressions/operator-expr.html#type-cast-expressions"><em>TypeCastExpression</em></a>,
<a href="expressions/operator-expr.html#assignment-expressions"><em>AssignmentExpression</em></a>, <a href="expressions/operator-expr.html#compound-assignment-expressions"><em>CompoundAssignmentExpression</em></a>).</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="statements.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="expressions/literal-expr.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="statements.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="expressions/literal-expr.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
