<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust 参考手册 - The Rust Language Reference</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Rust 参考手册, Rust 编程手册, Rust 编程语言, Rust 开发手册, Rust 开发指南">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        <script>
            var _hmt = _hmt || [];
            (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?5770bc327c3554e341930729aa8f9eb2";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
            })();
        </script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="introduction.html">Introduction</a></li><li class="expanded "><a href="notation.html"><strong aria-hidden="true">1.</strong> Notation</a></li><li class="expanded "><a href="lexical-structure.html"><strong aria-hidden="true">2.</strong> Lexical structure</a></li><li><ol class="section"><li class="expanded "><a href="input-format.html"><strong aria-hidden="true">2.1.</strong> Input format</a></li><li class="expanded "><a href="keywords.html"><strong aria-hidden="true">2.2.</strong> Keywords</a></li><li class="expanded "><a href="identifiers.html"><strong aria-hidden="true">2.3.</strong> Identifiers</a></li><li class="expanded "><a href="comments.html"><strong aria-hidden="true">2.4.</strong> Comments</a></li><li class="expanded "><a href="whitespace.html"><strong aria-hidden="true">2.5.</strong> Whitespace</a></li><li class="expanded "><a href="tokens.html"><strong aria-hidden="true">2.6.</strong> Tokens</a></li><li class="expanded "><a href="paths.html"><strong aria-hidden="true">2.7.</strong> Paths</a></li></ol></li><li class="expanded "><a href="macros.html"><strong aria-hidden="true">3.</strong> Macros</a></li><li><ol class="section"><li class="expanded "><a href="macros-by-example.html"><strong aria-hidden="true">3.1.</strong> Macros By Example</a></li><li class="expanded "><a href="procedural-macros.html"><strong aria-hidden="true">3.2.</strong> Procedural Macros</a></li></ol></li><li class="expanded "><a href="crates-and-source-files.html"><strong aria-hidden="true">4.</strong> Crates and source files</a></li><li class="expanded "><a href="conditional-compilation.html"><strong aria-hidden="true">5.</strong> Conditional compilation</a></li><li class="expanded "><a href="items.html"><strong aria-hidden="true">6.</strong> Items</a></li><li><ol class="section"><li class="expanded "><a href="items/modules.html"><strong aria-hidden="true">6.1.</strong> Modules</a></li><li class="expanded "><a href="items/extern-crates.html"><strong aria-hidden="true">6.2.</strong> Extern crates</a></li><li class="expanded "><a href="items/use-declarations.html"><strong aria-hidden="true">6.3.</strong> Use declarations</a></li><li class="expanded "><a href="items/functions.html"><strong aria-hidden="true">6.4.</strong> Functions</a></li><li class="expanded "><a href="items/type-aliases.html"><strong aria-hidden="true">6.5.</strong> Type aliases</a></li><li class="expanded "><a href="items/structs.html"><strong aria-hidden="true">6.6.</strong> Structs</a></li><li class="expanded "><a href="items/enumerations.html"><strong aria-hidden="true">6.7.</strong> Enumerations</a></li><li class="expanded "><a href="items/unions.html"><strong aria-hidden="true">6.8.</strong> Unions</a></li><li class="expanded "><a href="items/constant-items.html"><strong aria-hidden="true">6.9.</strong> Constant items</a></li><li class="expanded "><a href="items/static-items.html"><strong aria-hidden="true">6.10.</strong> Static items</a></li><li class="expanded "><a href="items/traits.html"><strong aria-hidden="true">6.11.</strong> Traits</a></li><li class="expanded "><a href="items/implementations.html"><strong aria-hidden="true">6.12.</strong> Implementations</a></li><li class="expanded "><a href="items/external-blocks.html"><strong aria-hidden="true">6.13.</strong> External blocks</a></li><li class="expanded "><a href="items/generics.html"><strong aria-hidden="true">6.14.</strong> Type and lifetime parameters</a></li><li class="expanded "><a href="items/associated-items.html"><strong aria-hidden="true">6.15.</strong> Associated Items</a></li><li class="expanded "><a href="visibility-and-privacy.html"><strong aria-hidden="true">6.16.</strong> Visibility and Privacy</a></li></ol></li><li class="expanded "><a href="attributes.html"><strong aria-hidden="true">7.</strong> Attributes</a></li><li><ol class="section"><li class="expanded "><a href="attributes/testing.html"><strong aria-hidden="true">7.1.</strong> Testing</a></li><li class="expanded "><a href="attributes/derive.html"><strong aria-hidden="true">7.2.</strong> Derive</a></li><li class="expanded "><a href="attributes/diagnostics.html"><strong aria-hidden="true">7.3.</strong> Diagnostics</a></li><li class="expanded "><a href="attributes/codegen.html"><strong aria-hidden="true">7.4.</strong> Code generation</a></li><li class="expanded "><a href="attributes/limits.html"><strong aria-hidden="true">7.5.</strong> Limits</a></li><li class="expanded "><a href="attributes/type_system.html"><strong aria-hidden="true">7.6.</strong> Type System</a></li></ol></li><li class="expanded "><a href="statements-and-expressions.html"><strong aria-hidden="true">8.</strong> Statements and expressions</a></li><li><ol class="section"><li class="expanded "><a href="statements.html"><strong aria-hidden="true">8.1.</strong> Statements</a></li><li class="expanded "><a href="expressions.html"><strong aria-hidden="true">8.2.</strong> Expressions</a></li><li><ol class="section"><li class="expanded "><a href="expressions/literal-expr.html"><strong aria-hidden="true">8.2.1.</strong> Literal expressions</a></li><li class="expanded "><a href="expressions/path-expr.html"><strong aria-hidden="true">8.2.2.</strong> Path expressions</a></li><li class="expanded "><a href="expressions/block-expr.html"><strong aria-hidden="true">8.2.3.</strong> Block expressions</a></li><li class="expanded "><a href="expressions/operator-expr.html"><strong aria-hidden="true">8.2.4.</strong> Operator expressions</a></li><li class="expanded "><a href="expressions/grouped-expr.html"><strong aria-hidden="true">8.2.5.</strong> Grouped expressions</a></li><li class="expanded "><a href="expressions/array-expr.html"><strong aria-hidden="true">8.2.6.</strong> Array and index expressions</a></li><li class="expanded "><a href="expressions/tuple-expr.html"><strong aria-hidden="true">8.2.7.</strong> Tuple and index expressions</a></li><li class="expanded "><a href="expressions/struct-expr.html"><strong aria-hidden="true">8.2.8.</strong> Struct expressions</a></li><li class="expanded "><a href="expressions/enum-variant-expr.html"><strong aria-hidden="true">8.2.9.</strong> Enum variant expressions</a></li><li class="expanded "><a href="expressions/call-expr.html"><strong aria-hidden="true">8.2.10.</strong> Call expressions</a></li><li class="expanded "><a href="expressions/method-call-expr.html"><strong aria-hidden="true">8.2.11.</strong> Method call expressions</a></li><li class="expanded "><a href="expressions/field-expr.html"><strong aria-hidden="true">8.2.12.</strong> Field access expressions</a></li><li class="expanded "><a href="expressions/closure-expr.html"><strong aria-hidden="true">8.2.13.</strong> Closure expressions</a></li><li class="expanded "><a href="expressions/loop-expr.html"><strong aria-hidden="true">8.2.14.</strong> Loop expressions</a></li><li class="expanded "><a href="expressions/range-expr.html"><strong aria-hidden="true">8.2.15.</strong> Range expressions</a></li><li class="expanded "><a href="expressions/if-expr.html"><strong aria-hidden="true">8.2.16.</strong> If and if let expressions</a></li><li class="expanded "><a href="expressions/match-expr.html"><strong aria-hidden="true">8.2.17.</strong> Match expressions</a></li><li class="expanded "><a href="expressions/return-expr.html"><strong aria-hidden="true">8.2.18.</strong> Return expressions</a></li><li class="expanded "><a href="expressions/await-expr.html"><strong aria-hidden="true">8.2.19.</strong> Await expressions</a></li></ol></li></ol></li><li class="expanded "><a href="patterns.html"><strong aria-hidden="true">9.</strong> Patterns</a></li><li class="expanded "><a href="type-system.html"><strong aria-hidden="true">10.</strong> Type system</a></li><li><ol class="section"><li class="expanded "><a href="types.html"><strong aria-hidden="true">10.1.</strong> Types</a></li><li><ol class="section"><li class="expanded "><a href="types/boolean.html"><strong aria-hidden="true">10.1.1.</strong> Boolean type</a></li><li class="expanded "><a href="types/numeric.html"><strong aria-hidden="true">10.1.2.</strong> Numeric types</a></li><li class="expanded "><a href="types/textual.html"><strong aria-hidden="true">10.1.3.</strong> Textual types</a></li><li class="expanded "><a href="types/never.html"><strong aria-hidden="true">10.1.4.</strong> Never type</a></li><li class="expanded "><a href="types/tuple.html"><strong aria-hidden="true">10.1.5.</strong> Tuple types</a></li><li class="expanded "><a href="types/array.html"><strong aria-hidden="true">10.1.6.</strong> Array types</a></li><li class="expanded "><a href="types/slice.html"><strong aria-hidden="true">10.1.7.</strong> Slice types</a></li><li class="expanded "><a href="types/struct.html"><strong aria-hidden="true">10.1.8.</strong> Struct types</a></li><li class="expanded "><a href="types/enum.html"><strong aria-hidden="true">10.1.9.</strong> Enumerated types</a></li><li class="expanded "><a href="types/union.html"><strong aria-hidden="true">10.1.10.</strong> Union types</a></li><li class="expanded "><a href="types/function-item.html"><strong aria-hidden="true">10.1.11.</strong> Function item types</a></li><li class="expanded "><a href="types/closure.html"><strong aria-hidden="true">10.1.12.</strong> Closure types</a></li><li class="expanded "><a href="types/pointer.html"><strong aria-hidden="true">10.1.13.</strong> Pointer types</a></li><li class="expanded "><a href="types/function-pointer.html"><strong aria-hidden="true">10.1.14.</strong> Function pointer types</a></li><li class="expanded "><a href="types/trait-object.html"><strong aria-hidden="true">10.1.15.</strong> Trait object types</a></li><li class="expanded "><a href="types/impl-trait.html"><strong aria-hidden="true">10.1.16.</strong> Impl trait type</a></li><li class="expanded "><a href="types/parameters.html"><strong aria-hidden="true">10.1.17.</strong> Type parameters</a></li><li class="expanded "><a href="types/inferred.html"><strong aria-hidden="true">10.1.18.</strong> Inferred type</a></li></ol></li><li class="expanded "><a href="dynamically-sized-types.html"><strong aria-hidden="true">10.2.</strong> Dynamically Sized Types</a></li><li class="expanded "><a href="type-layout.html"><strong aria-hidden="true">10.3.</strong> Type layout</a></li><li class="expanded "><a href="interior-mutability.html"><strong aria-hidden="true">10.4.</strong> Interior mutability</a></li><li class="expanded "><a href="subtyping.html"><strong aria-hidden="true">10.5.</strong> Subtyping and Variance</a></li><li class="expanded "><a href="trait-bounds.html"><strong aria-hidden="true">10.6.</strong> Trait and lifetime bounds</a></li><li class="expanded "><a href="type-coercions.html"><strong aria-hidden="true">10.7.</strong> Type coercions</a></li><li class="expanded "><a href="destructors.html"><strong aria-hidden="true">10.8.</strong> Destructors</a></li><li class="expanded "><a href="lifetime-elision.html"><strong aria-hidden="true">10.9.</strong> Lifetime elision</a></li></ol></li><li class="expanded "><a href="special-types-and-traits.html"><strong aria-hidden="true">11.</strong> Special types and traits</a></li><li class="expanded "><a href="memory-model.html"><strong aria-hidden="true">12.</strong> Memory model</a></li><li><ol class="section"><li class="expanded "><a href="memory-allocation-and-lifetime.html"><strong aria-hidden="true">12.1.</strong> Memory allocation and lifetime</a></li><li class="expanded "><a href="memory-ownership.html"><strong aria-hidden="true">12.2.</strong> Memory ownership</a></li><li class="expanded "><a href="variables.html"><strong aria-hidden="true">12.3.</strong> Variables</a></li></ol></li><li class="expanded "><a href="linkage.html"><strong aria-hidden="true">13.</strong> Linkage</a></li><li class="expanded "><a href="unsafety.html"><strong aria-hidden="true">14.</strong> Unsafety</a></li><li><ol class="section"><li class="expanded "><a href="unsafe-functions.html"><strong aria-hidden="true">14.1.</strong> Unsafe functions</a></li><li class="expanded "><a href="unsafe-blocks.html"><strong aria-hidden="true">14.2.</strong> Unsafe blocks</a></li><li class="expanded "><a href="behavior-considered-undefined.html"><strong aria-hidden="true">14.3.</strong> Behavior considered undefined</a></li><li class="expanded "><a href="behavior-not-considered-unsafe.html"><strong aria-hidden="true">14.4.</strong> Behavior not considered unsafe</a></li></ol></li><li class="expanded "><a href="const_eval.html"><strong aria-hidden="true">15.</strong> Constant Evaluation</a></li><li class="expanded "><a href="abi.html"><strong aria-hidden="true">16.</strong> Application Binary Interface</a></li><li class="expanded "><a href="runtime.html"><strong aria-hidden="true">17.</strong> The Rust runtime</a></li><li class="expanded "><a href="appendices.html"><strong aria-hidden="true">18.</strong> Appendices</a></li><li><ol class="section"><li class="expanded "><a href="macro-ambiguity.html"><strong aria-hidden="true">18.1.</strong> Macro Follow-Set Ambiguity Formal Specification</a></li><li class="expanded "><a href="influences.html"><strong aria-hidden="true">18.2.</strong> Influences</a></li><li class="expanded "><a href="glossary.html"><strong aria-hidden="true">18.3.</strong> Glossary</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust 参考手册 - The Rust Language Reference</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                            <a href="https://github.com/zzy/rust-reference-zh" title="Git repository" aria-label="Git repository">
                                <i id="git-repository-button" class="fa fa-github"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>This book is the primary reference for the Rust programming language. It
provides three kinds of material:</p>
<ul>
<li>Chapters that informally describe each language construct and their use.</li>
<li>Chapters that informally describe the memory model, concurrency model,
runtime services, linkage model, and debugging facilities.</li>
<li>Appendix chapters providing rationale and references to languages that
influenced the design.</li>
</ul>
<div class="warning">
<p>Warning: This book is incomplete. Documenting everything takes a while. See
the <a href="https://github.com/rust-lang/reference/issues">GitHub issues</a> for what is not documented in this book.</p>
</div>
<h2><a class="header" href="#what-the-reference-is-not" id="what-the-reference-is-not">What <em>The Reference</em> is Not</a></h2>
<p>This book does not serve as an introduction to the language. Background
familiarity with the language is assumed. A separate <a href="../book/index.html">book</a> is available to
help acquire such background familiarity.</p>
<p>This book also does not serve as a reference to the <a href="../std/index.html">standard library</a>
included in the language distribution. Those libraries are documented
separately by extracting documentation attributes from their source code. Many
of the features that one might expect to be language features are library
features in Rust, so what you’re looking for may be there, not here.</p>
<p>Similarly, this book does not usually document the specifics of <code>rustc</code> as a
tool or of Cargo. <code>rustc</code> has its own <a href="../rustc/index.html">book</a>. Cargo has a
<a href="../cargo/index.html">book</a> that contains a <a href="../cargo/reference/index.html">reference</a>. There are a few
pages such as <a href="linkage.html">linkage</a> that still describe how <code>rustc</code> works.</p>
<p>This book also only serves as a reference to what is available in stable
Rust. For unstable features being worked on, see the <a href="https://doc.rust-lang.org/nightly/unstable-book/">Unstable Book</a>.</p>
<p>Finally, this book is not normative. It may include details that are
specific to <code>rustc</code> itself, and should not be taken as a specification for
the Rust language. We intend to produce such a book someday, and until then,
the reference is the closest thing we have to one.</p>
<h2><a class="header" href="#how-to-use-this-book" id="how-to-use-this-book">How to Use This Book</a></h2>
<p>This book does not assume you are reading this book sequentially. Each
chapter generally can be read standalone, but will cross-link to other chapters
for facets of the language they refer to, but do not discuss.</p>
<p>There are two main ways to read this document.</p>
<p>The first is to answer a specific question. If you know which chapter answers
that question, you can jump to that chapter in the table of contents. Otherwise,
you can press <code>s</code> or the click the magnifying glass on the top bar to search for
keywords related to your question. For example, say you wanted to know when a
temporary value created in a let statement is dropped. If you didn’t already
know that the <a href="expressions.html#temporary-lifetimes">lifetime of temporaries</a> is defined in the <a href="expressions.html">expressions chapter</a>,
you could search “temporary let” and the first search result will take you to
that section.</p>
<p>The second is to generally improve your knowledge of a facet of the language.
In that case, just browse the table of contents until you see something you
want to know more about, and just start reading. If a link looks interesting,
click it, and read about that section.</p>
<p>That said, there is no wrong way to read this book. Read it however you feel
helps you best.</p>
<h3><a class="header" href="#conventions" id="conventions">Conventions</a></h3>
<p>Like all technical books, this book has certain conventions in how it displays
information. These conventions are documented here.</p>
<ul>
<li>
<p>Statements that define a term contain that term in <em>italics</em>. Whenever that
term is used outside of that chapter, it is usually a link to the section that
has this definition.</p>
<p>An <em>example term</em> is an example of a term being defined.</p>
</li>
<li>
<p>Differences in the language by which edition the crate is compiled under are
in a blockquote that start with the words “Edition Differences:” in <strong>bold</strong>.</p>
<blockquote>
<p><strong>Edition Differences</strong>: In the 2015 edition, this syntax is valid that is
disallowed as of the 2018 edition.</p>
</blockquote>
</li>
<li>
<p>Notes that contain useful information about the state of the book or point out
useful, but mostly out of scope, information are in blockquotes that start
with the word “Note:” in <strong>bold</strong>.</p>
<blockquote>
<p><strong>Note</strong>: This is an example note.</p>
</blockquote>
</li>
<li>
<p>Warnings that show unsound behavior in the language or possibly confusing
interactions of language features are in a special warning box.</p>
<div class="warning">
<p>Warning: This is an example warning.</p>
</div>
</li>
<li>
<p>Code snippets inline in the text are inside <code>&lt;code&gt;</code> tags.</p>
<p>Longer code examples are in a syntax highlighted box that has controls for
copying, executing, and showing hidden lines in the top right corner.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">// This is a hidden line.
</span>fn main() {
    println!(&quot;This is a code example&quot;);
}
</code></pre></pre>
</li>
<li>
<p>The grammar and lexical structure is in blockquotes with either “Lexer” or
“Syntax” in <sup><strong>bold superscript</strong></sup> as the first line.</p>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ExampleGrammar</em>:<br />
      <code>~</code> <a href="expressions.html"><em>Expression</em></a><br />
   | <code>box</code> <a href="expressions.html"><em>Expression</em></a></p>
</blockquote>
<p>See <a href="notation.html">Notation</a> for more detail.</p>
</li>
</ul>
<h2><a class="header" href="#contributing" id="contributing">Contributing</a></h2>
<p>We welcome contributions of all kinds.</p>
<p>You can contribute to this book by opening an issue or sending a pull
request to <a href="https://github.com/rust-lang/reference/">the Rust Reference repository</a>. If this book does not answer
your question, and you think its answer is in scope of it, please do not
hesitate to file an issue or ask about it in the <code>#docs</code> channels on
<a href="https://discord.gg/rust-lang">Discord</a>. Knowing what people use this book for the most helps direct our
attention to making those sections the best that they can be.</p>
<h1><a class="header" href="#notation" id="notation">Notation</a></h1>
<h2><a class="header" href="#grammar" id="grammar">Grammar</a></h2>
<p>The following notations are used by the <em>Lexer</em> and <em>Syntax</em> grammar snippets:</p>
<table><thead><tr><th>Notation</th><th>Examples</th><th>Meaning</th></tr></thead><tbody>
<tr><td>CAPITAL</td><td>KW_IF, INTEGER_LITERAL</td><td>A token produced by the lexer</td></tr>
<tr><td><em>ItalicCamelCase</em></td><td><em>LetStatement</em>, <em>Item</em></td><td>A syntactical production</td></tr>
<tr><td><code>string</code></td><td><code>x</code>, <code>while</code>, <code>*</code></td><td>The exact character(s)</td></tr>
<tr><td>\x</td><td>\n, \r, \t, \0</td><td>The character represented by this escape</td></tr>
<tr><td>x<sup>?</sup></td><td><code>pub</code><sup>?</sup></td><td>An optional item</td></tr>
<tr><td>x<sup>*</sup></td><td><em>OuterAttribute</em><sup>*</sup></td><td>0 or more of x</td></tr>
<tr><td>x<sup>+</sup></td><td><em>MacroMatch</em><sup>+</sup></td><td>1 or more of x</td></tr>
<tr><td>x<sup>a..b</sup></td><td>HEX_DIGIT<sup>1..6</sup></td><td>a to b repetitions of x</td></tr>
<tr><td>|</td><td><code>u8</code> | <code>u16</code>, Block | Item</td><td>Either one or another</td></tr>
<tr><td>[ ]</td><td>[<code>b</code> <code>B</code>]</td><td>Any of the characters listed</td></tr>
<tr><td>[ - ]</td><td>[<code>a</code>-<code>z</code>]</td><td>Any of the characters in the range</td></tr>
<tr><td>~[ ]</td><td>~[<code>b</code> <code>B</code>]</td><td>Any characters, except those listed</td></tr>
<tr><td>~<code>string</code></td><td>~<code>\n</code>, ~<code>*/</code></td><td>Any characters, except this sequence</td></tr>
<tr><td>( )</td><td>(<code>,</code> <em>Parameter</em>)<sup>?</sup></td><td>Groups items</td></tr>
</tbody></table>
<h2><a class="header" href="#string-table-productions" id="string-table-productions">String table productions</a></h2>
<p>Some rules in the grammar — notably <a href="expressions/operator-expr.html#borrow-operators">unary operators</a>, <a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">binary
operators</a>, and <a href="keywords.html">keywords</a> — are given in a simplified form: as a listing
of printable strings. These cases form a subset of the rules regarding the
<a href="tokens.html">token</a> rule, and are assumed to be the result of a lexical-analysis
phase feeding the parser, driven by a <abbr title="Deterministic Finite
Automaton">DFA</abbr>, operating over the disjunction of all such string table
entries.</p>
<p>When such a string in <code>monospace</code> font occurs inside the grammar,
it is an implicit reference to a single member of such a string table
production. See <a href="tokens.html">tokens</a> for more information.</p>
<h1><a class="header" href="#lexical-structure" id="lexical-structure">Lexical structure</a></h1>
<h1><a class="header" href="#input-format" id="input-format">Input format</a></h1>
<p>Rust input is interpreted as a sequence of Unicode code points encoded in UTF-8.</p>
<h1><a class="header" href="#keywords" id="keywords">Keywords</a></h1>
<p>Rust divides keywords into three categories:</p>
<ul>
<li><a href="keywords.html#strict-keywords">strict</a></li>
<li><a href="keywords.html#reserved-keywords">reserved</a></li>
<li><a href="keywords.html#weak-keywords">weak</a></li>
</ul>
<h2><a class="header" href="#strict-keywords" id="strict-keywords">Strict keywords</a></h2>
<p>These keywords can only be used in their correct contexts. They cannot
be used as the names of:</p>
<ul>
<li><a href="items.html">Items</a></li>
<li><a href="variables.html">Variables</a> and function parameters</li>
<li>Fields and <a href="items/enumerations.html">variants</a></li>
<li><a href="types/parameters.html">Type parameters</a></li>
<li>Lifetime parameters or <a href="expressions/loop-expr.html#loop-labels">loop labels</a></li>
<li><a href="macros.html">Macros</a> or <a href="attributes.html">attributes</a></li>
<li><a href="macros-by-example.html">Macro placeholders</a></li>
<li><a href="crates-and-source-files.html">Crates</a></li>
</ul>
<blockquote>
<p><strong><sup>Lexer:<sup></strong><br />
KW_AS             : <code>as</code><br />
KW_BREAK          : <code>break</code><br />
KW_CONST          : <code>const</code><br />
KW_CONTINUE       : <code>continue</code><br />
KW_CRATE          : <code>crate</code><br />
KW_ELSE           : <code>else</code><br />
KW_ENUM           : <code>enum</code><br />
KW_EXTERN         : <code>extern</code><br />
KW_FALSE          : <code>false</code><br />
KW_FN             : <code>fn</code><br />
KW_FOR            : <code>for</code><br />
KW_IF             : <code>if</code><br />
KW_IMPL           : <code>impl</code><br />
KW_IN             : <code>in</code><br />
KW_LET            : <code>let</code><br />
KW_LOOP           : <code>loop</code><br />
KW_MATCH          : <code>match</code><br />
KW_MOD            : <code>mod</code><br />
KW_MOVE           : <code>move</code><br />
KW_MUT            : <code>mut</code><br />
KW_PUB            : <code>pub</code><br />
KW_REF            : <code>ref</code><br />
KW_RETURN         : <code>return</code><br />
KW_SELFVALUE      : <code>self</code><br />
KW_SELFTYPE       : <code>Self</code><br />
KW_STATIC         : <code>static</code><br />
KW_STRUCT         : <code>struct</code><br />
KW_SUPER          : <code>super</code><br />
KW_TRAIT          : <code>trait</code><br />
KW_TRUE           : <code>true</code><br />
KW_TYPE           : <code>type</code><br />
KW_UNSAFE         : <code>unsafe</code><br />
KW_USE            : <code>use</code><br />
KW_WHERE          : <code>where</code><br />
KW_WHILE          : <code>while</code></p>
</blockquote>
<p>The following keywords were added beginning in the 2018 edition.</p>
<blockquote>
<p><strong><sup>Lexer 2018+</sup></strong><br />
KW_ASYNC          : <code>async</code><br />
KW_AWAIT          : <code>await</code><br />
KW_DYN            : <code>dyn</code></p>
</blockquote>
<h2><a class="header" href="#reserved-keywords" id="reserved-keywords">Reserved keywords</a></h2>
<p>These keywords aren’t used yet, but they are reserved for future use. They have
the same restrictions as strict keywords. The reasoning behind this is to make
current programs forward compatible with future versions of Rust by forbidding
them to use these keywords.</p>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
KW_ABSTRACT       : <code>abstract</code><br />
KW_BECOME         : <code>become</code><br />
KW_BOX            : <code>box</code><br />
KW_DO             : <code>do</code><br />
KW_FINAL          : <code>final</code><br />
KW_MACRO          : <code>macro</code><br />
KW_OVERRIDE       : <code>override</code><br />
KW_PRIV           : <code>priv</code><br />
KW_TYPEOF         : <code>typeof</code><br />
KW_UNSIZED        : <code>unsized</code><br />
KW_VIRTUAL        : <code>virtual</code><br />
KW_YIELD          : <code>yield</code></p>
</blockquote>
<p>The following keywords are reserved beginning in the 2018 edition.</p>
<blockquote>
<p><strong><sup>Lexer 2018+</sup></strong><br />
KW_TRY   : <code>try</code></p>
</blockquote>
<h2><a class="header" href="#weak-keywords" id="weak-keywords">Weak keywords</a></h2>
<p>These keywords have special meaning only in certain contexts. For example, it
is possible to declare a variable or method with the name <code>union</code>.</p>
<ul>
<li>
<p><code>union</code> is used to declare a <a href="items/unions.html">union</a> and is only a keyword when used in a
union declaration.</p>
</li>
<li>
<p><code>'static</code> is used for the static lifetime and cannot be used as a generic
lifetime parameter</p>
<pre><code class="language-compile_fail">// error[E0262]: invalid lifetime parameter name: `'static`
fn invalid_lifetime_parameter&lt;'static&gt;(s: &amp;'static str) -&gt; &amp;'static str { s }
</code></pre>
</li>
<li>
<p>In the 2015 edition, <a href="types/trait-object.html"><code>dyn</code></a> is a keyword when used in a type position
followed by a path that does not start with <code>::</code>.</p>
<p>Beginning in the 2018 edition, <code>dyn</code> has been promoted to a strict keyword.</p>
</li>
</ul>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
KW_UNION          : <code>union</code><br />
KW_STATICLIFETIME : <code>'static</code></p>
<p><strong><sup>Lexer 2015</sup></strong><br />
KW_DYN            : <code>dyn</code></p>
</blockquote>
<h1><a class="header" href="#identifiers" id="identifiers">Identifiers</a></h1>
<blockquote>
<p><strong><sup>Lexer:<sup></strong><br />
IDENTIFIER_OR_KEYWORD :<br />
      [<code>a</code>-<code>z</code> <code>A</code>-<code>Z</code>] [<code>a</code>-<code>z</code> <code>A</code>-<code>Z</code> <code>0</code>-<code>9</code> <code>_</code>]<sup>*</sup><br />
   | <code>_</code> [<code>a</code>-<code>z</code> <code>A</code>-<code>Z</code> <code>0</code>-<code>9</code> <code>_</code>]<sup>+</sup></p>
<p>RAW_IDENTIFIER : <code>r#</code> IDENTIFIER_OR_KEYWORD <sub><em>Except <code>crate</code>, <code>self</code>, <code>super</code>, <code>Self</code></em></sub></p>
<p>NON_KEYWORD_IDENTIFIER : IDENTIFIER_OR_KEYWORD <sub><em>Except a <a href="keywords.html#strict-keywords">strict</a> or <a href="keywords.html#reserved-keywords">reserved</a> keyword</em></sub></p>
<p>IDENTIFIER :<br />
NON_KEYWORD_IDENTIFIER | RAW_IDENTIFIER</p>
</blockquote>
<p>An identifier is any nonempty ASCII string of the following form:</p>
<p>Either</p>
<ul>
<li>The first character is a letter.</li>
<li>The remaining characters are alphanumeric or <code>_</code>.</li>
</ul>
<p>Or</p>
<ul>
<li>The first character is <code>_</code>.</li>
<li>The identifier is more than one character. <code>_</code> alone is not an identifier.</li>
<li>The remaining characters are alphanumeric or <code>_</code>.</li>
</ul>
<p>A raw identifier is like a normal identifier, but prefixed by <code>r#</code>. (Note that
the <code>r#</code> prefix is not included as part of the actual identifier.)
Unlike a normal identifier, a raw identifier may be any strict or reserved
keyword except the ones listed above for <code>RAW_IDENTIFIER</code>.</p>
<h1><a class="header" href="#comments" id="comments">Comments</a></h1>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
LINE_COMMENT :<br />
      <code>//</code> (~[<code>/</code> <code>!</code>] | <code>//</code>) ~<code>\n</code><sup>*</sup><br />
   | <code>//</code></p>
<p>BLOCK_COMMENT :<br />
      <code>/*</code> (~[<code>*</code> <code>!</code>] | <code>**</code> | <em>BlockCommentOrDoc</em>)
(<em>BlockCommentOrDoc</em> | ~<code>*/</code>)<sup>*</sup> <code>*/</code><br />
   | <code>/**/</code><br />
   | <code>/***/</code></p>
<p>INNER_LINE_DOC :<br />
   <code>//!</code> ~[<code>\n</code> <em>IsolatedCR</em>]<sup>*</sup></p>
<p>INNER_BLOCK_DOC :<br />
   <code>/*!</code> ( <em>BlockCommentOrDoc</em> | ~[<code>*/</code> <em>IsolatedCR</em>] )<sup>*</sup> <code>*/</code></p>
<p>OUTER_LINE_DOC :<br />
   <code>///</code> (~<code>/</code> ~[<code>\n</code> <em>IsolatedCR</em>]<sup>*</sup>)<sup>?</sup></p>
<p>OUTER_BLOCK_DOC :<br />
   <code>/**</code> (~<code>*</code> | <em>BlockCommentOrDoc</em> )
(<em>BlockCommentOrDoc</em> | ~[<code>*/</code> <em>IsolatedCR</em>])<sup>*</sup> <code>*/</code></p>
<p><em>BlockCommentOrDoc</em> :<br />
      BLOCK_COMMENT<br />
   | OUTER_BLOCK_DOC<br />
   | INNER_BLOCK_DOC</p>
<p><em>IsolatedCR</em> :<br />
   <em>A <code>\r</code> not followed by a <code>\n</code></em></p>
</blockquote>
<h2><a class="header" href="#non-doc-comments" id="non-doc-comments">Non-doc comments</a></h2>
<p>Comments in Rust code follow the general C++ style of line (<code>//</code>) and
block (<code>/* ... */</code>) comment forms. Nested block comments are supported.</p>
<p>Non-doc comments are interpreted as a form of whitespace.</p>
<h2><a class="header" href="#doc-comments" id="doc-comments">Doc comments</a></h2>
<p>Line doc comments beginning with exactly <em>three</em> slashes (<code>///</code>), and block
doc comments (<code>/** ... */</code>), both inner doc comments, are interpreted as a
special syntax for <a href="../rustdoc/the-doc-attribute.html"><code>doc</code> attributes</a>. That is, they are equivalent to writing
<code>#[doc=&quot;...&quot;]</code> around the body of the comment, i.e., <code>/// Foo</code> turns into
<code>#[doc=&quot;Foo&quot;]</code> and <code>/** Bar */</code> turns into <code>#[doc=&quot;Bar&quot;]</code>.</p>
<p>Line comments beginning with <code>//!</code> and block comments <code>/*! ... */</code> are
doc comments that apply to the parent of the comment, rather than the item
that follows.  That is, they are equivalent to writing <code>#![doc=&quot;...&quot;]</code> around
the body of the comment. <code>//!</code> comments are usually used to document
modules that occupy a source file.</p>
<p>Isolated CRs (<code>\r</code>), i.e. not followed by LF (<code>\n</code>), are not allowed in doc
comments.</p>
<h2><a class="header" href="#examples" id="examples">Examples</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>//! A doc comment that applies to the implicit anonymous module of this crate

pub mod outer_module {

    //!  - Inner line doc
    //!! - Still an inner line doc (but with a bang at the beginning)

    /*!  - Inner block doc */
    /*!! - Still an inner block doc (but with a bang at the beginning) */

    //   - Only a comment
    ///  - Outer line doc (exactly 3 slashes)
    //// - Only a comment

    /*   - Only a comment */
    /**  - Outer block doc (exactly) 2 asterisks */
    /*** - Only a comment */

    pub mod inner_module {}

    pub mod nested_comments {
        /* In Rust /* we can /* nest comments */ */ */

        // All three types of block comments can contain or be nested inside
        // any other type:

        /*   /* */  /** */  /*! */  */
        /*!  /* */  /** */  /*! */  */
        /**  /* */  /** */  /*! */  */
        pub mod dummy_item {}
    }

    pub mod degenerate_cases {
        // empty inner line doc
        //!

        // empty inner block doc
        /*!*/

        // empty line comment
        //

        // empty outer line doc
        ///

        // empty block comment
        /**/

        pub mod dummy_item {}

        // empty 2-asterisk block isn't a doc block, it is a block comment
        /***/

    }

    /* The next one isn't allowed because outer doc comments
       require an item that will receive the doc */

    /// Where is my item?
<span class="boring">  mod boo {}
</span>}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#whitespace" id="whitespace">Whitespace</a></h1>
<p>Whitespace is any non-empty string containing only characters that have the
<code>Pattern_White_Space</code> Unicode property, namely:</p>
<ul>
<li><code>U+0009</code> (horizontal tab, <code>'\t'</code>)</li>
<li><code>U+000A</code> (line feed, <code>'\n'</code>)</li>
<li><code>U+000B</code> (vertical tab)</li>
<li><code>U+000C</code> (form feed)</li>
<li><code>U+000D</code> (carriage return, <code>'\r'</code>)</li>
<li><code>U+0020</code> (space, <code>' '</code>)</li>
<li><code>U+0085</code> (next line)</li>
<li><code>U+200E</code> (left-to-right mark)</li>
<li><code>U+200F</code> (right-to-left mark)</li>
<li><code>U+2028</code> (line separator)</li>
<li><code>U+2029</code> (paragraph separator)</li>
</ul>
<p>Rust is a “free-form” language, meaning that all forms of whitespace serve only
to separate <em>tokens</em> in the grammar, and have no semantic significance.</p>
<p>A Rust program has identical meaning if each whitespace element is replaced
with any other legal whitespace element, such as a single space character.</p>
<h1><a class="header" href="#tokens" id="tokens">Tokens</a></h1>
<p>Tokens are primitive productions in the grammar defined by regular
(non-recursive) languages.  Rust source input can be broken down
into the following kinds of tokens:</p>
<ul>
<li><a href="keywords.html">Keywords</a></li>
<li><a href="identifiers.html">Identifiers</a></li>
<li><a href="tokens.html#literals">Literals</a></li>
<li><a href="tokens.html#lifetimes-and-loop-labels">Lifetimes</a></li>
<li><a href="tokens.html#punctuation">Punctuation</a></li>
<li><a href="tokens.html#delimiters">Delimiters</a></li>
</ul>
<p>Within this documentation’s grammar, “simple” tokens are given in <a href="notation.html#string-table-productions">string
table production</a> form, and appear in <code>monospace</code> font.</p>
<h2><a class="header" href="#literals" id="literals">Literals</a></h2>
<p>A literal is an expression consisting of a single token, rather than a sequence
of tokens, that immediately and directly denotes the value it evaluates to,
rather than referring to it by name or some other evaluation rule. A literal is
a form of <a href="const_eval.html#constant-expressions">constant expression</a>, so is
evaluated (primarily) at compile time.</p>
<h3><a class="header" href="#examples-1" id="examples-1">Examples</a></h3>
<h4><a class="header" href="#characters-and-strings" id="characters-and-strings">Characters and strings</a></h4>
<table><thead><tr><th></th><th>Example</th><th><code>#</code> sets</th><th>Characters</th><th>Escapes</th></tr></thead><tbody>
<tr><td><a href="tokens.html#character-literals">Character</a></td><td><code>'H'</code></td><td>0</td><td>All Unicode</td><td><a href="tokens.html#quote-escapes">Quote</a> &amp; <a href="tokens.html#ascii-escapes">ASCII</a> &amp; <a href="tokens.html#unicode-escapes">Unicode</a></td></tr>
<tr><td><a href="tokens.html#string-literals">String</a></td><td><code>&quot;hello&quot;</code></td><td>0</td><td>All Unicode</td><td><a href="tokens.html#quote-escapes">Quote</a> &amp; <a href="tokens.html#ascii-escapes">ASCII</a> &amp; <a href="tokens.html#unicode-escapes">Unicode</a></td></tr>
<tr><td><a href="tokens.html#raw-string-literals">Raw string</a></td><td><code>r#&quot;hello&quot;#</code></td><td>0 or more*</td><td>All Unicode</td><td><code>N/A</code></td></tr>
<tr><td><a href="tokens.html#byte-literals">Byte</a></td><td><code>b'H'</code></td><td>0</td><td>All ASCII</td><td><a href="tokens.html#quote-escapes">Quote</a> &amp; <a href="tokens.html#byte-escapes">Byte</a></td></tr>
<tr><td><a href="tokens.html#byte-string-literals">Byte string</a></td><td><code>b&quot;hello&quot;</code></td><td>0</td><td>All ASCII</td><td><a href="tokens.html#quote-escapes">Quote</a> &amp; <a href="tokens.html#byte-escapes">Byte</a></td></tr>
<tr><td><a href="tokens.html#raw-byte-string-literals">Raw byte string</a></td><td><code>br#&quot;hello&quot;#</code></td><td>0 or more*</td><td>All ASCII</td><td><code>N/A</code></td></tr>
</tbody></table>
<p>* The number of <code>#</code>s on each side of the same literal must be equivalent</p>
<h4><a class="header" href="#ascii-escapes" id="ascii-escapes">ASCII escapes</a></h4>
<table><thead><tr><th></th><th>Name</th></tr></thead><tbody>
<tr><td><code>\x41</code></td><td>7-bit character code (exactly 2 digits, up to 0x7F)</td></tr>
<tr><td><code>\n</code></td><td>Newline</td></tr>
<tr><td><code>\r</code></td><td>Carriage return</td></tr>
<tr><td><code>\t</code></td><td>Tab</td></tr>
<tr><td><code>\\</code></td><td>Backslash</td></tr>
<tr><td><code>\0</code></td><td>Null</td></tr>
</tbody></table>
<h4><a class="header" href="#byte-escapes" id="byte-escapes">Byte escapes</a></h4>
<table><thead><tr><th></th><th>Name</th></tr></thead><tbody>
<tr><td><code>\x7F</code></td><td>8-bit character code (exactly 2 digits)</td></tr>
<tr><td><code>\n</code></td><td>Newline</td></tr>
<tr><td><code>\r</code></td><td>Carriage return</td></tr>
<tr><td><code>\t</code></td><td>Tab</td></tr>
<tr><td><code>\\</code></td><td>Backslash</td></tr>
<tr><td><code>\0</code></td><td>Null</td></tr>
</tbody></table>
<h4><a class="header" href="#unicode-escapes" id="unicode-escapes">Unicode escapes</a></h4>
<table><thead><tr><th></th><th>Name</th></tr></thead><tbody>
<tr><td><code>\u{7FFF}</code></td><td>24-bit Unicode character code (up to 6 digits)</td></tr>
</tbody></table>
<h4><a class="header" href="#quote-escapes" id="quote-escapes">Quote escapes</a></h4>
<table><thead><tr><th></th><th>Name</th></tr></thead><tbody>
<tr><td><code>\'</code></td><td>Single quote</td></tr>
<tr><td><code>\&quot;</code></td><td>Double quote</td></tr>
</tbody></table>
<h4><a class="header" href="#numbers" id="numbers">Numbers</a></h4>
<table><thead><tr><th><a href="tokens.html#number-literals">Number literals</a><code>*</code></th><th>Example</th><th>Exponentiation</th><th>Suffixes</th></tr></thead><tbody>
<tr><td>Decimal integer</td><td><code>98_222</code></td><td><code>N/A</code></td><td>Integer suffixes</td></tr>
<tr><td>Hex integer</td><td><code>0xff</code></td><td><code>N/A</code></td><td>Integer suffixes</td></tr>
<tr><td>Octal integer</td><td><code>0o77</code></td><td><code>N/A</code></td><td>Integer suffixes</td></tr>
<tr><td>Binary integer</td><td><code>0b1111_0000</code></td><td><code>N/A</code></td><td>Integer suffixes</td></tr>
<tr><td>Floating-point</td><td><code>123.0E+77</code></td><td><code>Optional</code></td><td>Floating-point suffixes</td></tr>
</tbody></table>
<p><code>*</code> All number literals allow <code>_</code> as a visual separator: <code>1_234.0E+18f64</code></p>
<h4><a class="header" href="#suffixes" id="suffixes">Suffixes</a></h4>
<p>A suffix is a non-raw identifier immediately (without whitespace)
following the primary part of a literal.</p>
<p>Any kind of literal (string, integer, etc) with any suffix is valid as a token,
and can be passed to a macro without producing an error.
The macro itself will decide how to interpret such a token and whether to produce an error or not.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>macro_rules! blackhole { ($tt:tt) =&gt; () }

blackhole!(&quot;string&quot;suffix); // OK
<span class="boring">}
</span></code></pre></pre>
<p>However, suffixes on literal tokens parsed as Rust code are restricted.
Any suffixes are rejected on non-numeric literal tokens,
and numeric literal tokens are accepted only with suffixes from the list below.</p>
<table><thead><tr><th>Integer</th><th>Floating-point</th></tr></thead><tbody>
<tr><td><code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>, <code>i64</code>, <code>u128</code>, <code>i128</code>, <code>usize</code>, <code>isize</code></td><td><code>f32</code>, <code>f64</code></td></tr>
</tbody></table>
<h3><a class="header" href="#character-and-string-literals" id="character-and-string-literals">Character and string literals</a></h3>
<h4><a class="header" href="#character-literals" id="character-literals">Character literals</a></h4>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
CHAR_LITERAL :<br />
   <code>'</code> ( ~[<code>'</code> <code>\</code> \n \r \t] | QUOTE_ESCAPE | ASCII_ESCAPE | UNICODE_ESCAPE ) <code>'</code></p>
<p>QUOTE_ESCAPE :<br />
   <code>\'</code> | <code>\&quot;</code></p>
<p>ASCII_ESCAPE :<br />
      <code>\x</code> OCT_DIGIT HEX_DIGIT<br />
   | <code>\n</code> | <code>\r</code> | <code>\t</code> | <code>\\</code> | <code>\0</code></p>
<p>UNICODE_ESCAPE :<br />
   <code>\u{</code> ( HEX_DIGIT <code>_</code><sup>*</sup> )<sup>1..6</sup> <code>}</code></p>
</blockquote>
<p>A <em>character literal</em> is a single Unicode character enclosed within two
<code>U+0027</code> (single-quote) characters, with the exception of <code>U+0027</code> itself,
which must be <em>escaped</em> by a preceding <code>U+005C</code> character (<code>\</code>).</p>
<h4><a class="header" href="#string-literals" id="string-literals">String literals</a></h4>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
STRING_LITERAL :<br />
   <code>&quot;</code> (<br />
      ~[<code>&quot;</code> <code>\</code> <em>IsolatedCR</em>]<br />
      | QUOTE_ESCAPE<br />
      | ASCII_ESCAPE<br />
      | UNICODE_ESCAPE<br />
      | STRING_CONTINUE<br />
   )<sup>*</sup> <code>&quot;</code></p>
<p>STRING_CONTINUE :<br />
   <code>\</code> <em>followed by</em> \n</p>
</blockquote>
<p>A <em>string literal</em> is a sequence of any Unicode characters enclosed within two
<code>U+0022</code> (double-quote) characters, with the exception of <code>U+0022</code> itself,
which must be <em>escaped</em> by a preceding <code>U+005C</code> character (<code>\</code>).</p>
<p>Line-breaks are allowed in string literals. A line-break is either a newline
(<code>U+000A</code>) or a pair of carriage return and newline (<code>U+000D</code>, <code>U+000A</code>). Both
byte sequences are normally translated to <code>U+000A</code>, but as a special exception,
when an unescaped <code>U+005C</code> character (<code>\</code>) occurs immediately before the
line-break, the <code>U+005C</code> character, the line-break, and all whitespace at the
beginning of the next line are ignored. Thus <code>a</code> and <code>b</code> are equal:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = &quot;foobar&quot;;
let b = &quot;foo\
         bar&quot;;

assert_eq!(a,b);
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#character-escapes" id="character-escapes">Character escapes</a></h4>
<p>Some additional <em>escapes</em> are available in either character or non-raw string
literals. An escape starts with a <code>U+005C</code> (<code>\</code>) and continues with one of the
following forms:</p>
<ul>
<li>A <em>7-bit code point escape</em> starts with <code>U+0078</code> (<code>x</code>) and is
followed by exactly two <em>hex digits</em> with value up to <code>0x7F</code>. It denotes the
ASCII character with value equal to the provided hex value. Higher values are
not permitted because it is ambiguous whether they mean Unicode code points or
byte values.</li>
<li>A <em>24-bit code point escape</em> starts with <code>U+0075</code> (<code>u</code>) and is followed
by up to six <em>hex digits</em> surrounded by braces <code>U+007B</code> (<code>{</code>) and <code>U+007D</code>
(<code>}</code>). It denotes the Unicode code point equal to the provided hex value.</li>
<li>A <em>whitespace escape</em> is one of the characters <code>U+006E</code> (<code>n</code>), <code>U+0072</code>
(<code>r</code>), or <code>U+0074</code> (<code>t</code>), denoting the Unicode values <code>U+000A</code> (LF),
<code>U+000D</code> (CR) or <code>U+0009</code> (HT) respectively.</li>
<li>The <em>null escape</em> is the character <code>U+0030</code> (<code>0</code>) and denotes the Unicode
value <code>U+0000</code> (NUL).</li>
<li>The <em>backslash escape</em> is the character <code>U+005C</code> (<code>\</code>) which must be
escaped in order to denote itself.</li>
</ul>
<h4><a class="header" href="#raw-string-literals" id="raw-string-literals">Raw string literals</a></h4>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
RAW_STRING_LITERAL :<br />
   <code>r</code> RAW_STRING_CONTENT</p>
<p>RAW_STRING_CONTENT :<br />
      <code>&quot;</code> ( ~ <em>IsolatedCR</em> )<sup>* (non-greedy)</sup> <code>&quot;</code><br />
   | <code>#</code> RAW_STRING_CONTENT <code>#</code></p>
</blockquote>
<p>Raw string literals do not process any escapes. They start with the character
<code>U+0072</code> (<code>r</code>), followed by zero or more of the character <code>U+0023</code> (<code>#</code>) and a
<code>U+0022</code> (double-quote) character. The <em>raw string body</em> can contain any sequence
of Unicode characters and is terminated only by another <code>U+0022</code> (double-quote)
character, followed by the same number of <code>U+0023</code> (<code>#</code>) characters that preceded
the opening <code>U+0022</code> (double-quote) character.</p>
<p>All Unicode characters contained in the raw string body represent themselves,
the characters <code>U+0022</code> (double-quote) (except when followed by at least as
many <code>U+0023</code> (<code>#</code>) characters as were used to start the raw string literal) or
<code>U+005C</code> (<code>\</code>) do not have any special meaning.</p>
<p>Examples for string literals:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>&quot;foo&quot;; r&quot;foo&quot;;                     // foo
&quot;\&quot;foo\&quot;&quot;; r#&quot;&quot;foo&quot;&quot;#;             // &quot;foo&quot;

&quot;foo #\&quot;# bar&quot;;
r##&quot;foo #&quot;# bar&quot;##;                // foo #&quot;# bar

&quot;\x52&quot;; &quot;R&quot;; r&quot;R&quot;;                 // R
&quot;\\x52&quot;; r&quot;\x52&quot;;                  // \x52
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#byte-and-byte-string-literals" id="byte-and-byte-string-literals">Byte and byte string literals</a></h3>
<h4><a class="header" href="#byte-literals" id="byte-literals">Byte literals</a></h4>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
BYTE_LITERAL :<br />
   <code>b'</code> ( ASCII_FOR_CHAR | BYTE_ESCAPE )  <code>'</code></p>
<p>ASCII_FOR_CHAR :<br />
   <em>any ASCII (i.e. 0x00 to 0x7F), except</em> <code>'</code>, <code>\</code>, \n, \r or \t</p>
<p>BYTE_ESCAPE :<br />
      <code>\x</code> HEX_DIGIT HEX_DIGIT<br />
   | <code>\n</code> | <code>\r</code> | <code>\t</code> | <code>\\</code> | <code>\0</code></p>
</blockquote>
<p>A <em>byte literal</em> is a single ASCII character (in the <code>U+0000</code> to <code>U+007F</code>
range) or a single <em>escape</em> preceded by the characters <code>U+0062</code> (<code>b</code>) and
<code>U+0027</code> (single-quote), and followed by the character <code>U+0027</code>. If the character
<code>U+0027</code> is present within the literal, it must be <em>escaped</em> by a preceding
<code>U+005C</code> (<code>\</code>) character. It is equivalent to a <code>u8</code> unsigned 8-bit integer
<em>number literal</em>.</p>
<h4><a class="header" href="#byte-string-literals" id="byte-string-literals">Byte string literals</a></h4>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
BYTE_STRING_LITERAL :<br />
   <code>b&quot;</code> ( ASCII_FOR_STRING | BYTE_ESCAPE | STRING_CONTINUE )<sup>*</sup> <code>&quot;</code></p>
<p>ASCII_FOR_STRING :<br />
   <em>any ASCII (i.e 0x00 to 0x7F), except</em> <code>&quot;</code>, <code>\</code> <em>and IsolatedCR</em></p>
</blockquote>
<p>A non-raw <em>byte string literal</em> is a sequence of ASCII characters and <em>escapes</em>,
preceded by the characters <code>U+0062</code> (<code>b</code>) and <code>U+0022</code> (double-quote), and
followed by the character <code>U+0022</code>. If the character <code>U+0022</code> is present within
the literal, it must be <em>escaped</em> by a preceding <code>U+005C</code> (<code>\</code>) character.
Alternatively, a byte string literal can be a <em>raw byte string literal</em>, defined
below. The type of a byte string literal of length <code>n</code> is <code>&amp;'static [u8; n]</code>.</p>
<p>Some additional <em>escapes</em> are available in either byte or non-raw byte string
literals. An escape starts with a <code>U+005C</code> (<code>\</code>) and continues with one of the
following forms:</p>
<ul>
<li>A <em>byte escape</em> escape starts with <code>U+0078</code> (<code>x</code>) and is
followed by exactly two <em>hex digits</em>. It denotes the byte
equal to the provided hex value.</li>
<li>A <em>whitespace escape</em> is one of the characters <code>U+006E</code> (<code>n</code>), <code>U+0072</code>
(<code>r</code>), or <code>U+0074</code> (<code>t</code>), denoting the bytes values <code>0x0A</code> (ASCII LF),
<code>0x0D</code> (ASCII CR) or <code>0x09</code> (ASCII HT) respectively.</li>
<li>The <em>null escape</em> is the character <code>U+0030</code> (<code>0</code>) and denotes the byte
value <code>0x00</code> (ASCII NUL).</li>
<li>The <em>backslash escape</em> is the character <code>U+005C</code> (<code>\</code>) which must be
escaped in order to denote its ASCII encoding <code>0x5C</code>.</li>
</ul>
<h4><a class="header" href="#raw-byte-string-literals" id="raw-byte-string-literals">Raw byte string literals</a></h4>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
RAW_BYTE_STRING_LITERAL :<br />
   <code>br</code> RAW_BYTE_STRING_CONTENT</p>
<p>RAW_BYTE_STRING_CONTENT :<br />
      <code>&quot;</code> ASCII<sup>* (non-greedy)</sup> <code>&quot;</code><br />
   | <code>#</code> RAW_STRING_CONTENT <code>#</code></p>
<p>ASCII :<br />
   <em>any ASCII (i.e. 0x00 to 0x7F)</em></p>
</blockquote>
<p>Raw byte string literals do not process any escapes. They start with the
character <code>U+0062</code> (<code>b</code>), followed by <code>U+0072</code> (<code>r</code>), followed by zero or more
of the character <code>U+0023</code> (<code>#</code>), and a <code>U+0022</code> (double-quote) character. The
<em>raw string body</em> can contain any sequence of ASCII characters and is terminated
only by another <code>U+0022</code> (double-quote) character, followed by the same number of
<code>U+0023</code> (<code>#</code>) characters that preceded the opening <code>U+0022</code> (double-quote)
character. A raw byte string literal can not contain any non-ASCII byte.</p>
<p>All characters contained in the raw string body represent their ASCII encoding,
the characters <code>U+0022</code> (double-quote) (except when followed by at least as
many <code>U+0023</code> (<code>#</code>) characters as were used to start the raw string literal) or
<code>U+005C</code> (<code>\</code>) do not have any special meaning.</p>
<p>Examples for byte string literals:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>b&quot;foo&quot;; br&quot;foo&quot;;                     // foo
b&quot;\&quot;foo\&quot;&quot;; br#&quot;&quot;foo&quot;&quot;#;             // &quot;foo&quot;

b&quot;foo #\&quot;# bar&quot;;
br##&quot;foo #&quot;# bar&quot;##;                 // foo #&quot;# bar

b&quot;\x52&quot;; b&quot;R&quot;; br&quot;R&quot;;                // R
b&quot;\\x52&quot;; br&quot;\x52&quot;;                  // \x52
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#number-literals" id="number-literals">Number literals</a></h3>
<p>A <em>number literal</em> is either an <em>integer literal</em> or a <em>floating-point
literal</em>. The grammar for recognizing the two kinds of literals is mixed.</p>
<h4><a class="header" href="#integer-literals" id="integer-literals">Integer literals</a></h4>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
INTEGER_LITERAL :<br />
   ( DEC_LITERAL | BIN_LITERAL | OCT_LITERAL | HEX_LITERAL )
INTEGER_SUFFIX<sup>?</sup></p>
<p>DEC_LITERAL :<br />
   DEC_DIGIT (DEC_DIGIT|<code>_</code>)<sup>*</sup></p>
<p>TUPLE_INDEX :<br />
      <code>0</code>
   | NON_ZERO_DEC_DIGIT DEC_DIGIT<sup>*</sup></p>
<p>BIN_LITERAL :<br />
   <code>0b</code> (BIN_DIGIT|<code>_</code>)<sup>*</sup> BIN_DIGIT (BIN_DIGIT|<code>_</code>)<sup>*</sup></p>
<p>OCT_LITERAL :<br />
   <code>0o</code> (OCT_DIGIT|<code>_</code>)<sup>*</sup> OCT_DIGIT (OCT_DIGIT|<code>_</code>)<sup>*</sup></p>
<p>HEX_LITERAL :<br />
   <code>0x</code> (HEX_DIGIT|<code>_</code>)<sup>*</sup> HEX_DIGIT (HEX_DIGIT|<code>_</code>)<sup>*</sup></p>
<p>BIN_DIGIT : [<code>0</code>-<code>1</code>]</p>
<p>OCT_DIGIT : [<code>0</code>-<code>7</code>]</p>
<p>DEC_DIGIT : [<code>0</code>-<code>9</code>]</p>
<p>NON_ZERO_DEC_DIGIT : [<code>1</code>-<code>9</code>]</p>
<p>HEX_DIGIT : [<code>0</code>-<code>9</code> <code>a</code>-<code>f</code> <code>A</code>-<code>F</code>]</p>
<p>INTEGER_SUFFIX :<br />
      <code>u8</code> | <code>u16</code> | <code>u32</code> | <code>u64</code> | <code>u128</code> | <code>usize</code><br />
   | <code>i8</code> | <code>i16</code> | <code>i32</code> | <code>i64</code> | <code>i128</code> | <code>isize</code></p>
</blockquote>
<p>An <em>integer literal</em> has one of four forms:</p>
<ul>
<li>A <em>decimal literal</em> starts with a <em>decimal digit</em> and continues with any
mixture of <em>decimal digits</em> and <em>underscores</em>.</li>
<li>A <em>tuple index</em> is either <code>0</code>, or starts with a <em>non-zero decimal digit</em> and
continues with zero or more decimal digits. Tuple indexes are used to refer
to the fields of <a href="types/tuple.html">tuples</a>, <a href="items/structs.html">tuple structs</a>, and <a href="items/enumerations.html">tuple variants</a>.</li>
<li>A <em>hex literal</em> starts with the character sequence <code>U+0030</code> <code>U+0078</code>
(<code>0x</code>) and continues as any mixture (with at least one digit) of hex digits
and underscores.</li>
<li>An <em>octal literal</em> starts with the character sequence <code>U+0030</code> <code>U+006F</code>
(<code>0o</code>) and continues as any mixture (with at least one digit) of octal digits
and underscores.</li>
<li>A <em>binary literal</em> starts with the character sequence <code>U+0030</code> <code>U+0062</code>
(<code>0b</code>) and continues as any mixture (with at least one digit) of binary digits
and underscores.</li>
</ul>
<p>Like any literal, an integer literal may be followed (immediately,
without any spaces) by an <em>integer suffix</em>, which forcibly sets the
type of the literal. The integer suffix must be the name of one of the
integral types: <code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code>, <code>i64</code>,
<code>u128</code>, <code>i128</code>, <code>usize</code>, or <code>isize</code>.</p>
<p>The type of an <em>unsuffixed</em> integer literal is determined by type inference:</p>
<ul>
<li>
<p>If an integer type can be <em>uniquely</em> determined from the surrounding
program context, the unsuffixed integer literal has that type.</p>
</li>
<li>
<p>If the program context under-constrains the type, it defaults to the
signed 32-bit integer <code>i32</code>.</p>
</li>
<li>
<p>If the program context over-constrains the type, it is considered a
static type error.</p>
</li>
</ul>
<p>Examples of integer literals of various forms:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>123;                               // type i32
123i32;                            // type i32
123u32;                            // type u32
123_u32;                           // type u32
let a: u64 = 123;                  // type u64

0xff;                              // type i32
0xff_u8;                           // type u8

0o70;                              // type i32
0o70_i16;                          // type i16

0b1111_1111_1001_0000;             // type i32
0b1111_1111_1001_0000i64;          // type i64
0b________1;                       // type i32

0usize;                            // type usize
<span class="boring">}
</span></code></pre></pre>
<p>Examples of invalid integer literals:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// invalid suffixes

0invalidSuffix;

// uses numbers of the wrong base

123AFB43;
0b0102;
0o0581;

// integers too big for their type (they overflow)

128_i8;
256_u8;

// bin, hex, and octal literals must have at least one digit

0b_;
0b____;
<span class="boring">}
</span></code></pre></pre>
<p>Note that the Rust syntax considers <code>-1i8</code> as an application of the <a href="expressions/operator-expr.html#negation-operators">unary minus
operator</a> to an integer literal <code>1i8</code>, rather than
a single integer literal.</p>
<h4><a class="header" href="#floating-point-literals" id="floating-point-literals">Floating-point literals</a></h4>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
FLOAT_LITERAL :<br />
      DEC_LITERAL <code>.</code>
<em>(not immediately followed by <code>.</code>, <code>_</code> or an <a href="identifiers.html">identifier</a></em>)<br />
   | DEC_LITERAL FLOAT_EXPONENT<br />
   | DEC_LITERAL <code>.</code> DEC_LITERAL FLOAT_EXPONENT<sup>?</sup><br />
   | DEC_LITERAL (<code>.</code> DEC_LITERAL)<sup>?</sup>
FLOAT_EXPONENT<sup>?</sup> FLOAT_SUFFIX</p>
<p>FLOAT_EXPONENT :<br />
   (<code>e</code>|<code>E</code>) (<code>+</code>|<code>-</code>)?
(DEC_DIGIT|<code>_</code>)<sup>*</sup> DEC_DIGIT (DEC_DIGIT|<code>_</code>)<sup>*</sup></p>
<p>FLOAT_SUFFIX :<br />
   <code>f32</code> | <code>f64</code></p>
</blockquote>
<p>A <em>floating-point literal</em> has one of two forms:</p>
<ul>
<li>A <em>decimal literal</em> followed by a period character <code>U+002E</code> (<code>.</code>). This is
optionally followed by another decimal literal, with an optional <em>exponent</em>.</li>
<li>A single <em>decimal literal</em> followed by an <em>exponent</em>.</li>
</ul>
<p>Like integer literals, a floating-point literal may be followed by a
suffix, so long as the pre-suffix part does not end with <code>U+002E</code> (<code>.</code>).
The suffix forcibly sets the type of the literal. There are two valid
<em>floating-point suffixes</em>, <code>f32</code> and <code>f64</code> (the 32-bit and 64-bit floating point
types), which explicitly determine the type of the literal.</p>
<p>The type of an <em>unsuffixed</em> floating-point literal is determined by
type inference:</p>
<ul>
<li>
<p>If a floating-point type can be <em>uniquely</em> determined from the
surrounding program context, the unsuffixed floating-point literal
has that type.</p>
</li>
<li>
<p>If the program context under-constrains the type, it defaults to <code>f64</code>.</p>
</li>
<li>
<p>If the program context over-constrains the type, it is considered a
static type error.</p>
</li>
</ul>
<p>Examples of floating-point literals of various forms:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>123.0f64;        // type f64
0.1f64;          // type f64
0.1f32;          // type f32
12E+99_f64;      // type f64
let x: f64 = 2.; // type f64
<span class="boring">}
</span></code></pre></pre>
<p>This last example is different because it is not possible to use the suffix
syntax with a floating point literal ending in a period. <code>2.f64</code> would attempt
to call a method named <code>f64</code> on <code>2</code>.</p>
<p>The representation semantics of floating-point numbers are described in
<a href="types/numeric.html">“Machine Types”</a>.</p>
<h3><a class="header" href="#boolean-literals" id="boolean-literals">Boolean literals</a></h3>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
BOOLEAN_LITERAL :<br />
      <code>true</code><br />
   | <code>false</code></p>
</blockquote>
<p>The two values of the boolean type are written <code>true</code> and <code>false</code>.</p>
<h2><a class="header" href="#lifetimes-and-loop-labels" id="lifetimes-and-loop-labels">Lifetimes and loop labels</a></h2>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
LIFETIME_TOKEN :<br />
      <code>'</code> <a href="identifiers.html">IDENTIFIER_OR_KEYWORD</a><br />
   | <code>'_</code></p>
<p>LIFETIME_OR_LABEL :<br />
      <code>'</code> <a href="identifiers.html">NON_KEYWORD_IDENTIFIER</a></p>
</blockquote>
<p>Lifetime parameters and <a href="expressions/loop-expr.html">loop labels</a> use LIFETIME_OR_LABEL tokens. Any
LIFETIME_TOKEN will be accepted by the lexer, and for example, can be used in
macros.</p>
<h2><a class="header" href="#punctuation" id="punctuation">Punctuation</a></h2>
<p>Punctuation symbol tokens are listed here for completeness. Their individual
usages and meanings are defined in the linked pages.</p>
<table><thead><tr><th>Symbol</th><th>Name</th><th>Usage</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>Plus</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">Addition</a>, <a href="trait-bounds.html">Trait Bounds</a>, <a href="macros-by-example.html">Macro Kleene Matcher</a></td></tr>
<tr><td><code>-</code></td><td>Minus</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">Subtraction</a>, <a href="expressions/operator-expr.html#negation-operators">Negation</a></td></tr>
<tr><td><code>*</code></td><td>Star</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">Multiplication</a>, <a href="expressions/operator-expr.html#the-dereference-operator">Dereference</a>, <a href="types/pointer.html#raw-pointers-const-and-mut">Raw Pointers</a>, <a href="macros-by-example.html">Macro Kleene Matcher</a></td></tr>
<tr><td><code>/</code></td><td>Slash</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">Division</a></td></tr>
<tr><td><code>%</code></td><td>Percent</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">Remainder</a></td></tr>
<tr><td><code>^</code></td><td>Caret</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">Bitwise and Logical XOR</a></td></tr>
<tr><td><code>!</code></td><td>Not</td><td><a href="expressions/operator-expr.html#negation-operators">Bitwise and Logical NOT</a>, <a href="macros-by-example.html">Macro Calls</a>, <a href="attributes.html">Inner Attributes</a>, <a href="types/never.html">Never Type</a></td></tr>
<tr><td><code>&amp;</code></td><td>And</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">Bitwise and Logical AND</a>, <a href="expressions/operator-expr.html#borrow-operators">Borrow</a>, <a href="types/pointer.html">References</a>, <a href="patterns.html#reference-patterns">Reference patterns</a></td></tr>
<tr><td><code>|</code></td><td>Or</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">Bitwise and Logical OR</a>, <a href="expressions/closure-expr.html">Closures</a>, <a href="expressions/match-expr.html">Match</a></td></tr>
<tr><td><code>&amp;&amp;</code></td><td>AndAnd</td><td><a href="expressions/operator-expr.html#lazy-boolean-operators">Lazy AND</a>, <a href="expressions/operator-expr.html#borrow-operators">Borrow</a>, <a href="types/pointer.html">References</a>, <a href="patterns.html#reference-patterns">Reference patterns</a></td></tr>
<tr><td><code>||</code></td><td>OrOr</td><td><a href="expressions/operator-expr.html#lazy-boolean-operators">Lazy OR</a>, <a href="expressions/closure-expr.html">Closures</a></td></tr>
<tr><td><code>&lt;&lt;</code></td><td>Shl</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">Shift Left</a>, <a href="items/generics.html">Nested Generics</a></td></tr>
<tr><td><code>&gt;&gt;</code></td><td>Shr</td><td><a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">Shift Right</a>, <a href="items/generics.html">Nested Generics</a></td></tr>
<tr><td><code>+=</code></td><td>PlusEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">Addition assignment</a></td></tr>
<tr><td><code>-=</code></td><td>MinusEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">Subtraction assignment</a></td></tr>
<tr><td><code>*=</code></td><td>StarEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">Multiplication assignment</a></td></tr>
<tr><td><code>/=</code></td><td>SlashEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">Division assignment</a></td></tr>
<tr><td><code>%=</code></td><td>PercentEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">Remainder assignment</a></td></tr>
<tr><td><code>^=</code></td><td>CaretEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">Bitwise XOR assignment</a></td></tr>
<tr><td><code>&amp;=</code></td><td>AndEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">Bitwise And assignment</a></td></tr>
<tr><td><code>|=</code></td><td>OrEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">Bitwise Or assignment</a></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td>ShlEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">Shift Left assignment</a></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td>ShrEq</td><td><a href="expressions/operator-expr.html#compound-assignment-expressions">Shift Right assignment</a>, <a href="items/generics.html">Nested Generics</a></td></tr>
<tr><td><code>=</code></td><td>Eq</td><td><a href="expressions/operator-expr.html#assignment-expressions">Assignment</a>, <a href="attributes.html">Attributes</a>, Various type definitions</td></tr>
<tr><td><code>==</code></td><td>EqEq</td><td><a href="expressions/operator-expr.html#comparison-operators">Equal</a></td></tr>
<tr><td><code>!=</code></td><td>Ne</td><td><a href="expressions/operator-expr.html#comparison-operators">Not Equal</a></td></tr>
<tr><td><code>&gt;</code></td><td>Gt</td><td><a href="expressions/operator-expr.html#comparison-operators">Greater than</a>, <a href="items/generics.html">Generics</a>, <a href="paths.html">Paths</a></td></tr>
<tr><td><code>&lt;</code></td><td>Lt</td><td><a href="expressions/operator-expr.html#comparison-operators">Less than</a>, <a href="items/generics.html">Generics</a>, <a href="paths.html">Paths</a></td></tr>
<tr><td><code>&gt;=</code></td><td>Ge</td><td><a href="expressions/operator-expr.html#comparison-operators">Greater than or equal to</a>, <a href="items/generics.html">Generics</a></td></tr>
<tr><td><code>&lt;=</code></td><td>Le</td><td><a href="expressions/operator-expr.html#comparison-operators">Less than or equal to</a></td></tr>
<tr><td><code>@</code></td><td>At</td><td><a href="patterns.html#identifier-patterns">Subpattern binding</a></td></tr>
<tr><td><code>_</code></td><td>Underscore</td><td><a href="patterns.html#wildcard-pattern">Wildcard patterns</a>, <a href="types/inferred.html">Inferred types</a></td></tr>
<tr><td><code>.</code></td><td>Dot</td><td><a href="expressions/field-expr.html">Field access</a>, <a href="expressions/tuple-expr.html#tuple-indexing-expressions">Tuple index</a></td></tr>
<tr><td><code>..</code></td><td>DotDot</td><td><a href="expressions/range-expr.html">Range</a>, <a href="expressions/struct-expr.html">Struct expressions</a>, <a href="patterns.html">Patterns</a></td></tr>
<tr><td><code>...</code></td><td>DotDotDot</td><td><a href="items/external-blocks.html">Variadic functions</a>, <a href="patterns.html#range-patterns">Range patterns</a></td></tr>
<tr><td><code>..=</code></td><td>DotDotEq</td><td><a href="expressions/range-expr.html">Inclusive Range</a>, <a href="patterns.html#range-patterns">Range patterns</a></td></tr>
<tr><td><code>,</code></td><td>Comma</td><td>Various separators</td></tr>
<tr><td><code>;</code></td><td>Semi</td><td>Terminator for various items and statements, <a href="types/array.html">Array types</a></td></tr>
<tr><td><code>:</code></td><td>Colon</td><td>Various separators</td></tr>
<tr><td><code>::</code></td><td>PathSep</td><td><a href="paths.html">Path separator</a></td></tr>
<tr><td><code>-&gt;</code></td><td>RArrow</td><td><a href="items/functions.html">Function return type</a>, <a href="expressions/closure-expr.html">Closure return type</a></td></tr>
<tr><td><code>=&gt;</code></td><td>FatArrow</td><td><a href="expressions/match-expr.html">Match arms</a>, <a href="macros-by-example.html">Macros</a></td></tr>
<tr><td><code>#</code></td><td>Pound</td><td><a href="attributes.html">Attributes</a></td></tr>
<tr><td><code>$</code></td><td>Dollar</td><td><a href="macros-by-example.html">Macros</a></td></tr>
<tr><td><code>?</code></td><td>Question</td><td><a href="expressions/operator-expr.html#the-question-mark-operator">Question mark operator</a>, <a href="trait-bounds.html#sized">Questionably sized</a>, <a href="macros-by-example.html">Macro Kleene Matcher</a></td></tr>
</tbody></table>
<h2><a class="header" href="#delimiters" id="delimiters">Delimiters</a></h2>
<p>Bracket punctuation is used in various parts of the grammar. An open bracket
must always be paired with a close bracket. Brackets and the tokens within
them are referred to as “token trees” in <a href="macros-by-example.html">macros</a>.  The three types of brackets are:</p>
<table><thead><tr><th>Bracket</th><th>Type</th></tr></thead><tbody>
<tr><td><code>{</code> <code>}</code></td><td>Curly braces</td></tr>
<tr><td><code>[</code> <code>]</code></td><td>Square brackets</td></tr>
<tr><td><code>(</code> <code>)</code></td><td>Parentheses</td></tr>
</tbody></table>
<h1><a class="header" href="#paths" id="paths">Paths</a></h1>
<p>A <em>path</em> is a sequence of one or more path segments <em>logically</em> separated by
a namespace <span class="parenthetical">qualifier (<code>::</code>)</span>. If a path
consists of only one segment, it refers to either an <a href="items.html">item</a> or a <a href="variables.html">variable</a> in
a local control scope. If a path has multiple segments, it always refers to an
item.</p>
<p>Two examples of simple paths consisting of only identifier segments:</p>
<!-- ignore: syntax fragment -->
<pre><code class="language-rust ignore">x;
x::y::z;
</code></pre>
<h2><a class="header" href="#types-of-paths" id="types-of-paths">Types of paths</a></h2>
<h3><a class="header" href="#simple-paths" id="simple-paths">Simple Paths</a></h3>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>SimplePath</em> :<br />
   <code>::</code><sup>?</sup> <em>SimplePathSegment</em> (<code>::</code> <em>SimplePathSegment</em>)<sup>*</sup></p>
<p><em>SimplePathSegment</em> :<br />
   <a href="identifiers.html">IDENTIFIER</a> | <code>super</code> | <code>self</code> | <code>crate</code> | <code>$crate</code></p>
</blockquote>
<p>Simple paths are used in <a href="visibility-and-privacy.html">visibility</a> markers, <a href="attributes.html">attributes</a>, <a href="macros-by-example.html">macros</a>, and <a href="items/use-declarations.html"><code>use</code></a> items.
Examples:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};
mod m {
    #[clippy::cyclomatic_complexity = &quot;0&quot;]
    pub (in super) fn f1() {}
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#paths-in-expressions" id="paths-in-expressions">Paths in expressions</a></h3>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>PathInExpression</em> :<br />
   <code>::</code><sup>?</sup> <em>PathExprSegment</em> (<code>::</code> <em>PathExprSegment</em>)<sup>*</sup></p>
<p><em>PathExprSegment</em> :<br />
   <em>PathIdentSegment</em> (<code>::</code> <em>GenericArgs</em>)<sup>?</sup></p>
<p><em>PathIdentSegment</em> :<br />
   <a href="identifiers.html">IDENTIFIER</a> | <code>super</code> | <code>self</code> | <code>Self</code> | <code>crate</code> | <code>$crate</code></p>
<p><em>GenericArgs</em> :<br />
      <code>&lt;</code> <code>&gt;</code><br />
   | <code>&lt;</code> <em>GenericArgsLifetimes</em> <code>,</code><sup>?</sup> <code>&gt;</code><br />
   | <code>&lt;</code> <em>GenericArgsTypes</em> <code>,</code><sup>?</sup> <code>&gt;</code><br />
   | <code>&lt;</code> <em>GenericArgsBindings</em> <code>,</code><sup>?</sup> <code>&gt;</code><br />
   | <code>&lt;</code> <em>GenericArgsTypes</em> <code>,</code> <em>GenericArgsBindings</em> <code>,</code><sup>?</sup> <code>&gt;</code><br />
   | <code>&lt;</code> <em>GenericArgsLifetimes</em> <code>,</code> <em>GenericArgsTypes</em> <code>,</code><sup>?</sup> <code>&gt;</code><br />
   | <code>&lt;</code> <em>GenericArgsLifetimes</em> <code>,</code> <em>GenericArgsBindings</em> <code>,</code><sup>?</sup> <code>&gt;</code><br />
   | <code>&lt;</code> <em>GenericArgsLifetimes</em> <code>,</code> <em>GenericArgsTypes</em> <code>,</code> <em>GenericArgsBindings</em> <code>,</code><sup>?</sup> <code>&gt;</code></p>
<p><em>GenericArgsLifetimes</em> :<br />
   <a href="trait-bounds.html"><em>Lifetime</em></a> (<code>,</code> <a href="trait-bounds.html"><em>Lifetime</em></a>)<sup>*</sup></p>
<p><em>GenericArgsTypes</em> :<br />
   <a href="types.html#type-expressions"><em>Type</em></a> (<code>,</code> <a href="types.html#type-expressions"><em>Type</em></a>)<sup>*</sup></p>
<p><em>GenericArgsBindings</em> :<br />
   <em>GenericArgsBinding</em> (<code>,</code> <em>GenericArgsBinding</em>)<sup>*</sup></p>
<p><em>GenericArgsBinding</em> :<br />
   <a href="identifiers.html">IDENTIFIER</a> <code>=</code> <a href="types.html#type-expressions"><em>Type</em></a></p>
</blockquote>
<p>Paths in expressions allow for paths with generic arguments to be specified. They are
used in various places in <a href="expressions.html">expressions</a> and <a href="patterns.html">patterns</a>.</p>
<p>The <code>::</code> token is required before the opening <code>&lt;</code> for generic arguments to avoid
ambiguity with the less-than operator. This is colloquially known as “turbofish” syntax.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>(0..10).collect::&lt;Vec&lt;_&gt;&gt;();
Vec::&lt;u8&gt;::with_capacity(1024);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#qualified-paths" id="qualified-paths">Qualified paths</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>QualifiedPathInExpression</em> :<br />
   <em>QualifiedPathType</em> (<code>::</code> <em>PathExprSegment</em>)<sup>+</sup></p>
<p><em>QualifiedPathType</em> :<br />
   <code>&lt;</code> <a href="types.html#type-expressions"><em>Type</em></a> (<code>as</code> <em>TypePath</em>)? <code>&gt;</code></p>
<p><em>QualifiedPathInType</em> :<br />
   <em>QualifiedPathType</em> (<code>::</code> <em>TypePathSegment</em>)<sup>+</sup></p>
</blockquote>
<p>Fully qualified paths allow for disambiguating the path for <a href="items/implementations.html#trait-implementations">trait implementations</a> and
for specifying <a href="paths.html#canonical-paths">canonical paths</a>. When used in a type specification, it
supports using the type syntax specified below.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct S;
impl S {
    fn f() { println!(&quot;S&quot;); }
}
trait T1 {
    fn f() { println!(&quot;T1 f&quot;); }
}
impl T1 for S {}
trait T2 {
    fn f() { println!(&quot;T2 f&quot;); }
}
impl T2 for S {}
S::f();  // Calls the inherent impl.
&lt;S as T1&gt;::f();  // Calls the T1 trait function.
&lt;S as T2&gt;::f();  // Calls the T2 trait function.
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#paths-in-types" id="paths-in-types">Paths in types</a></h3>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>TypePath</em> :<br />
   <code>::</code><sup>?</sup> <em>TypePathSegment</em> (<code>::</code> <em>TypePathSegment</em>)<sup>*</sup></p>
<p><em>TypePathSegment</em> :<br />
   <em>PathIdentSegment</em> <code>::</code><sup>?</sup> (<a href="paths.html#paths-in-expressions"><em>GenericArgs</em></a> | <em>TypePathFn</em>)<sup>?</sup></p>
<p><em>TypePathFn</em> :<br />
<code>(</code> <em>TypePathFnInputs</em><sup>?</sup> <code>)</code> (<code>-&gt;</code> <a href="types.html#type-expressions"><em>Type</em></a>)<sup>?</sup></p>
<p><em>TypePathFnInputs</em> :<br />
<a href="types.html#type-expressions"><em>Type</em></a> (<code>,</code> <a href="types.html#type-expressions"><em>Type</em></a>)<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<p>Type paths are used within type definitions, trait bounds, type parameter bounds,
and qualified paths.</p>
<p>Although the <code>::</code> token is allowed before the generics arguments, it is not required
because there is no ambiguity like there is in <em>PathInExpression</em>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">mod ops {
</span><span class="boring">    pub struct Range&lt;T&gt; {f1: T}
</span><span class="boring">    pub trait Index&lt;T&gt; {}
</span><span class="boring">    pub struct Example&lt;'a&gt; {f1: &amp;'a i32}
</span><span class="boring">}
</span><span class="boring">struct S;
</span>impl ops::Index&lt;ops::Range&lt;usize&gt;&gt; for S { /*...*/ }
fn i&lt;'a&gt;() -&gt; impl Iterator&lt;Item = ops::Example&lt;'a&gt;&gt; {
    // ...
<span class="boring">   const EXAMPLE: Vec&lt;ops::Example&lt;'static&gt;&gt; = Vec::new();
</span><span class="boring">   EXAMPLE.into_iter()
</span>}
type G = std::boxed::Box&lt;dyn std::ops::FnOnce(isize) -&gt; isize&gt;;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#path-qualifiers" id="path-qualifiers">Path qualifiers</a></h2>
<p>Paths can be denoted with various leading qualifiers to change the meaning of
how it is resolved.</p>
<h3><a class="header" href="#" id=""><code>::</code></a></h3>
<p>Paths starting with <code>::</code> are considered to be global paths where the segments of the path
start being resolved from the crate root. Each identifier in the path must resolve to an
item.</p>
<blockquote>
<p><strong>Edition Differences</strong>: In the 2015 Edition, the crate root contains a variety of
different items, including external crates, default crates such as <code>std</code> and <code>core</code>, and
items in the top level of the crate (including <code>use</code> imports).</p>
<p>Beginning with the 2018 Edition, paths starting with <code>::</code> can only reference crates.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">mod a {
    pub fn foo() {}
}
mod b {
    pub fn foo() {
        ::a::foo(); // call `a`'s foo function
        // In Rust 2018, `::a` would be interpreted as the crate `a`.
    }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h3><a class="header" href="#self" id="self"><code>self</code></a></h3>
<p><code>self</code> resolves the path relative to the current module. <code>self</code> can only be used as the
first segment, without a preceding <code>::</code>.</p>
<pre><pre class="playpen"><code class="language-rust">fn foo() {}
fn bar() {
    self::foo();
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h3><a class="header" href="#self-1" id="self-1"><code>Self</code></a></h3>
<p><code>Self</code>, with a capital “S”, is used to refer to the implementing type within
<a href="items/traits.html">traits</a> and <a href="items/implementations.html">implementations</a>.</p>
<p><code>Self</code> can only be used as the first segment, without a preceding <code>::</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait T {
    type Item;
    const C: i32;
    // `Self` will be whatever type that implements `T`.
    fn new() -&gt; Self;
    // `Self::Item` will be the type alias in the implementation.
    fn f(&amp;self) -&gt; Self::Item;
}
struct S;
impl T for S {
    type Item = i32;
    const C: i32 = 9;
    fn new() -&gt; Self {           // `Self` is the type `S`.
        S
    }
    fn f(&amp;self) -&gt; Self::Item {  // `Self::Item` is the type `i32`.
        Self::C                  // `Self::C` is the constant value `9`.
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#super" id="super"><code>super</code></a></h3>
<p><code>super</code> in a path resolves to the parent module. It may only be used in leading
segments of the path, possibly after an initial <code>self</code> segment.</p>
<pre><pre class="playpen"><code class="language-rust">mod a {
    pub fn foo() {}
}
mod b {
    pub fn foo() {
        super::a::foo(); // call a's foo function
    }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p><code>super</code> may be repeated several times after the first <code>super</code> or <code>self</code> to refer to
ancestor modules.</p>
<pre><pre class="playpen"><code class="language-rust">mod a {
    fn foo() {}

    mod b {
        mod c {
            fn foo() {
                super::super::foo(); // call a's foo function
                self::super::super::foo(); // call a's foo function
            }
        }
    }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h3><a class="header" href="#crate" id="crate"><code>crate</code></a></h3>
<p><code>crate</code> resolves the path relative to the current crate. <code>crate</code> can only be used as the
first segment, without a preceding <code>::</code>.</p>
<pre><pre class="playpen"><code class="language-rust">fn foo() {}
mod a {
    fn bar() {
        crate::foo();
    }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<h3><a class="header" href="#crate-1" id="crate-1"><code>$crate</code></a></h3>
<p><code>$crate</code> is only used within <a href="macros-by-example.html">macro transcribers</a>, and can only be used as the first
segment, without a preceding <code>::</code>. <code>$crate</code> will expand to a path to access items from the
top level of the crate where the macro is defined, regardless of which crate the macro is
invoked.</p>
<pre><pre class="playpen"><code class="language-rust">pub fn increment(x: u32) -&gt; u32 {
    x + 1
}

#[macro_export]
macro_rules! inc {
    ($x:expr) =&gt; ( $crate::increment($x) )
}
<span class="boring">fn main() { }
</span></code></pre></pre>
<h2><a class="header" href="#canonical-paths" id="canonical-paths">Canonical paths</a></h2>
<p>Items defined in a module or implementation have a <em>canonical path</em> that
corresponds to where within its crate it is defined. All other paths to these
items are aliases. The canonical path is defined as a <em>path prefix</em> appended by
the path segment the item itself defines.</p>
<p><a href="items/implementations.html">Implementations</a> and <a href="items/use-declarations.html">use declarations</a> do not have canonical paths, although
the items that implementations define do have them. Items defined in
block expressions do not have canonical paths. Items defined in a module that
does not have a canonical path do not have a canonical path. Associated items
defined in an implementation that refers to an item without a canonical path,
e.g. as the implementing type, the trait being implemented, a type parameter or
bound on a type parameter, do not have canonical paths.</p>
<p>The path prefix for modules is the canonical path to that module. For bare
implementations, it is the canonical path of the item being implemented
surrounded by <span class="parenthetical">angle (<code>&lt;&gt;</code>)</span> brackets. For
<a href="items/implementations.html#trait-implementations">trait implementations</a>, it is the canonical path of the item being implemented
followed by <code>as</code> followed by the canonical path to the trait all surrounded in
<span class="parenthetical">angle (<code>&lt;&gt;</code>)</span> brackets.</p>
<p>The canonical path is only meaningful within a given crate. There is no global
namespace across crates; an item’s canonical path merely identifies it within
the crate.</p>
<pre><pre class="playpen"><code class="language-rust">// Comments show the canonical path of the item.

mod a { // ::a
    pub struct Struct; // ::a::Struct

    pub trait Trait { // ::a::Trait
        fn f(&amp;self); // a::Trait::f
    }

    impl Trait for Struct {
        fn f(&amp;self) {} // &lt;::a::Struct as ::a::Trait&gt;::f
    }

    impl Struct {
        fn g(&amp;self) {} // &lt;::a::Struct&gt;::g
    }
}

mod without { // ::without
    fn canonicals() { // ::without::canonicals
        struct OtherStruct; // None

        trait OtherTrait { // None
            fn g(&amp;self); // None
        }

        impl OtherTrait for OtherStruct {
            fn g(&amp;self) {} // None
        }

        impl OtherTrait for ::a::Struct {
            fn g(&amp;self) {} // None
        }

        impl ::a::Trait for OtherStruct {
            fn f(&amp;self) {} // None
        }
    }
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<h1><a class="header" href="#macros" id="macros">Macros</a></h1>
<p>The functionality and syntax of Rust can be extended with custom definitions
called macros. They are given names, and invoked through a consistent
syntax:<code>some_extension!(...)</code>.</p>
<p>There are two ways to define new macros:</p>
<ul>
<li><a href="macros-by-example.html">Macros by Example</a> define new syntax in a higher-level, declarative way.</li>
<li><a href="procedural-macros.html">Procedural Macros</a> can be used to implement custom derive.</li>
</ul>
<h2><a class="header" href="#macro-invocation" id="macro-invocation">Macro Invocation</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>MacroInvocation</em> :<br />
   <a href="paths.html#simple-paths"><em>SimplePath</em></a> <code>!</code> <em>DelimTokenTree</em></p>
<p><em>DelimTokenTree</em> :<br />
       <code>(</code> <em>TokenTree</em><sup>*</sup> <code>)</code><br />
   | <code>[</code> <em>TokenTree</em><sup>*</sup> <code>]</code><br />
   | <code>{</code> <em>TokenTree</em><sup>*</sup> <code>}</code></p>
<p><em>TokenTree</em> :<br />
   <a href="tokens.html"><em>Token</em></a><sub><em>except <a href="tokens.html#delimiters">delimiters</a></em></sub> | <em>DelimTokenTree</em></p>
<p><em>MacroInvocationSemi</em> :<br />
      <a href="paths.html#simple-paths"><em>SimplePath</em></a> <code>!</code> <code>(</code> <em>TokenTree</em><sup>*</sup> <code>)</code> <code>;</code><br />
   | <a href="paths.html#simple-paths"><em>SimplePath</em></a> <code>!</code> <code>[</code> <em>TokenTree</em><sup>*</sup> <code>]</code> <code>;</code><br />
   | <a href="paths.html#simple-paths"><em>SimplePath</em></a> <code>!</code> <code>{</code> <em>TokenTree</em><sup>*</sup> <code>}</code></p>
</blockquote>
<p>A macro invocation executes a macro at compile time and replaces the
invocation with the result of the macro. Macros may be invoked in the
following situations:</p>
<ul>
<li><a href="expressions.html">Expressions</a> and <a href="statements.html">statements</a></li>
<li><a href="patterns.html">Patterns</a></li>
<li><a href="types.html">Types</a></li>
<li><a href="items.html">Items</a> including <a href="items/associated-items.html">associated items</a></li>
<li><a href="macros-by-example.html"><code>macro_rules</code></a> transcribers</li>
<li><a href="items/external-blocks.html">External blocks</a></li>
</ul>
<p>When used as an item or a statement, the <em>MacroInvocationSemi</em> form is used
where a semicolon is required at the end when not using curly braces.
<a href="visibility-and-privacy.html">Visibility qualifiers</a> are never allowed before a macro invocation or
<a href="macros-by-example.html"><code>macro_rules</code></a> definition.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Used as an expression.
let x = vec![1,2,3];

// Used as a statement.
println!(&quot;Hello!&quot;);

// Used in a pattern.
macro_rules! pat {
    ($i:ident) =&gt; (Some($i))
}

if let pat!(x) = Some(1) {
    assert_eq!(x, 1);
}

// Used in a type.
macro_rules! Tuple {
    { $A:ty, $B:ty } =&gt; { ($A, $B) };
}

type N2 = Tuple!(i32, i32);

// Used as an item.
<span class="boring">use std::cell::RefCell;
</span>thread_local!(static FOO: RefCell&lt;u32&gt; = RefCell::new(1));

// Used as an associated item.
macro_rules! const_maker {
    ($t:ty, $v:tt) =&gt; { const CONST: $t = $v; };
}
trait T {
    const_maker!{i32, 7}
}

// Macro calls within macros.
macro_rules! example {
    () =&gt; { println!(&quot;Macro call in a macro!&quot;) };
}
// Outer macro `example` is expanded, then inner macro `println` is expanded.
example!();
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#macros-by-example" id="macros-by-example">Macros By Example</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>MacroRulesDefinition</em> :<br />
   <code>macro_rules</code> <code>!</code> <a href="identifiers.html">IDENTIFIER</a> <em>MacroRulesDef</em></p>
<p><em>MacroRulesDef</em> :<br />
      <code>(</code> <em>MacroRules</em> <code>)</code> <code>;</code><br />
   | <code>[</code> <em>MacroRules</em> <code>]</code> <code>;</code><br />
   | <code>{</code> <em>MacroRules</em> <code>}</code></p>
<p><em>MacroRules</em> :<br />
   <em>MacroRule</em> ( <code>;</code> <em>MacroRule</em> )<sup>*</sup> <code>;</code><sup>?</sup></p>
<p><em>MacroRule</em> :<br />
   <em>MacroMatcher</em> <code>=&gt;</code> <em>MacroTranscriber</em></p>
<p><em>MacroMatcher</em> :<br />
      <code>(</code> <em>MacroMatch</em><sup>*</sup> <code>)</code><br />
   | <code>[</code> <em>MacroMatch</em><sup>*</sup> <code>]</code><br />
   | <code>{</code> <em>MacroMatch</em><sup>*</sup> <code>}</code></p>
<p><em>MacroMatch</em> :<br />
      <a href="tokens.html"><em>Token</em></a><sub><em>except $ and delimiters</em></sub><br />
   | <em>MacroMatcher</em><br />
   | <code>$</code> <a href="identifiers.html">IDENTIFIER</a> <code>:</code> <em>MacroFragSpec</em><br />
   | <code>$</code> <code>(</code> <em>MacroMatch</em><sup>+</sup> <code>)</code> <em>MacroRepSep</em><sup>?</sup> <em>MacroRepOp</em></p>
<p><em>MacroFragSpec</em> :<br />
      <code>block</code> | <code>expr</code> | <code>ident</code> | <code>item</code> | <code>lifetime</code> | <code>literal</code><br />
   | <code>meta</code> | <code>pat</code> | <code>path</code> | <code>stmt</code> | <code>tt</code> | <code>ty</code> | <code>vis</code></p>
<p><em>MacroRepSep</em> :<br />
   <a href="tokens.html"><em>Token</em></a><sub><em>except delimiters and repetition operators</em></sub></p>
<p><em>MacroRepOp</em> :<br />
   <code>*</code> | <code>+</code> | <code>?</code></p>
<p><em>MacroTranscriber</em> :<br />
   <a href="macros.html"><em>DelimTokenTree</em></a></p>
</blockquote>
<p><code>macro_rules</code> allows users to define syntax extension in a declarative way.  We
call such extensions “macros by example” or simply “macros”.</p>
<p>Each macro by example has a name, and one or more <em>rules</em>. Each rule has two
parts: a <em>matcher</em>, describing the syntax that it matches, and a <em>transcriber</em>,
describing the syntax that will replace a successfully matched invocation. Both
the matcher and the transcriber must be surrounded by delimiters. Macros can
expand to expressions, statements, items (including traits, impls, and foreign
items), types, or patterns.</p>
<h2><a class="header" href="#transcribing" id="transcribing">Transcribing</a></h2>
<p>When a macro is invoked, the macro expander looks up macro invocations by name,
and tries each macro rule in turn. It transcribes the first successful match; if
this results in an error, then future matches are not tried. When matching, no
lookahead is performed; if the compiler cannot unambiguously determine how to
parse the macro invocation one token at a time, then it is an error. In the
following example, the compiler does not look ahead past the identifier to see
if the following token is a <code>)</code>, even though that would allow it to parse the
invocation unambiguously:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>macro_rules! ambiguity {
    ($($i:ident)* $j:ident) =&gt; { };
}

ambiguity!(error); // Error: local ambiguity
<span class="boring">}
</span></code></pre></pre>
<p>In both the matcher and the transcriber, the <code>$</code> token is used to invoke special
behaviours from the macro engine (described below in <a href="macros-by-example.html#metavariables">Metavariables</a> and
<a href="macros-by-example.html#repetitions">Repetitions</a>). Tokens that aren’t part of such an invocation are matched and
transcribed literally, with one exception. The exception is that the outer
delimiters for the matcher will match any pair of delimiters. Thus, for
instance, the matcher <code>(())</code> will match <code>{()}</code> but not <code>{{}}</code>. The character
<code>$</code> cannot be matched or transcribed literally.</p>
<p>When forwarding a matched fragment to another macro-by-example, matchers in
the second macro will see an opaque AST of the fragment type. The second macro
can’t use literal tokens to match the fragments in the matcher, only a
fragment specifier of the same type. The <code>ident</code>, <code>lifetime</code>, and <code>tt</code>
fragment types are an exception, and <em>can</em> be matched by literal tokens. The
following illustrates this restriction:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
    ($l:expr) =&gt; { bar!($l); }
// ERROR:               ^^ no rules expected this token in macro call
}

macro_rules! bar {
    (3) =&gt; {}
}

foo!(3);
<span class="boring">}
</span></code></pre></pre>
<p>The following illustrates how tokens can be directly matched after matching a
<code>tt</code> fragment:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// compiles OK
macro_rules! foo {
    ($l:tt) =&gt; { bar!($l); }
}

macro_rules! bar {
    (3) =&gt; {}
}

foo!(3);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#metavariables" id="metavariables">Metavariables</a></h2>
<p>In the matcher, <code>$</code> <em>name</em> <code>:</code> <em>fragment-specifier</em> matches a Rust syntax
fragment of the kind specified and binds it to the metavariable <code>$</code><em>name</em>. Valid
fragment specifiers are:</p>
<ul>
<li><code>item</code>: an <a href="items.html"><em>Item</em></a></li>
<li><code>block</code>: a <a href="expressions/block-expr.html"><em>BlockExpression</em></a></li>
<li><code>stmt</code>: a <a href="statements.html"><em>Statement</em></a> without the trailing semicolon (except for item
statements that require semicolons)</li>
<li><code>pat</code>: a <a href="patterns.html"><em>Pattern</em></a></li>
<li><code>expr</code>: an <a href="expressions.html"><em>Expression</em></a></li>
<li><code>ty</code>: a <a href="types.html#type-expressions"><em>Type</em></a></li>
<li><code>ident</code>: an <a href="identifiers.html">IDENTIFIER_OR_KEYWORD</a></li>
<li><code>path</code>: a <a href="paths.html#paths-in-types"><em>TypePath</em></a> style path</li>
<li><code>tt</code>: a <a href="macros.html#macro-invocation"><em>TokenTree</em></a> (a single <a href="tokens.html">token</a> or tokens in matching delimiters <code>()</code>, <code>[]</code>, or <code>{}</code>)</li>
<li><code>meta</code>: an <a href="attributes.html"><em>Attr</em></a>, the contents of an attribute</li>
<li><code>lifetime</code>: a <a href="tokens.html#lifetimes-and-loop-labels">LIFETIME_TOKEN</a></li>
<li><code>vis</code>: a possibly empty <a href="visibility-and-privacy.html"><em>Visibility</em></a> qualifier</li>
<li><code>literal</code>: matches <code>-</code><sup>?</sup><a href="expressions/literal-expr.html"><em>LiteralExpression</em></a></li>
</ul>
<p>In the transcriber, metavariables are referred to simply by <code>$</code><em>name</em>, since
the fragment kind is specified in the matcher. Metavariables are replaced with
the syntax element that matched them. The keyword metavariable <code>$crate</code> can be
used to refer to the current crate; see <a href="macros-by-example.html#hygiene">Hygiene</a> below. Metavariables can be
transcribed more than once or not at all.</p>
<h2><a class="header" href="#repetitions" id="repetitions">Repetitions</a></h2>
<p>In both the matcher and transcriber, repetitions are indicated by placing the
tokens to be repeated inside <code>$(</code>…<code>)</code>, followed by a repetition operator,
optionally with a separator token between. The separator token can be any token
other than a delimiter or one of the repetition operators, but <code>;</code> and <code>,</code> are
the most common. For instance, <code>$( $i:ident ),*</code> represents any number of
identifiers separated by commas. Nested repetitions are permitted.</p>
<p>The repetition operators are:</p>
<ul>
<li><code>*</code> — indicates any number of repetitions.</li>
<li><code>+</code> — indicates any number but at least one.</li>
<li><code>?</code> — indicates an optional fragment with zero or one occurrences.</li>
</ul>
<p>Since <code>?</code> represents at most one occurrence, it cannot be used with a
separator.</p>
<p>The repeated fragment both matches and transcribes to the specified number of
the fragment, separated by the separator token. Metavariables are matched to
every repetition of their corresponding fragment. For instance, the <code>$( $i:ident ),*</code> example above matches <code>$i</code> to all of the identifiers in the list.</p>
<p>During transcription, additional restrictions apply to repetitions so that the
compiler knows how to expand them properly:</p>
<ol>
<li>A metavariable must appear in exactly the same number, kind, and nesting
order of repetitions in the transcriber as it did in the matcher. So for the
matcher <code>$( $i:ident ),*</code>, the transcribers <code>=&gt; { $i }</code>,
<code>=&gt; { $( $( $i)* )* }</code>, and <code>=&gt; { $( $i )+ }</code> are all illegal, but
<code>=&gt; { $( $i );* }</code> is correct and replaces a comma-separated list of
identifiers with a semicolon-separated list.</li>
<li>Second, each repetition in the transcriber must contain at least one
metavariable to decide how many times to expand it. If multiple
metavariables appear in the same repetition, they must be bound to the same
number of fragments. For instance, <code>( $( $i:ident ),* ; $( $j:ident ),* ) =&gt; ( $( ($i,$j) ),*</code> must bind the same number of <code>$i</code> fragments as <code>$j</code>
fragments. This means that invoking the macro with <code>(a, b, c; d, e, f</code>) is
legal and expands to <code>((a,d), (b,e), (c,f))</code>, but <code>(a, b, c; d, e)</code> is
illegal because it does not have the same number. This requirement applies
to every layer of nested repetitions.</li>
</ol>
<h2><a class="header" href="#scoping-exporting-and-importing" id="scoping-exporting-and-importing">Scoping, Exporting, and Importing</a></h2>
<p>For historical reasons, the scoping of macros by example does not work entirely like
items. Macros have two forms of scope: textual scope, and path-based scope.
Textual scope is based on the order that things appear in source files, or even
across multiple files, and is the default scoping. It is explained further below.
Path-based scope works exactly the same way that item scoping does. The scoping,
exporting, and importing of macros is controlled largely by attributes.</p>
<p>When a macro is invoked by an unqualified identifier (not part of a multi-part
path), it is first looked up in textual scoping. If this does not yield any
results, then it is looked up in path-based scoping. If the macro’s name is
qualified with a path, then it is only looked up in path-based scoping.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">use lazy_static::lazy_static; // Path-based import.

macro_rules! lazy_static { // Textual definition.
    (lazy) =&gt; {};
}

lazy_static!{lazy} // Textual lookup finds our macro first.
self::lazy_static!{} // Path-based lookup ignores our macro, finds imported one.
</code></pre>
<h3><a class="header" href="#textual-scope" id="textual-scope">Textual Scope</a></h3>
<p>Textual scope is based largely on the order that things appear in source files,
and works similarly to the scope of local variables declared with <code>let</code> except
it also applies at the module level. When <code>macro_rules!</code> is used to define a
macro, the macro enters the scope after the definition (note that it can still
be used recursively, since names are looked up from the invocation site), up
until its surrounding scope, typically a module, is closed. This can enter child
modules and even span across multiple files:</p>
<!-- ignore: requires external modules -->
<pre><code class="language-rust ignore">//// src/lib.rs
mod has_macro {
    // m!{} // Error: m is not in scope.

    macro_rules! m {
        () =&gt; {};
    }
    m!{} // OK: appears after declaration of m.

    mod uses_macro;
}

// m!{} // Error: m is not in scope.

//// src/has_macro/uses_macro.rs

m!{} // OK: appears after declaration of m in src/lib.rs
</code></pre>
<p>It is not an error to define a macro multiple times; the most recent declaration
will shadow the previous one unless it has gone out of scope.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    (1) =&gt; {};
}

m!(1);

mod inner {
    m!(1);

    macro_rules! m {
        (2) =&gt; {};
    }
    // m!(1); // Error: no rule matches '1'
    m!(2);

    macro_rules! m {
        (3) =&gt; {};
    }
    m!(3);
}

m!(1);
<span class="boring">}
</span></code></pre></pre>
<p>Macros can be declared and used locally inside functions as well, and work
similarly:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn foo() {
    // m!(); // Error: m is not in scope.
    macro_rules! m {
        () =&gt; {};
    }
    m!();
}


// m!(); // Error: m is not in scope.
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#the-macro_use-attribute" id="the-macro_use-attribute">The <code>macro_use</code> attribute</a></h3>
<p>The <em><code>macro_use</code> attribute</em> has two purposes. First, it can be used to make a
module’s macro scope not end when the module is closed, by applying it to a
module:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[macro_use]
mod inner {
    macro_rules! m {
        () =&gt; {};
    }
}

m!();
<span class="boring">}
</span></code></pre></pre>
<p>Second, it can be used to import macros from another crate, by attaching it to
an <code>extern crate</code> declaration appearing in the crate’s root module. Macros
imported this way are imported into the prelude of the crate, not textually,
which means that they can be shadowed by any other name. While macros imported
by <code>#[macro_use]</code> can be used before the import statement, in case of a
conflict, the last macro imported wins. Optionally, a list of macros to import
can be specified using the <a href="attributes.html#meta-item-attribute-syntax"><em>MetaListIdents</em></a> syntax; this is not supported
when <code>#[macro_use]</code> is applied to a module.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">#[macro_use(lazy_static)] // Or #[macro_use] to import all macros.
extern crate lazy_static;

lazy_static!{}
// self::lazy_static!{} // Error: lazy_static is not defined in `self`
</code></pre>
<p>Macros to be imported with <code>#[macro_use]</code> must be exported with
<code>#[macro_export]</code>, which is described below.</p>
<h3><a class="header" href="#path-based-scope" id="path-based-scope">Path-Based Scope</a></h3>
<p>By default, a macro has no path-based scope. However, if it has the
<code>#[macro_export]</code> attribute, then it is declared in the crate root scope and can
be referred to normally as such:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>self::m!();
m!(); // OK: Path-based lookup finds m in the current module.

mod inner {
    super::m!();
    crate::m!();
}

mod mac {
    #[macro_export]
    macro_rules! m {
        () =&gt; {};
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Macros labeled with <code>#[macro_export]</code> are always <code>pub</code> and can be referred to
by other crates, either by path or by <code>#[macro_use]</code> as described above.</p>
<h2><a class="header" href="#hygiene" id="hygiene">Hygiene</a></h2>
<p>By default, all identifiers referred to in a macro are expanded as-is, and are
looked up at the macro’s invocation site. This can lead to issues if a macro
refers to an item or macro which isn’t in scope at the invocation site. To
alleviate this, the <code>$crate</code> metavariable can be used at the start of a path to
force lookup to occur inside the crate defining the macro.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">//// Definitions in the `helper_macro` crate.
#[macro_export]
macro_rules! helped {
    // () =&gt; { helper!() } // This might lead to an error due to 'helper' not being in scope.
    () =&gt; { $crate::helper!() }
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}

//// Usage in another crate.
// Note that `helper_macro::helper` is not imported!
use helper_macro::helped;

fn unit() {
    helped!();
}
</code></pre>
<p>Note that, because <code>$crate</code> refers to the current crate, it must be used with a
fully qualified module path when referring to non-macro items:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub mod inner {
    #[macro_export]
    macro_rules! call_foo {
        () =&gt; { $crate::inner::foo() };
    }

    pub fn foo() {}
}
<span class="boring">}
</span></code></pre></pre>
<p>Additionally, even though <code>$crate</code> allows a macro to refer to items within its
own crate when expanding, its use has no effect on visibility. An item or macro
referred to must still be visible from the invocation site. In the following
example, any attempt to invoke <code>call_foo!()</code> from outside its crate will fail
because <code>foo()</code> is not public.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! call_foo {
    () =&gt; { $crate::foo() };
}

fn foo() {}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Version &amp; Edition Differences</strong>: Prior to Rust 1.30, <code>$crate</code> and
<code>local_inner_macros</code> (below) were unsupported. They were added alongside
path-based imports of macros (described above), to ensure that helper macros
did not need to be manually imported by users of a macro-exporting crate.
Crates written for earlier versions of Rust that use helper macros need to be
modified to use <code>$crate</code> or <code>local_inner_macros</code> to work well with path-based
imports.</p>
</blockquote>
<p>When a macro is exported, the <code>#[macro_export]</code> attribute can have the
<code>local_inner_macros</code> keyword added to automatically prefix all contained macro
invocations with <code>$crate::</code>. This is intended primarily as a tool to migrate
code written before <code>$crate</code> was added to the language to work with Rust 2018’s
path-based imports of macros. Its use is discouraged in new code.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[macro_export(local_inner_macros)]
macro_rules! helped {
    () =&gt; { helper!() } // Automatically converted to $crate::helper!().
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#follow-set-ambiguity-restrictions" id="follow-set-ambiguity-restrictions">Follow-set Ambiguity Restrictions</a></h2>
<p>The parser used by the macro system is reasonably powerful, but it is limited in
order to prevent ambiguity in current or future versions of the language. In
particular, in addition to the rule about ambiguous expansions, a nonterminal
matched by a metavariable must be followed by a token which has been decided can
be safely used after that kind of match.</p>
<p>As an example, a macro matcher like <code>$i:expr [ , ]</code> could in theory be accepted
in Rust today, since <code>[,]</code> cannot be part of a legal expression and therefore
the parse would always be unambiguous. However, because <code>[</code> can start trailing
expressions, <code>[</code> is not a character which can safely be ruled out as coming
after an expression. If <code>[,]</code> were accepted in a later version of Rust, this
matcher would become ambiguous or would misparse, breaking working code.
Matchers like <code>$i:expr,</code> or <code>$i:expr;</code> would be legal, however, because <code>,</code> and
<code>;</code> are legal expression separators. The specific rules are:</p>
<ul>
<li><code>expr</code> and <code>stmt</code> may only be followed by one of: <code>=&gt;</code>, <code>,</code>, or <code>;</code>.</li>
<li><code>pat</code> may only be followed by one of: <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>if</code>, or <code>in</code>.</li>
<li><code>path</code> and <code>ty</code> may only be followed by one of: <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>;</code>,
<code>:</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>[</code>, <code>{</code>, <code>as</code>, <code>where</code>, or a macro variable of <code>block</code>
fragment specifier.</li>
<li><code>vis</code> may only be followed by one of: <code>,</code>, an identifier other than a
non-raw <code>priv</code>, any token that can begin a type, or a metavariable with a
<code>ident</code>, <code>ty</code>, or <code>path</code> fragment specifier.</li>
<li>All other fragment specifiers have no restrictions.</li>
</ul>
<p>When repetitions are involved, then the rules apply to every possible number of
expansions, taking separators into account. This means:</p>
<ul>
<li>If the repetition includes a separator, that separator must be able to
follow the contents of the repetition.</li>
<li>If the repetition can repeat multiple times (<code>*</code> or <code>+</code>), then the contents
must be able to follow themselves.</li>
<li>The contents of the repetition must be able to follow whatever comes
before, and whatever comes after must be able to follow the contents of the
repetition.</li>
<li>If the repetition can match zero times (<code>*</code> or <code>?</code>), then whatever comes
after must be able to follow whatever comes before.</li>
</ul>
<p>For more detail, see the <a href="macro-ambiguity.html">formal specification</a>.</p>
<h2><a class="header" href="#procedural-macros" id="procedural-macros">Procedural Macros</a></h2>
<p><em>Procedural macros</em> allow creating syntax extensions as execution of a function.
Procedural macros come in one of three flavors:</p>
<ul>
<li><a href="procedural-macros.html#function-like-procedural-macros">Function-like macros</a> - <code>custom!(...)</code></li>
<li><a href="procedural-macros.html#derive-macros">Derive macros</a> - <code>#[derive(CustomDerive)]</code></li>
<li><a href="procedural-macros.html#attribute-macros">Attribute macros</a> - <code>#[CustomAttribute]</code></li>
</ul>
<p>Procedural macros allow you to run code at compile time that operates over Rust
syntax, both consuming and producing Rust syntax. You can sort of think of
procedural macros as functions from an AST to another AST.</p>
<p>Procedural macros must be defined in a crate with the <a href="linkage.html">crate type</a> of
<code>proc-macro</code>.</p>
<blockquote>
<p><strong>Note</strong>: When using Cargo, Procedural macro crates are defined with the
<code>proc-macro</code> key in your manifest:</p>
<pre><code class="language-toml">[lib]
proc-macro = true
</code></pre>
</blockquote>
<p>As functions, they must either return syntax, panic, or loop endlessly. Returned
syntax either replaces or adds the syntax depending on the kind of procedural
macro. Panics are caught by the compiler and are turned into a compiler error.
Endless loops are not caught by the compiler which hangs the compiler.</p>
<p>Procedural macros run during compilation, and thus have the same resources that
the compiler has. For example, standard input, error, and output are the same
that the compiler has access to. Similarly, file access is the same. Because
of this, procedural macros have the same security concerns that <a href="../cargo/reference/build-scripts.html">Cargo’s
build scripts</a> have.</p>
<p>Procedural macros have two ways of reporting errors. The first is to panic. The
second is to emit a <a href="../std/macro.compile_error.html"><code>compile_error</code></a> macro invocation.</p>
<h3><a class="header" href="#the-proc_macro-crate" id="the-proc_macro-crate">The <code>proc_macro</code> crate</a></h3>
<p>Procedural macro crates almost always will link to the compiler-provided
<a href="../proc_macro/index.html"><code>proc_macro</code> crate</a>. The <code>proc_macro</code> crate provides types required for
writing procedural macros and facilities to make it easier.</p>
<p>This crate primarily contains a <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> type. Procedural macros operate
over <em>token streams</em> instead of AST nodes, which is a far more stable interface
over time for both the compiler and for procedural macros to target. A
<em>token stream</em> is roughly equivalent to <code>Vec&lt;TokenTree&gt;</code> where a <code>TokenTree</code>
can roughly be thought of as lexical token. For example <code>foo</code> is an <code>Ident</code>
token, <code>.</code> is a <code>Punct</code> token, and <code>1.2</code> is a <code>Literal</code> token. The <code>TokenStream</code>
type, unlike <code>Vec&lt;TokenTree&gt;</code>, is cheap to clone.</p>
<p>All tokens have an associated <code>Span</code>. A <code>Span</code> is an opaque value that cannot
be modified but can be manufactured. <code>Span</code>s represent an extent of source
code within a program and are primarily used for error reporting. You can modify
the <code>Span</code> of any token.</p>
<h3><a class="header" href="#procedural-macro-hygiene" id="procedural-macro-hygiene">Procedural macro hygiene</a></h3>
<p>Procedural macros are <em>unhygienic</em>. This means they behave as if the output
token stream was simply written inline to the code it’s next to. This means that
it’s affected by external items and also affects external imports.</p>
<p>Macro authors need to be careful to ensure their macros work in as many contexts
as possible given this limitation. This often includes using absolute paths to
items in libraries (for example, <code>::std::option::Option</code> instead of <code>Option</code>) or
by ensuring that generated functions have names that are unlikely to clash with
other functions (like <code>__internal_foo</code> instead of <code>foo</code>).</p>
<h3><a class="header" href="#function-like-procedural-macros" id="function-like-procedural-macros">Function-like procedural macros</a></h3>
<p><em>Function-like procedural macros</em> are procedural macros that are invoked using
the macro invocation operator (<code>!</code>).</p>
<p>These macros are defined by a <a href="visibility-and-privacy.html">public</a> <a href="items/functions.html">function</a> with the <code>proc_macro</code>
<a href="attributes.html">attribute</a> and a signature of <code>(TokenStream) -&gt; TokenStream</code>. The input
<a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> is what is inside the delimiters of the macro invocation and the
output <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> replaces the entire macro invocation.</p>
<p>For example, the following macro definition ignores its input and outputs a
function <code>answer</code> into its scope.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type = &quot;proc-macro&quot;]
</span>extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro]
pub fn make_answer(_item: TokenStream) -&gt; TokenStream {
    &quot;fn answer() -&gt; u32 { 42 }&quot;.parse().unwrap()
}
</code></pre>
<p>And then we use it a binary crate to print “42” to standard output.</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">extern crate proc_macro_examples;
use proc_macro_examples::make_answer;

make_answer!();

fn main() {
    println!(&quot;{}&quot;, answer());
}
</code></pre>
<p>Function-like procedural macros may expand to a <a href="types.html">type</a> or any number of
<a href="items.html">items</a>, including <a href="macros-by-example.html"><code>macro_rules</code></a> definitions. They may be invoked in a <a href="types.html#type-expressions">type
expression</a>, <a href="items.html">item</a> position (except as a <a href="statements.html">statement</a>), including items in
<a href="items/external-blocks.html"><code>extern</code> blocks</a>, inherent and trait <a href="items/implementations.html">implementations</a>, and <a href="items/traits.html">trait
definitions</a>. They cannot be used in a <a href="statements.html">statement</a>, <a href="expressions.html">expression</a>, or
<a href="patterns.html">pattern</a>.</p>
<h3><a class="header" href="#derive-macros" id="derive-macros">Derive macros</a></h3>
<p><em>Derive macros</em> define new inputs for the <a href="attributes/derive.html"><code>derive</code> attribute</a>. These macros
can create new <a href="items.html">items</a> given the token stream of a <a href="items/structs.html">struct</a>, <a href="items/enumerations.html">enum</a>, or <a href="items/unions.html">union</a>.
They can also define <a href="procedural-macros.html#derive-macro-helper-attributes">derive macro helper attributes</a>.</p>
<p>Custom derive macros are defined by a <a href="visibility-and-privacy.html">public</a> <a href="items/functions.html">function</a> with the
<code>proc_macro_derive</code> attribute and a signature of <code>(TokenStream) -&gt; TokenStream</code>.</p>
<p>The input <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> is the token stream of the item that has the <code>derive</code>
attribute on it. The output <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> must be a set of items that are
then appended to the <a href="items/modules.html">module</a> or <a href="expressions/block-expr.html">block</a> that the item from the input
<a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> is in.</p>
<p>The following is an example of a derive macro. Instead of doing anything
useful with its input, it just appends a function <code>answer</code>.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type = &quot;proc-macro&quot;]
</span>extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro_derive(AnswerFn)]
pub fn derive_answer_fn(_item: TokenStream) -&gt; TokenStream {
    &quot;fn answer() -&gt; u32 { 42 }&quot;.parse().unwrap()
}
</code></pre>
<p>And then using said derive macro:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">extern crate proc_macro_examples;
use proc_macro_examples::AnswerFn;

#[derive(AnswerFn)]
struct Struct;

fn main() {
    assert_eq!(42, answer());
}
</code></pre>
<h4><a class="header" href="#derive-macro-helper-attributes" id="derive-macro-helper-attributes">Derive macro helper attributes</a></h4>
<p>Derive macros can add additional <a href="attributes.html">attributes</a> into the scope of the <a href="items.html">item</a>
they are on. Said attributes are called <em>derive macro helper attributes</em>. These
attributes are <a href="attributes.html#active-and-inert-attributes">inert</a>, and their only purpose is to be fed into the derive
macro that defined them. That said, they can be seen by all macros.</p>
<p>The way to define helper attributes is to put an <code>attributes</code> key in the
<code>proc_macro_derive</code> macro with a comma separated list of identifiers that are
the names of the helper attributes.</p>
<p>For example, the following derive macro defines a helper attribute
<code>helper</code>, but ultimately doesn’t do anything with it.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type=&quot;proc-macro&quot;]
</span><span class="boring">extern crate proc_macro;
</span><span class="boring">use proc_macro::TokenStream;
</span>
#[proc_macro_derive(HelperAttr, attributes(helper))]
pub fn derive_helper_attr(_item: TokenStream) -&gt; TokenStream {
    TokenStream::new()
}
</code></pre>
<p>And then usage on the derive macro on a struct:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">#[derive(HelperAttr)]
struct Struct {
    #[helper] field: ()
}
</code></pre>
<h3><a class="header" href="#attribute-macros" id="attribute-macros">Attribute macros</a></h3>
<p><em>Attribute macros</em> define new <a href="attributes.html">outer attributes</a> which can be
attached to <a href="items.html">items</a>, including items in <a href="items/external-blocks.html"><code>extern</code> blocks</a>, inherent and trait
<a href="items/implementations.html">implementations</a>, and <a href="items/traits.html">trait definitions</a>.</p>
<p>Attribute macros are defined by a <a href="visibility-and-privacy.html">public</a> <a href="items/functions.html">function</a> with the
<code>proc_macro_attribute</code> <a href="attributes.html">attribute</a> that has a signature of <code>(TokenStream, TokenStream) -&gt; TokenStream</code>. The first <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> is the delimited token
tree following the attribute’s name, not including the outer delimiters. If
the attribute is written as a bare attribute name, the attribute
<a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> is empty. The second <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> is the rest of the <a href="items.html">item</a>
including other <a href="attributes.html">attributes</a> on the <a href="items.html">item</a>. The returned <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a>
replaces the <a href="items.html">item</a> with an arbitrary number of <a href="items.html">items</a>.</p>
<p>For example, this attribute macro takes the input stream and returns it as is,
effectively being the no-op of attributes.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore"><span class="boring">#![crate_type = &quot;proc-macro&quot;]
</span><span class="boring">extern crate proc_macro;
</span><span class="boring">use proc_macro::TokenStream;
</span>
#[proc_macro_attribute]
pub fn return_as_is(_attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    item
}
</code></pre>
<p>This following example shows the stringified <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code>s</a> that the attribute
macros see. The output will show in the output of the compiler. The output is
shown in the comments after the function prefixed with “out:”.</p>
<!-- ignore: test doesn't support proc-macro -->
<pre><code class="language-rust ignore">// my-macro/src/lib.rs
<span class="boring">extern crate proc_macro;
</span><span class="boring">use proc_macro::TokenStream;
</span>
#[proc_macro_attribute]
pub fn show_streams(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    println!(&quot;attr: \&quot;{}\&quot;&quot;, attr.to_string());
    println!(&quot;item: \&quot;{}\&quot;&quot;, item.to_string());
    item
}
</code></pre>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">// src/lib.rs
extern crate my_macro;

use my_macro::show_streams;

// Example: Basic function
#[show_streams]
fn invoke1() {}
// out: attr: &quot;&quot;
// out: item: &quot;fn invoke1() { }&quot;

// Example: Attribute with input
#[show_streams(bar)]
fn invoke2() {}
// out: attr: &quot;bar&quot;
// out: item: &quot;fn invoke2() {}&quot;

// Example: Multiple tokens in the input
#[show_streams(multiple =&gt; tokens)]
fn invoke3() {}
// out: attr: &quot;multiple =&gt; tokens&quot;
// out: item: &quot;fn invoke3() {}&quot;

// Example:
#[show_streams { delimiters }]
fn invoke4() {}
// out: attr: &quot;delimiters&quot;
// out: item: &quot;fn invoke4() {}&quot;
</code></pre>
<h1><a class="header" href="#crates-and-source-files" id="crates-and-source-files">Crates and source files</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Crate</em> :<br />
   UTF8BOM<sup>?</sup><br />
   SHEBANG<sup>?</sup><br />
   <a href="attributes.html"><em>InnerAttribute</em></a><sup>*</sup><br />
   <a href="items.html"><em>Item</em></a><sup>*</sup></p>
</blockquote>
<blockquote>
<p><strong><sup>Lexer</sup></strong><br />
UTF8BOM : <code>\uFEFF</code><br />
SHEBANG : <code>#!</code> ~[<code>[</code> <code>\n</code>] ~<code>\n</code><sup>*</sup></p>
</blockquote>
<blockquote>
<p>Note: Although Rust, like any other language, can be implemented by an
interpreter as well as a compiler, the only existing implementation is a
compiler, and the language has always been designed to be compiled. For these
reasons, this section assumes a compiler.</p>
</blockquote>
<p>Rust’s semantics obey a <em>phase distinction</em> between compile-time and
run-time.<sup class="footnote-reference"><a href="#phase-distinction">1</a></sup> Semantic rules that have a <em>static
interpretation</em> govern the success or failure of compilation, while
semantic rules that have a <em>dynamic interpretation</em> govern the behavior of the
program at run-time.</p>
<p>The compilation model centers on artifacts called <em>crates</em>. Each compilation
processes a single crate in source form, and if successful, produces a single
crate in binary form: either an executable or some sort of
library.<sup class="footnote-reference"><a href="#cratesourcefile">2</a></sup></p>
<p>A <em>crate</em> is a unit of compilation and linking, as well as versioning,
distribution, and runtime loading. A crate contains a <em>tree</em> of nested
<a href="items/modules.html">module</a> scopes. The top level of this tree is a module that is
anonymous (from the point of view of paths within the module) and any item
within a crate has a canonical <a href="paths.html">module path</a> denoting its location
within the crate’s module tree.</p>
<p>The Rust compiler is always invoked with a single source file as input, and
always produces a single output crate. The processing of that source file may
result in other source files being loaded as modules. Source files have the
extension <code>.rs</code>.</p>
<p>A Rust source file describes a module, the name and location of which —
in the module tree of the current crate — are defined from outside the
source file: either by an explicit <a href="items/modules.html"><em>Module</em></a> item in a referencing
source file, or by the name of the crate itself. Every source file is a
module, but not every module needs its own source file: <a href="items/modules.html">module
definitions</a> can be nested within one file.</p>
<p>Each source file contains a sequence of zero or more <a href="items.html"><em>Item</em></a> definitions, and
may optionally begin with any number of <a href="attributes.html">attributes</a>
that apply to the containing module, most of which influence the behavior of
the compiler. The anonymous crate module can have additional attributes that
apply to the crate as a whole.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Specify the crate name.
#![crate_name = &quot;projx&quot;]

// Specify the type of output artifact.
#![crate_type = &quot;lib&quot;]

// Turn on a warning.
// This can be done in any module, not just the anonymous crate module.
#![warn(non_camel_case_types)]
<span class="boring">}
</span></code></pre></pre>
<p>The optional <a href="https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8"><em>UTF8 byte order mark</em></a> (UTF8BOM production) indicates that the
file is encoded in UTF8. It can only occur at the beginning of the file and
is ignored by the compiler.</p>
<p>A source file can have a <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)"><em>shebang</em></a> (SHEBANG production), which indicates
to the operating system what program to use to execute this file. It serves
essentially to treat the source file as an executable script. The shebang
can only occur at the beginning of the file (but after the optional
<em>UTF8BOM</em>). It is ignored by the compiler. For example:</p>
<!-- ignore: tests don't like shebang -->
<pre><code class="language-rust ignore">#!/usr/bin/env rustx

fn main() {
    println!(&quot;Hello!&quot;);
}
</code></pre>
<h2><a class="header" href="#preludes-and-no_std" id="preludes-and-no_std">Preludes and <code>no_std</code></a></h2>
<p>All crates have a <em>prelude</em> that automatically inserts names from a specific
module, the <em>prelude module</em>, into scope of each <a href="items/modules.html">module</a> and an <a href="items/extern-crates.html"><code>extern crate</code></a> into the crate root module. By default, the <em>standard prelude</em> is used.
The linked crate is <a href="../std/index.html"><code>std</code></a> and the prelude module is <a href="../std/prelude/index.html"><code>std::prelude::v1</code></a>.</p>
<p>The prelude can be changed to the <em>core prelude</em> by using the <code>no_std</code>
<a href="attributes.html">attribute</a> on the root crate module. The linked crate is <a href="../core/index.html"><code>core</code></a> and the
prelude module is <a href="../core/prelude/index.html"><code>core::prelude::v1</code></a>. Using the core prelude over the
standard prelude is useful when either the crate is targeting a platform that
does not support the standard library or is purposefully not using the
capabilities of the standard library. Those capabilities are mainly dynamic
memory allocation (e.g. <code>Box</code> and <code>Vec</code>) and file and network capabilities (e.g.
<code>std::fs</code> and <code>std::io</code>).</p>
<div class="warning">
<p>Warning: Using <code>no_std</code> does not prevent the standard library from being linked
in. It is still valid to put <code>extern crate std;</code> into the crate and dependencies
can also link it in.</p>
</div>
<h2><a class="header" href="#main-functions" id="main-functions">Main Functions</a></h2>
<p>A crate that contains a <code>main</code> <a href="items/functions.html">function</a> can be compiled to an executable. If a
<code>main</code> function is present, it must take no arguments, must not declare any
<a href="trait-bounds.html">trait or lifetime bounds</a>, must not have any <a href="items/generics.html#where-clauses">where clauses</a>, and its return
type must  be one of the following:</p>
<ul>
<li><code>()</code></li>
<li><code>Result&lt;(), E&gt; where E: Error</code></li>
</ul>
<!-- * `!` -->
<!-- * Result<!, E> where E: Error` -->
<blockquote>
<p>Note: The implementation of which return types are allowed is determined by
the unstable <a href="../std/process/trait.Termination.html"><code>Termination</code></a> trait.</p>
</blockquote>
<!-- If the previous section needs updating (from "must take no arguments"
  onwards, also update it in the testing.md file -->
<h3><a class="header" href="#the-no_main-attribute" id="the-no_main-attribute">The <code>no_main</code> attribute</a></h3>
<p>The <em><code>no_main</code> <a href="attributes.html">attribute</a></em> may be applied at the crate level to disable
emitting the <code>main</code> symbol for an executable binary. This is useful when some
other object being linked to defines <code>main</code>.</p>
<h2><a class="header" href="#the-crate_name-attribute" id="the-crate_name-attribute">The <code>crate_name</code> attribute</a></h2>
<p>The <em><code>crate_name</code> <a href="attributes.html">attribute</a></em> may be applied at the crate level to specify the
name of the crate with the <a href="attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> syntax.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>#![crate_name = &quot;mycrate&quot;]
<span class="boring">fn main() {
</span><span class="boring">}
</span></code></pre></pre>
<p>The crate name must not be empty, and must only contain <a href="../std/primitive.char.html#method.is_alphanumeric">Unicode alphanumeric</a>
or <code>-</code> (U+002D) characters.</p>
<div class="footnote-definition" id="phase-distinction"><sup class="footnote-definition-label">1</sup>
<p>This distinction would also exist in an interpreter.
Static checks like syntactic analysis, type checking, and lints should
happen before the program is executed regardless of when it is executed.</p>
</div>
<div class="footnote-definition" id="cratesourcefile"><sup class="footnote-definition-label">2</sup>
<p>A crate is somewhat analogous to an <em>assembly</em> in the
ECMA-335 CLI model, a <em>library</em> in the SML/NJ Compilation Manager, a <em>unit</em>
in the Owens and Flatt module system, or a <em>configuration</em> in Mesa.</p>
</div>
<h1><a class="header" href="#conditional-compilation" id="conditional-compilation">Conditional compilation</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ConfigurationPredicate</em> :<br />
      <em>ConfigurationOption</em><br />
   | <em>ConfigurationAll</em><br />
   | <em>ConfigurationAny</em><br />
   | <em>ConfigurationNot</em></p>
<p><em>ConfigurationOption</em> :<br />
   <a href="identifiers.html">IDENTIFIER</a> (<code>=</code> (<a href="tokens.html#string-literals">STRING_LITERAL</a> | <a href="tokens.html#raw-string-literals">RAW_STRING_LITERAL</a>))<sup>?</sup></p>
<p><em>ConfigurationAll</em><br />
   <code>all</code> <code>(</code> <em>ConfigurationPredicateList</em><sup>?</sup> <code>)</code></p>
<p><em>ConfigurationAny</em><br />
   <code>any</code> <code>(</code> <em>ConfigurationPredicateList</em><sup>?</sup> <code>)</code></p>
<p><em>ConfigurationNot</em><br />
   <code>not</code> <code>(</code> <em>ConfigurationPredicate</em> <code>)</code></p>
<p><em>ConfigurationPredicateList</em><br />
   <em>ConfigurationPredicate</em> (<code>,</code> <em>ConfigurationPredicate</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<p><em>Conditionally compiled source code</em> is source code that may or may not be
considered a part of the source code depending on certain conditions. <!-- This
definition is sort of vacuous --> Source code can be conditionally compiled
using the <a href="attributes.html">attributes</a> <a href="conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a> and <a href="conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a> and the built-in <a href="conditional-compilation.html#the-cfg-macro"><code>cfg</code> macro</a>.
These conditions are based on the target architecture of the compiled crate,
arbitrary values passed to the compiler, and a few other miscellaneous things
further described below in detail.</p>
<p>Each form of conditional compilation takes a <em>configuration predicate</em> that
evaluates to true or false. The predicate is one of the following:</p>
<ul>
<li>A configuration option. It is true if the option is set and false if it is
unset.</li>
<li><code>all()</code> with a comma separated list of configuration predicates. It is false
if at least one predicate is false. If there are no predicates, it is true.</li>
<li><code>any()</code> with a comma separated list of configuration predicates. It is true
if at least one predicate is true. If there are no predicates, it is false.</li>
<li><code>not()</code> with a configuration predicate. It is true if its predicate is false
and false if its predicate is true.</li>
</ul>
<p><em>Configuration options</em> are names and key-value pairs that are either set or
unset. Names are written as a single identifier such as, for example, <code>unix</code>.
Key-value pairs are written as an identifier, <code>=</code>, and then a string. For
example, <code>target_arch = &quot;x86_64&quot;</code> is a configuration option.</p>
<blockquote>
<p><strong>Note</strong>: Whitespace around the <code>=</code> is ignored. <code>foo=&quot;bar&quot;</code> and <code>foo = &quot;bar&quot;</code>
are equivalent configuration options.</p>
</blockquote>
<p>Keys are not unique in the set of key-value configuration options. For example,
both <code>feature = &quot;std&quot;</code> and <code>feature = &quot;serde&quot;</code> can be set at the same time.</p>
<h2><a class="header" href="#set-configuration-options" id="set-configuration-options">Set Configuration Options</a></h2>
<p>Which configuration options are set is determined statically during the
compilation of the crate. Certain options are <em>compiler-set</em> based on data
about the compilation. Other options are <em>arbitrarily-set</em>, set based on input
passed to the compiler outside of the code. It is not possible to set a
configuration option from within the source code of the crate being compiled.</p>
<blockquote>
<p><strong>Note</strong>: For <code>rustc</code>, arbitrary-set configuration options are set using the
<a href="../rustc/command-line-arguments.html#--cfg-configure-the-compilation-environment"><code>--cfg</code></a> flag.</p>
</blockquote>
<div class="warning">
<p>Warning: It is possible for arbitrarily-set configuration options to have the
same value as compiler-set configuration options. For example, it is possible
to do <code>rustc --cfg &quot;unix&quot; program.rs</code> while compiling to a Windows target, and
have both <code>unix</code> and <code>windows</code> configuration options set at the same time. It
is unwise to actually do this.</p>
</div>
<h3><a class="header" href="#target_arch" id="target_arch"><code>target_arch</code></a></h3>
<p>Key-value option set once with the target’s CPU architecture. The value is
similar to the first element of the platform’s target triple, but not
identical.</p>
<p>Example values:</p>
<ul>
<li><code>&quot;x86&quot;</code></li>
<li><code>&quot;x86_64&quot;</code></li>
<li><code>&quot;mips&quot;</code></li>
<li><code>&quot;powerpc&quot;</code></li>
<li><code>&quot;powerpc64&quot;</code></li>
<li><code>&quot;arm&quot;</code></li>
<li><code>&quot;aarch64&quot;</code></li>
</ul>
<h3><a class="header" href="#target_feature" id="target_feature"><code>target_feature</code></a></h3>
<p>Key-value option set for each platform feature available for the current
compilation target.</p>
<p>Example values:</p>
<ul>
<li><code>&quot;avx&quot;</code></li>
<li><code>&quot;avx2&quot;</code></li>
<li><code>&quot;crt-static&quot;</code></li>
<li><code>&quot;rdrand&quot;</code></li>
<li><code>&quot;sse&quot;</code></li>
<li><code>&quot;sse2&quot;</code></li>
<li><code>&quot;sse4.1&quot;</code></li>
</ul>
<p>See the <a href="attributes/codegen.html#the-target_feature-attribute"><code>target_feature</code> attribute</a> for more details on the available
features. An additional feature of <code>crt-static</code> is available to the
<code>target_feature</code> option to indicate that a <a href="linkage.html#static-and-dynamic-c-runtimes">static C runtime</a> is available.</p>
<h3><a class="header" href="#target_os" id="target_os"><code>target_os</code></a></h3>
<p>Key-value option set once with the target’s operating system. This value is
similar to the second and third element of the platform’s target triple.</p>
<p>Example values:</p>
<ul>
<li><code>&quot;windows&quot;</code></li>
<li><code>&quot;macos&quot;</code></li>
<li><code>&quot;ios&quot;</code></li>
<li><code>&quot;linux&quot;</code></li>
<li><code>&quot;android&quot;</code></li>
<li><code>&quot;freebsd&quot;</code></li>
<li><code>&quot;dragonfly&quot;</code></li>
<li><code>&quot;openbsd&quot;</code></li>
<li><code>&quot;netbsd&quot;</code></li>
</ul>
<h3><a class="header" href="#target_family" id="target_family"><code>target_family</code></a></h3>
<p>Key-value option set at most once with the target’s operating system value.</p>
<p>Example values:</p>
<ul>
<li><code>&quot;unix&quot;</code></li>
<li><code>&quot;windows&quot;</code></li>
</ul>
<h3><a class="header" href="#unix-and-windows" id="unix-and-windows"><code>unix</code> and <code>windows</code></a></h3>
<p><code>unix</code> is set if <code>target_family = &quot;unix&quot;</code> is set and <code>windows</code> is set if
<code>target_family = &quot;windows&quot;</code> is set.</p>
<h3><a class="header" href="#target_env" id="target_env"><code>target_env</code></a></h3>
<p>Key-value option set with further disambiguating information about the target
platform with information about the ABI or <code>libc</code> used. For historical reasons,
this value is only defined as not the empty-string when actually needed for
disambiguation. Thus, for example, on many GNU platforms, this value will be
empty. This value is similar to the fourth element of the platform’s target
triple. One difference is that embedded ABIs such as <code>gnueabihf</code> will simply
define <code>target_env</code> as <code>&quot;gnu&quot;</code>.</p>
<p>Example values:</p>
<ul>
<li><code>&quot;&quot;</code></li>
<li><code>&quot;gnu&quot;</code></li>
<li><code>&quot;msvc&quot;</code></li>
<li><code>&quot;musl&quot;</code></li>
<li><code>&quot;sgx&quot;</code></li>
</ul>
<h3><a class="header" href="#target_endian" id="target_endian"><code>target_endian</code></a></h3>
<p>Key-value option set once with either a value of “little” or “big” depending
on the endianness of the target’s CPU.</p>
<h3><a class="header" href="#target_pointer_width" id="target_pointer_width"><code>target_pointer_width</code></a></h3>
<p>Key-value option set once with the target’s pointer width in bits. For example,
for targets with 32-bit pointers, this is set to <code>&quot;32&quot;</code>. Likewise, it is set
to <code>&quot;64&quot;</code> for targets with 64-bit pointers.</p>
<!-- Are there targets that have a different bit number? -->
<h3><a class="header" href="#target_vendor" id="target_vendor"><code>target_vendor</code></a></h3>
<p>Key-value option set once with the vendor of the target.</p>
<p>Example values:</p>
<ul>
<li><code>&quot;apple&quot;</code></li>
<li><code>&quot;fortanix&quot;</code></li>
<li><code>&quot;pc&quot;</code></li>
<li><code>&quot;unknown&quot;</code></li>
</ul>
<h3><a class="header" href="#test" id="test"><code>test</code></a></h3>
<p>Enabled when compiling the test harness. Done with <code>rustc</code> by using the
<a href="../rustc/command-line-arguments.html#--test-build-a-test-harness"><code>--test</code></a> flag. See <a href="attributes/testing.html">Testing</a> for more on testing support.</p>
<h3><a class="header" href="#debug_assertions" id="debug_assertions"><code>debug_assertions</code></a></h3>
<p>Enabled by default when compiling without optimizations.
This can be used to enable extra debugging code in development but not in
production.  For example, it controls the behavior of the standard library’s
<a href="../std/macro.debug_assert.html"><code>debug_assert!</code></a> macro.</p>
<h3><a class="header" href="#proc_macro" id="proc_macro"><code>proc_macro</code></a></h3>
<p>Set when the crate being compiled is being compiled with the <code>proc_macro</code>
<a href="linkage.html">crate type</a>.</p>
<h2><a class="header" href="#forms-of-conditional-compilation" id="forms-of-conditional-compilation">Forms of conditional compilation</a></h2>
<h3><a class="header" href="#the-cfg-attribute" id="the-cfg-attribute">The <code>cfg</code> attribute</a></h3>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>CfgAttrAttribute</em> :<br />
   <code>cfg</code> <code>(</code> <em>ConfigurationPredicate</em> <code>)</code></p>
</blockquote>
<!-- should we say they're active attributes here? -->
<p>The <code>cfg</code> <a href="attributes.html">attribute</a> conditionally includes the thing it is attached to based
on a configuration predicate.</p>
<p>It is written as <code>cfg</code>, <code>(</code>, a configuration predicate, and finally <code>)</code>.</p>
<p>If the predicate is true, the thing is rewritten to not have the <code>cfg</code> attribute
on it. If the predicate is false, the thing is removed from the source code.</p>
<p>Some examples on functions:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// The function is only included in the build when compiling for macOS
#[cfg(target_os = &quot;macos&quot;)]
fn macos_only() {
  // ...
}

// This function is only included when either foo or bar is defined
#[cfg(any(foo, bar))]
fn needs_foo_or_bar() {
  // ...
}

// This function is only included when compiling for a unixish OS with a 32-bit
// architecture
#[cfg(all(unix, target_pointer_width = &quot;32&quot;))]
fn on_32bit_unix() {
  // ...
}

// This function is only included when foo is not defined
#[cfg(not(foo))]
fn needs_not_foo() {
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>cfg</code> attribute is allowed anywhere attributes are allowed.</p>
<h3><a class="header" href="#the-cfg_attr-attribute" id="the-cfg_attr-attribute">The <code>cfg_attr</code> attribute</a></h3>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>CfgAttrAttribute</em> :<br />
   <code>cfg_attr</code> <code>(</code> <em>ConfigurationPredicate</em> <code>,</code> <em>CfgAttrs</em><sup>?</sup> <code>)</code></p>
<p><em>CfgAttrs</em> :<br />
   <a href="attributes.html"><em>Attr</em></a> (<code>,</code> <a href="attributes.html"><em>Attr</em></a>)<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<p>The <code>cfg_attr</code> <a href="attributes.html">attribute</a> conditionally includes <a href="attributes.html">attributes</a> based on a
configuration predicate.</p>
<p>When the configuration predicate is true, this attribute expands out to the
attributes listed after the predicate. For example, the following module will
either be found at <code>linux.rs</code> or <code>windows.rs</code> based on the target.</p>
<!-- ignore: `mod` needs multiple files -->
<pre><code class="language-rust ignore">#[cfg_attr(linux, path = &quot;linux.rs&quot;)]
#[cfg_attr(windows, path = &quot;windows.rs&quot;)]
mod os;
</code></pre>
<p>Zero, one, or more attributes may be listed. Multiple attributes will each be
expanded into separate attributes. For example:</p>
<!-- ignore: fake attributes -->
<pre><code class="language-rust ignore">#[cfg_attr(feature = &quot;magic&quot;, sparkles, crackles)]
fn bewitched() {}

// When the `magic` feature flag is enabled, the above will expand to:
#[sparkles]
#[crackles]
fn bewitched() {}
</code></pre>
<blockquote>
<p><strong>Note</strong>: The <code>cfg_attr</code> can expand to another <code>cfg_attr</code>. For example,
<code>#[cfg_attr(linux, cfg_attr(feature = &quot;multithreaded&quot;, some_other_attribute))]</code>
is valid. This example would be equivalent to
<code>#[cfg_attr(all(linux, feature =&quot;multithreaded&quot;), some_other_attribute)]</code>.</p>
</blockquote>
<p>The <code>cfg_attr</code> attribute is allowed anywhere attributes are allowed.</p>
<h3><a class="header" href="#the-cfg-macro" id="the-cfg-macro">The <code>cfg</code> macro</a></h3>
<p>The built-in <code>cfg</code> macro takes in a single configuration predicate and evaluates
to the <code>true</code> literal when the predicate is true and the <code>false</code> literal when
it is false.</p>
<p>For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let machine_kind = if cfg!(unix) {
  &quot;unix&quot;
} else if cfg!(windows) {
  &quot;windows&quot;
} else {
  &quot;unknown&quot;
};

println!(&quot;I'm running on a {} machine!&quot;, machine_kind);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#items" id="items">Items</a></h1>
<blockquote>
<p><strong><sup>Syntax:<sup></strong><br />
<em>Item</em>:<br />
   <a href="attributes.html"><em>OuterAttribute</em></a><sup>*</sup><br />
      <em>VisItem</em><br />
   | <em>MacroItem</em></p>
<p><em>VisItem</em>:<br />
   <a href="visibility-and-privacy.html"><em>Visibility</em></a><sup>?</sup><br />
   (<br />
          <a href="items/modules.html"><em>Module</em></a><br />
      | <a href="items/extern-crates.html"><em>ExternCrate</em></a><br />
      | <a href="items/use-declarations.html"><em>UseDeclaration</em></a><br />
      | <a href="items/functions.html"><em>Function</em></a><br />
      | <a href="items/type-aliases.html"><em>TypeAlias</em></a><br />
      | <a href="items/structs.html"><em>Struct</em></a><br />
      | <a href="items/enumerations.html"><em>Enumeration</em></a><br />
      | <a href="items/unions.html"><em>Union</em></a><br />
      | <a href="items/constant-items.html"><em>ConstantItem</em></a><br />
      | <a href="items/static-items.html"><em>StaticItem</em></a><br />
      | <a href="items/traits.html"><em>Trait</em></a><br />
      | <a href="items/implementations.html"><em>Implementation</em></a><br />
      | <a href="items/external-blocks.html"><em>ExternBlock</em></a><br />
   )</p>
<p><em>MacroItem</em>:<br />
      <a href="macros.html#macro-invocation"><em>MacroInvocationSemi</em></a><br />
   | <a href="macros-by-example.html"><em>MacroRulesDefinition</em></a></p>
</blockquote>
<p>An <em>item</em> is a component of a crate. Items are organized within a crate by a
nested set of <a href="items/modules.html">modules</a>. Every crate has a single “outermost” anonymous module;
all further items within the crate have <a href="paths.html">paths</a> within the module tree of the
crate.</p>
<p>Items are entirely determined at compile-time, generally remain fixed during
execution, and may reside in read-only memory.</p>
<p>There are several kinds of items:</p>
<ul>
<li><a href="items/modules.html">modules</a></li>
<li><a href="items/extern-crates.html"><code>extern crate</code> declarations</a></li>
<li><a href="items/use-declarations.html"><code>use</code> declarations</a></li>
<li><a href="items/functions.html">function definitions</a></li>
<li><a href="items/type-aliases.html">type definitions</a></li>
<li><a href="items/structs.html">struct definitions</a></li>
<li><a href="items/enumerations.html">enumeration definitions</a></li>
<li><a href="items/unions.html">union definitions</a></li>
<li><a href="items/constant-items.html">constant items</a></li>
<li><a href="items/static-items.html">static items</a></li>
<li><a href="items/traits.html">trait definitions</a></li>
<li><a href="items/implementations.html">implementations</a></li>
<li><a href="items/external-blocks.html"><code>extern</code> blocks</a></li>
</ul>
<p>Some items form an implicit scope for the declaration of sub-items. In other
words, within a function or module, declarations of items can (in many cases)
be mixed with the statements, control blocks, and similar artifacts that
otherwise compose the item body. The meaning of these scoped items is the same
as if the item was declared outside the scope — it is still a static item
— except that the item’s <em>path name</em> within the module namespace is
qualified by the name of the enclosing item, or is private to the enclosing
item (in the case of functions). The grammar specifies the exact locations in
which sub-item declarations may appear.</p>
<h1><a class="header" href="#modules" id="modules">Modules</a></h1>
<blockquote>
<p><strong><sup>Syntax:</sup></strong><br />
<em>Module</em> :<br />
      <code>mod</code> <a href="items/../identifiers.html">IDENTIFIER</a> <code>;</code><br />
   | <code>mod</code> <a href="items/../identifiers.html">IDENTIFIER</a> <code>{</code><br />
        <a href="items/../attributes.html"><em>InnerAttribute</em></a><sup>*</sup><br />
        <a href="items/../items.html"><em>Item</em></a><sup>*</sup><br />
      <code>}</code></p>
</blockquote>
<p>A module is a container for zero or more <a href="items/../items.html">items</a>.</p>
<p>A <em>module item</em> is a module, surrounded in braces, named, and prefixed with the
keyword <code>mod</code>. A module item introduces a new, named module into the tree of
modules making up a crate. Modules can nest arbitrarily.</p>
<p>An example of a module:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>mod math {
    type Complex = (f64, f64);
    fn sin(f: f64) -&gt; f64 {
        /* ... */
<span class="boring">      unimplemented!();
</span>    }
    fn cos(f: f64) -&gt; f64 {
        /* ... */
<span class="boring">      unimplemented!();
</span>    }
    fn tan(f: f64) -&gt; f64 {
        /* ... */
<span class="boring">      unimplemented!();
</span>    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Modules and types share the same namespace. Declaring a named type with the
same name as a module in scope is forbidden: that is, a type definition, trait,
struct, enumeration, union, type parameter or crate can’t shadow the name of a
module in scope, or vice versa. Items brought into scope with <code>use</code> also have
this restriction.</p>
<h2><a class="header" href="#module-source-filenames" id="module-source-filenames">Module Source Filenames</a></h2>
<p>A module without a body is loaded from an external file. When the module does
not have a <code>path</code> attribute, the path to the file mirrors the logical <a href="items/../paths.html">module
path</a>. Ancestor module path components are directories, and the module’s
contents are in a file with the name of the module plus the <code>.rs</code> extension.
For example, the following module structure can have this corresponding
filesystem structure:</p>
<table><thead><tr><th>Module Path</th><th>Filesystem Path</th><th>File Contents</th></tr></thead><tbody>
<tr><td><code>crate</code></td><td><code>lib.rs</code></td><td><code>mod util;</code></td></tr>
<tr><td><code>crate::util</code></td><td><code>util.rs</code></td><td><code>mod config;</code></td></tr>
<tr><td><code>crate::util::config</code></td><td><code>util/config.rs</code></td><td></td></tr>
</tbody></table>
<p>Module filenames may also be the name of the module as a directory with the
contents in a file named <code>mod.rs</code> within that directory. The above example can
alternately be expressed with <code>crate::util</code>‘s contents in a file named
<code>util/mod.rs</code>. It is not allowed to have both <code>util.rs</code> and <code>util/mod.rs</code>.</p>
<blockquote>
<p><strong>Note</strong>: Previous to <code>rustc</code> 1.30, using <code>mod.rs</code> files was the way to load
a module with nested children. It is encouraged to use the new naming
convention as it is more consistent, and avoids having many files named
<code>mod.rs</code> within a project.</p>
</blockquote>
<h3><a class="header" href="#the-path-attribute" id="the-path-attribute">The <code>path</code> attribute</a></h3>
<p>The directories and files used for loading external file modules can be
influenced with the <code>path</code> attribute.</p>
<p>For <code>path</code> attributes on modules not inside inline module blocks, the file
path is relative to the directory the source file is located. For example, the
following code snippet would use the paths shown based on where it is located:</p>
<!-- ignore: requires external files -->
<pre><code class="language-rust ignore">#[path = &quot;foo.rs&quot;]
mod c;
</code></pre>
<table><thead><tr><th>Source File</th><th><code>c</code>‘s File Location</th><th><code>c</code>‘s Module Path</th></tr></thead><tbody>
<tr><td><code>src/a/b.rs</code></td><td><code>src/a/foo.rs</code></td><td><code>crate::a::b::c</code></td></tr>
<tr><td><code>src/a/mod.rs</code></td><td><code>src/a/foo.rs</code></td><td><code>crate::a::c</code></td></tr>
</tbody></table>
<p>For <code>path</code> attributes inside inline module blocks, the relative location of
the file path depends on the kind of source file the <code>path</code> attribute is
located in. “mod-rs” source files are root modules (such as <code>lib.rs</code> or
<code>main.rs</code>) and modules with files named <code>mod.rs</code>. “non-mod-rs” source files
are all other module files. Paths for <code>path</code> attributes inside inline module
blocks in a mod-rs file are relative to the directory of the mod-rs file
including the inline module components as directories. For non-mod-rs files,
it is the same except the path starts with a directory with the name of the
non-mod-rs module. For example, the following code snippet would use the paths
shown based on where it is located:</p>
<!-- ignore: requires external files -->
<pre><code class="language-rust ignore">mod inline {
    #[path = &quot;other.rs&quot;]
    mod inner;
}
</code></pre>
<table><thead><tr><th>Source File</th><th><code>inner</code>‘s File Location</th><th><code>inner</code>‘s Module Path</th></tr></thead><tbody>
<tr><td><code>src/a/b.rs</code></td><td><code>src/a/b/inline/other.rs</code></td><td><code>crate::a::b::inline::inner</code></td></tr>
<tr><td><code>src/a/mod.rs</code></td><td><code>src/a/inline/other.rs</code></td><td><code>crate::a::inline::inner</code></td></tr>
</tbody></table>
<p>An example of combining the above rules of <code>path</code> attributes on inline modules
and nested modules within (applies to both mod-rs and non-mod-rs files):</p>
<!-- ignore: requires external files -->
<pre><code class="language-rust ignore">#[path = &quot;thread_files&quot;]
mod thread {
    // Load the `local_data` module from `thread_files/tls.rs` relative to
    // this source file's directory.
    #[path = &quot;tls.rs&quot;]
    mod local_data;
}
</code></pre>
<h2><a class="header" href="#prelude-items" id="prelude-items">Prelude Items</a></h2>
<p>Modules implicitly have some names in scope. These name are to built-in types,
macros imported with <a href="items/../macros-by-example.html#the-macro_use-attribute"><code>#[macro_use]</code></a> on an extern crate, and by the crate’s
<a href="items/../crates-and-source-files.html#preludes-and-no_std">prelude</a>. These names are all made of a single identifier. These names are not
part of the module, so for example, any name <code>name</code>, <code>self::name</code> is not a
valid path. The names added by the <a href="items/../crates-and-source-files.html#preludes-and-no_std">prelude</a> can be removed by placing the
<code>no_implicit_prelude</code> <a href="items/../attributes.html">attribute</a> onto the module or one of its ancestor modules.</p>
<h2><a class="header" href="#attributes-on-modules" id="attributes-on-modules">Attributes on Modules</a></h2>
<p>Modules, like all items, accept outer attributes. They also accept inner
attributes: either after <code>{</code> for a module with a body, or at the beginning of the
source file, after the optional BOM and shebang.</p>
<p>The built-in attributes that have meaning on a module are <a href="items/../conditional-compilation.html"><code>cfg</code></a>,
<a href="items/../attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a>, <a href="items/../../rustdoc/the-doc-attribute.html"><code>doc</code></a>, <a href="items/../attributes/diagnostics.html#lint-check-attributes">the lint check attributes</a>, <code>path</code>, and
<code>no_implicit_prelude</code>. Modules also accept macro attributes.</p>
<h1><a class="header" href="#extern-crate-declarations" id="extern-crate-declarations">Extern crate declarations</a></h1>
<blockquote>
<p><strong><sup>Syntax:<sup></strong><br />
<em>ExternCrate</em> :<br />
   <code>extern</code> <code>crate</code> <em>CrateRef</em> <em>AsClause</em><sup>?</sup> <code>;</code></p>
<p><em>CrateRef</em> :<br />
   <a href="items/../identifiers.html">IDENTIFIER</a> | <code>self</code></p>
<p><em>AsClause</em> :<br />
   <code>as</code> ( <a href="items/../identifiers.html">IDENTIFIER</a> | <code>_</code> )</p>
</blockquote>
<p>An <em><code>extern crate</code> declaration</em> specifies a dependency on an external crate.
The external crate is then bound into the declaring scope as the <a href="items/../identifiers.html">identifier</a>
provided in the <code>extern crate</code> declaration. The <code>as</code> clause can be used to
bind the imported crate to a different name.</p>
<p>The external crate is resolved to a specific <code>soname</code> at compile time, and a
runtime linkage requirement to that <code>soname</code> is passed to the linker for
loading at runtime. The <code>soname</code> is resolved at compile time by scanning the
compiler’s library path and matching the optional <code>crateid</code> provided against
the <code>crateid</code> attributes that were declared on the external crate when it was
compiled. If no <code>crateid</code> is provided, a default <code>name</code> attribute is assumed,
equal to the <a href="items/../identifiers.html">identifier</a> given in the <code>extern crate</code> declaration.</p>
<p>The <code>self</code> crate may be imported which creates a binding to the current crate.
In this case the <code>as</code> clause must be used to specify the name to bind it to.</p>
<p>Three examples of <code>extern crate</code> declarations:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">extern crate pcre;

extern crate std; // equivalent to: extern crate std as std;

extern crate std as ruststd; // linking to 'std' under another name
</code></pre>
<p>When naming Rust crates, hyphens are disallowed. However, Cargo packages may
make use of them. In such case, when <code>Cargo.toml</code> doesn’t specify a crate name,
Cargo will transparently replace <code>-</code> with <code>_</code> (Refer to <a href="https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md">RFC 940</a> for more
details).</p>
<p>Here is an example:</p>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">// Importing the Cargo package hello-world
extern crate hello_world; // hyphen replaced with an underscore
</code></pre>
<h2><a class="header" href="#extern-prelude" id="extern-prelude">Extern Prelude</a></h2>
<p>External crates imported with <code>extern crate</code> in the root module or provided to
the compiler (as with the <code>--extern</code> flag with <code>rustc</code>) are added to the
“extern prelude”. Crates in the extern prelude are in scope in the entire
crate, including inner modules. If imported with <code>extern crate orig_name as new_name</code>, then the symbol <code>new_name</code> is instead added to the prelude.</p>
<p>The <code>core</code> crate is always added to the extern prelude. The <code>std</code> crate
is added as long as the <a href="items/../crates-and-source-files.html#preludes-and-no_std"><code>no_std</code></a> attribute is not specified in the crate root.</p>
<p>The <a href="items/modules.html#prelude-items"><code>no_implicit_prelude</code></a> attribute can be used on a module to disable
prelude lookups within that module.</p>
<blockquote>
<p><strong>Edition Differences</strong>: In the 2015 edition, crates in the extern prelude
cannot be referenced via <a href="items/use-declarations.html">use declarations</a>, so it is generally standard
practice to include <code>extern crate</code> declarations to bring them into scope.</p>
<p>Beginning in the 2018 edition, <a href="items/use-declarations.html">use declarations</a> can reference crates in
the extern prelude, so it is considered unidiomatic to use <code>extern crate</code>.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: Additional crates that ship with <code>rustc</code>, such as <a href="https://doc.rust-lang.org/proc_macro/"><code>proc_macro</code></a>,
<a href="https://doc.rust-lang.org/alloc/"><code>alloc</code></a>, and <a href="https://doc.rust-lang.org/test/"><code>test</code></a>, are not automatically included with the <code>--extern</code>
flag when using Cargo. They must be brought into scope with an <code>extern crate</code> declaration, even in the 2018 edition.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>extern crate proc_macro;
use proc_macro::TokenStream;
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<!--
The proc_macro/alloc/test limitation may be lifted if the `--extern`
flag is stabilized and used. See tracking issue
https://github.com/rust-lang/rust/issues/57288 and the unstable
`--extern` flag added in https://github.com/rust-lang/rust/pull/54116.
-->
<h2><a class="header" href="#underscore-imports" id="underscore-imports">Underscore Imports</a></h2>
<p>An external crate dependency can be declared without binding its name in scope
by using an underscore with the form <code>extern crate foo as _</code>. This may be
useful for crates that only need to be linked, but are never referenced, and
will avoid being reported as unused.</p>
<p>The <a href="items/../macros-by-example.html#the-macro_use-attribute"><code>macro_use</code> attribute</a> works as usual and import the macro names
into the macro-use prelude.</p>
<h2><a class="header" href="#the-no_link-attribute" id="the-no_link-attribute">The <code>no_link</code> attribute</a></h2>
<p>The <em><code>no_link</code> attribute</em> may be specified on an <code>extern crate</code> item to
prevent linking the crate into the output. This is commonly used to load a
crate to access only its macros.</p>
<h1><a class="header" href="#use-declarations" id="use-declarations">Use declarations</a></h1>
<blockquote>
<p><strong><sup>Syntax:</sup></strong><br />
<em>UseDeclaration</em> :<br />
   <code>use</code> <em>UseTree</em> <code>;</code></p>
<p><em>UseTree</em> :<br />
      (<a href="items/../paths.html#simple-paths"><em>SimplePath</em></a><sup>?</sup> <code>::</code>)<sup>?</sup> <code>*</code><br />
   | (<a href="items/../paths.html#simple-paths"><em>SimplePath</em></a><sup>?</sup> <code>::</code>)<sup>?</sup> <code>{</code> (<em>UseTree</em> ( <code>,</code>  <em>UseTree</em> )<sup>*</sup> <code>,</code><sup>?</sup>)<sup>?</sup> <code>}</code><br />
   | <a href="items/../paths.html#simple-paths"><em>SimplePath</em></a> ( <code>as</code> ( <a href="items/../identifiers.html">IDENTIFIER</a> | <code>_</code> ) )<sup>?</sup></p>
</blockquote>
<p>A <em>use declaration</em> creates one or more local name bindings synonymous with
some other <a href="items/../paths.html">path</a>. Usually a <code>use</code> declaration is used to shorten the path
required to refer to a module item. These declarations may appear in <a href="items/modules.html">modules</a>
and <a href="items/../expressions/block-expr.html">blocks</a>, usually at the top.</p>
<p>Use declarations support a number of convenient shortcuts:</p>
<ul>
<li>Simultaneously binding a list of paths with a common prefix, using the
glob-like brace syntax <code>use a::b::{c, d, e::f, g::h::i};</code></li>
<li>Simultaneously binding a list of paths with a common prefix and their common
parent module, using the <code>self</code> keyword, such as <code>use a::b::{self, c, d::e};</code></li>
<li>Rebinding the target name as a new local name, using the syntax <code>use p::q::r as x;</code>. This can also be used with the last two features:
<code>use a::b::{self as ab, c as abc}</code>.</li>
<li>Binding all paths matching a given prefix, using the asterisk wildcard syntax
<code>use a::b::*;</code>.</li>
<li>Nesting groups of the previous features multiple times, such as
<code>use a::b::{self as ab, c, d::{*, e::f}};</code></li>
</ul>
<p>An example of <code>use</code> declarations:</p>
<pre><pre class="playpen"><code class="language-rust">use std::option::Option::{Some, None};
use std::collections::hash_map::{self, HashMap};

fn foo&lt;T&gt;(_: T){}
fn bar(map1: HashMap&lt;String, usize&gt;, map2: hash_map::HashMap&lt;String, usize&gt;){}

fn main() {
    // Equivalent to 'foo(vec![std::option::Option::Some(1.0f64),
    // std::option::Option::None]);'
    foo(vec![Some(1.0f64), None]);

    // Both `hash_map` and `HashMap` are in scope.
    let map1 = HashMap::new();
    let map2 = hash_map::HashMap::new();
    bar(map1, map2);
}
</code></pre></pre>
<h2><a class="header" href="#use-visibility" id="use-visibility"><code>use</code> Visibility</a></h2>
<p>Like items, <code>use</code> declarations are private to the containing module, by
default. Also like items, a <code>use</code> declaration can be public, if qualified by
the <code>pub</code> keyword. Such a <code>use</code> declaration serves to <em>re-export</em> a name. A
public <code>use</code> declaration can therefore <em>redirect</em> some public name to a
different target definition: even a definition with a private canonical path,
inside a different module. If a sequence of such redirections form a cycle or
cannot be resolved unambiguously, they represent a compile-time error.</p>
<p>An example of re-exporting:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() { }
</span>mod quux {
    pub use quux::foo::{bar, baz};

    pub mod foo {
        pub fn bar() { }
        pub fn baz() { }
    }
}
</code></pre></pre>
<p>In this example, the module <code>quux</code> re-exports two public names defined in
<code>foo</code>.</p>
<h2><a class="header" href="#use-paths" id="use-paths"><code>use</code> Paths</a></h2>
<p>Paths in <code>use</code> items must start with a crate name or one of the <a href="items/../paths.html#path-qualifiers">path
qualifiers</a> <code>crate</code>, <code>self</code>, <code>super</code>, or <code>::</code>. <code>crate</code> refers to the current
crate. <code>self</code> refers to the current module. <code>super</code> refers to the parent
module. <code>::</code> can be used to explicitly refer to a crate, requiring an extern
crate name to follow.</p>
<p>An example of what will and will not work for <code>use</code> items:</p>
<!-- Note: This example works as-is in either 2015 or 2018. -->
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#![allow(unused_imports)]
</span>use std::path::{self, Path, PathBuf};  // good: std is a crate name
use crate::foo::baz::foobaz;    // good: foo is at the root of the crate

mod foo {

    pub mod example {
        pub mod iter {}
    }

    use crate::foo::example::iter; // good: foo is at crate root
//  use example::iter;      // bad in 2015 edition: relative paths are not allowed without `self`; good in 2018 edition
    use self::baz::foobaz;  // good: self refers to module 'foo'
    use crate::foo::bar::foobar;   // good: foo is at crate root

    pub mod bar {
        pub fn foobar() { }
    }

    pub mod baz {
        use super::bar::foobar; // good: super refers to module 'foo'
        pub fn foobaz() { }
    }
}

fn main() {}
</code></pre></pre>
<blockquote>
<p><strong>Edition Differences</strong>: In the 2015 edition, <code>use</code> paths also allow
accessing items in the crate root. Using the example above, the following
<code>use</code> paths work in 2015 but not 2018:</p>
<pre><pre class="playpen"><code class="language-rust edition2015"><span class="boring">mod foo {
</span><span class="boring">    pub mod example { pub mod iter {} }
</span><span class="boring">    pub mod baz { pub fn foobaz() {} }
</span><span class="boring">}
</span>use foo::example::iter;
use ::foo::baz::foobaz;
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>The 2015 edition does not allow use declarations to reference the <a href="items/extern-crates.html#extern-prelude">extern prelude</a>.
Thus <a href="items/extern-crates.html"><code>extern crate</code></a> declarations are still required in 2015 to
reference an external crate in a use declaration. Beginning with the 2018
edition, use declarations can specify an external crate dependency the same
way <code>extern crate</code> can.</p>
<p>In the 2018 edition, if an in-scope item has the same name as an external
crate, then <code>use</code> of that crate name requires a leading <code>::</code> to
unambiguously select the crate name. This is to retain compatibility with
potential future changes. <!-- uniform_paths future-proofing --></p>
<pre><pre class="playpen"><code class="language-rust edition2018">// use std::fs; // Error, this is ambiguous.
use ::std::fs;  // Imports from the `std` crate, not the module below.
use self::std::fs as self_fs;  // Imports the module below.

mod std {
    pub mod fs {}
}
<span class="boring">fn main() {}
</span></code></pre></pre>
</blockquote>
<h2><a class="header" href="#underscore-imports-1" id="underscore-imports-1">Underscore Imports</a></h2>
<p>Items can be imported without binding to a name by using an underscore with
the form <code>use path as _</code>. This is particularly useful to import a trait so
that its methods may be used without importing the trait’s symbol, for example
if the trait’s symbol may conflict with another symbol. Another example is to
link an external crate without importing its name.</p>
<p>Asterisk glob imports will import items imported with <code>_</code> in their unnameable
form.</p>
<pre><pre class="playpen"><code class="language-rust">mod foo {
    pub trait Zoo {
        fn zoo(&amp;self) {}
    }

    impl&lt;T&gt; Zoo for T {}
}

use self::foo::Zoo as _;
struct Zoo;  // Underscore import avoids name conflict with this item.

fn main() {
    let z = Zoo;
    z.zoo();
}
</code></pre></pre>
<p>The unique, unnameable symbols are created after macro expansion so that
macros may safely emit multiple references to <code>_</code> imports. For example, the
following should not produce an error:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    ($item: item) =&gt; { $item $item }
}

m!(use std as _;);
// This expands to:
// use std as _;
// use std as _;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#functions" id="functions">Functions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Function</em> :<br />
   <em>FunctionQualifiers</em> <code>fn</code> <a href="items/../identifiers.html">IDENTIFIER</a> <a href="items/generics.html"><em>Generics</em></a><sup>?</sup><br />
      <code>(</code> <em>FunctionParameters</em><sup>?</sup> <code>)</code><br />
      <em>FunctionReturnType</em><sup>?</sup> <a href="items/generics.html#where-clauses"><em>WhereClause</em></a><sup>?</sup><br />
      <a href="items/../expressions/block-expr.html"><em>BlockExpression</em></a></p>
<p><em>FunctionQualifiers</em> :<br />
   <em>AsyncConstQualifiers</em><sup>?</sup> <code>unsafe</code><sup>?</sup> (<code>extern</code> <em>Abi</em><sup>?</sup>)<sup>?</sup></p>
<p><em>AsyncConstQualifiers</em> :<br />
   <code>async</code> | <code>const</code></p>
<p><em>Abi</em> :<br />
   <a href="items/../tokens.html#string-literals">STRING_LITERAL</a> | <a href="items/../tokens.html#raw-string-literals">RAW_STRING_LITERAL</a></p>
<p><em>FunctionParameters</em> :<br />
   <em>FunctionParam</em> (<code>,</code> <em>FunctionParam</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>FunctionParam</em> :<br />
   <a href="items/../attributes.html"><em>OuterAttribute</em></a><sup>*</sup> <a href="items/../patterns.html"><em>Pattern</em></a> <code>:</code> <a href="items/../types.html#type-expressions"><em>Type</em></a></p>
<p><em>FunctionReturnType</em> :<br />
   <code>-&gt;</code> <a href="items/../types.html#type-expressions"><em>Type</em></a></p>
</blockquote>
<p>A <em>function</em> consists of a <a href="items/../expressions/block-expr.html">block</a>, along with a name and a set of parameters.
Other than a name, all these are optional. Functions are declared with the
keyword <code>fn</code>. Functions may declare a set of <em>input</em> <a href="items/../variables.html"><em>variables</em></a>
as parameters, through which the caller passes arguments into the function, and
the <em>output</em> <a href="items/../types.html#type-expressions"><em>type</em></a> of the value the function will return to its caller
on completion.</p>
<p>When referred to, a <em>function</em> yields a first-class <em>value</em> of the
corresponding zero-sized <a href="items/../types/function-item.html"><em>function item type</em></a>, which
when called evaluates to a direct call to the function.</p>
<p>For example, this is a simple function:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn answer_to_life_the_universe_and_everything() -&gt; i32 {
    return 42;
}
<span class="boring">}
</span></code></pre></pre>
<p>As with <code>let</code> bindings, function arguments are irrefutable <a href="items/../patterns.html">patterns</a>, so any
pattern that is valid in a let binding is also valid as an argument:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn first((value, _): (i32, i32)) -&gt; i32 { value }
<span class="boring">}
</span></code></pre></pre>
<p>The block of a function is conceptually wrapped in a block that binds the
argument patterns and then <code>return</code>s the value of the function’s block. This
means that the tail expression of the block, if evaluated, ends up being
returned to the caller. As usual, an explicit return expression within
the body of the function will short-cut that implicit return, if reached.</p>
<p>For example, the function above behaves as if it was written as:</p>
<!-- ignore: example expansion -->
<pre><code class="language-rust ignore">// argument_0 is the actual first argument passed from the caller
let (value, _) = argument_0;
return {
    value
};
</code></pre>
<h2><a class="header" href="#generic-functions" id="generic-functions">Generic functions</a></h2>
<p>A <em>generic function</em> allows one or more <em>parameterized types</em> to appear in its
signature. Each type parameter must be explicitly declared in an
angle-bracket-enclosed and comma-separated list, following the function name.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// foo is generic over A and B

fn foo&lt;A, B&gt;(x: A, y: B) {
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Inside the function signature and body, the name of the type parameter can be
used as a type name. <a href="items/traits.html">Trait</a> bounds can be specified for type
parameters to allow methods with that trait to be called on values of that
type. This is specified using the <code>where</code> syntax:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::Debug;
</span>fn foo&lt;T&gt;(x: T) where T: Debug {
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>When a generic function is referenced, its type is instantiated based on the
context of the reference. For example, calling the <code>foo</code> function here:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fmt::Debug;

fn foo&lt;T&gt;(x: &amp;[T]) where T: Debug {
    // details elided
}

foo(&amp;[1, 2]);
<span class="boring">}
</span></code></pre></pre>
<p>will instantiate type parameter <code>T</code> with <code>i32</code>.</p>
<p>The type parameters can also be explicitly supplied in a trailing <a href="items/../paths.html">path</a>
component after the function name. This might be necessary if there is not
sufficient context to determine the type parameters. For example,
<code>mem::size_of::&lt;u32&gt;() == 4</code>.</p>
<h2><a class="header" href="#extern-function-qualifier" id="extern-function-qualifier">Extern function qualifier</a></h2>
<p>The <code>extern</code> function qualifier allows providing function <em>definitions</em> that can
be called with a particular ABI:</p>
<p>+<!-- ignore: fake ABI --></p>
<pre><code class="language-rust ignore">extern &quot;ABI&quot; fn foo() { /* ... */ }
</code></pre>
<p>These are often used in combination with <a href="items/external-blocks.html">external block</a> items which provide
function <em>declarations</em> that can be used to call functions without providing
their <em>definition</em>:</p>
<p>+<!-- ignore: fake ABI --></p>
<pre><code class="language-rust ignore">extern &quot;ABI&quot; {
  fn foo(); /* no body */
}
unsafe { foo() }
</code></pre>
<p>When <code>&quot;extern&quot; Abi?*</code> is omitted from <code>FunctionQualifiers</code> in function items,
the ABI <code>&quot;Rust&quot;</code> is assigned. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn foo() {}
<span class="boring">}
</span></code></pre></pre>
<p>is equivalent to:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>extern &quot;Rust&quot; fn foo() {}
<span class="boring">}
</span></code></pre></pre>
<p>Functions in Rust can be called by foreign code, and using an ABI that
differs from Rust allows, for example, to provide functions that can be
called from other programming languages like C:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Declares a function with the &quot;C&quot; ABI
extern &quot;C&quot; fn new_i32() -&gt; i32 { 0 }

// Declares a function with the &quot;stdcall&quot; ABI
<span class="boring">#[cfg(target_arch = &quot;x86_64&quot;)]
</span>extern &quot;stdcall&quot; fn new_i32_stdcall() -&gt; i32 { 0 }
<span class="boring">}
</span></code></pre></pre>
<p>Just as with <a href="items/external-blocks.html">external block</a>, when the <code>extern</code> keyword is used and the <code>&quot;ABI</code>
is omitted, the ABI used defaults to <code>&quot;C&quot;</code>. That is, this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>extern fn new_i32() -&gt; i32 { 0 }
let fptr: extern fn() -&gt; i32 = new_i32;
<span class="boring">}
</span></code></pre></pre>
<p>is equivalent to:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; fn new_i32() -&gt; i32 { 0 }
let fptr: extern &quot;C&quot; fn() -&gt; i32 = new_i32;
<span class="boring">}
</span></code></pre></pre>
<p>Functions with an ABI that differs from <code>&quot;Rust&quot;</code> do not support unwinding in the
exact same way that Rust does. Therefore, unwinding past the end of functions
with such ABIs causes the process to abort.</p>
<blockquote>
<p><strong>Note</strong>: The LLVM backend of the <code>rustc</code> implementation
aborts the process by executing an illegal instruction.</p>
</blockquote>
<h2><a class="header" href="#const-functions" id="const-functions">Const functions</a></h2>
<p>Functions qualified with the <code>const</code> keyword are const functions, as are
<a href="items/structs.html">tuple struct</a> and <a href="items/enumerations.html">tuple variant</a> constructors. <em>Const functions</em>  can be
called from within <a href="items/../const_eval.html#const-context">const context</a>s. When called from a const context, the
function is interpreted by the compiler at compile time. The interpretation
happens in the environment of the compilation target and not the host. So
<code>usize</code> is <code>32</code> bits if you are compiling against a <code>32</code> bit system, irrelevant
of whether you are building on a <code>64</code> bit or a <code>32</code> bit system.</p>
<p>If a const function is called outside a <a href="items/../const_eval.html#const-context">const context</a>, it is indistinguishable
from any other function. You can freely do anything with a const function that
you can do with a regular function.</p>
<p>Const functions have various restrictions to make sure that they can be
evaluated at compile-time. It is, for example, not possible to write a random
number generator as a const function. Calling a const function at compile-time
will always yield the same result as calling it at runtime, even when called
multiple times. There’s one exception to this rule: if you are doing complex
floating point operations in extreme situations, then you might get (very
slightly) different results. It is advisable to not make array lengths and enum
discriminants depend on floating point computations.</p>
<p>Exhaustive list of permitted structures in const functions:</p>
<blockquote>
<p><strong>Note</strong>: this list is more restrictive than what you can write in
regular constants</p>
</blockquote>
<ul>
<li>
<p>Type parameters where the parameters only have any <a href="items/../trait-bounds.html">trait bounds</a>
of the following kind:</p>
<ul>
<li>lifetimes</li>
<li><code>Sized</code> or <a href="items/../trait-bounds.html#sized"><code>?Sized</code></a></li>
</ul>
<p>This means that <code>&lt;T: 'a + ?Sized&gt;</code>, <code>&lt;T: 'b + Sized&gt;</code>, and <code>&lt;T&gt;</code>
are all permitted.</p>
<p>This rule also applies to type parameters of impl blocks that
contain const methods.</p>
<p>This does not apply to tuple struct and tuple variant constructors.</p>
</li>
<li>
<p>Arithmetic and comparison operators on integers</p>
</li>
<li>
<p>All boolean operators except for <code>&amp;&amp;</code> and <code>||</code> which are banned since
they are short-circuiting.</p>
</li>
<li>
<p>Any kind of aggregate constructor (array, <code>struct</code>, <code>enum</code>, tuple, ...)</p>
</li>
<li>
<p>Calls to other <em>safe</em> const functions (whether by function call or method call)</p>
</li>
<li>
<p>Index expressions on arrays and slices</p>
</li>
<li>
<p>Field accesses on structs and tuples</p>
</li>
<li>
<p>Reading from constants (but not statics, not even taking a reference to a static)</p>
</li>
<li>
<p><code>&amp;</code> and <code>*</code> (only dereferencing of references, not raw pointers)</p>
</li>
<li>
<p>Casts except for raw pointer to integer casts</p>
</li>
<li>
<p><code>unsafe</code> blocks and <code>const unsafe fn</code> are allowed, but the body/block may only do
the following unsafe operations:</p>
<ul>
<li>calls to const unsafe functions</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#async-functions" id="async-functions">Async functions</a></h2>
<p>Functions may be qualified as async, and this can also be combined with the
<code>unsafe</code> qualifier:</p>
<pre><pre class="playpen"><code class="language-rust edition2018">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>async fn regular_example() { }
async unsafe fn unsafe_example() { }
<span class="boring">}
</span></code></pre></pre>
<p>Async functions do no work when called: instead, they
capture their arguments into a future. When polled, that future will
execute the function’s body.</p>
<p>An async function is roughly equivalent to a function
that returns <a href="items/../types/impl-trait.html"><code>impl Future</code></a> and with an <a href="items/../expressions/block-expr.html#async-blocks"><code>async move</code> block</a> as
its body:</p>
<pre><pre class="playpen"><code class="language-rust edition2018">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Source
async fn example(x: &amp;str) -&gt; usize {
    x.len()
}
<span class="boring">}
</span></code></pre></pre>
<p>is roughly equivalent to:</p>
<pre><pre class="playpen"><code class="language-rust edition2018">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::future::Future;
</span>// Desugared
fn example&lt;'a&gt;(x: &amp;'a str) -&gt; impl Future&lt;Output = usize&gt; + 'a {
    async move { x.len() }
}
<span class="boring">}
</span></code></pre></pre>
<p>The actual desugaring is more complex:</p>
<ul>
<li>The return type in the desugaring is assumed to capture all lifetime
parameters from the <code>async fn</code> declaration. This can be seen in the
desugared example above, which explicitly outlives, and hence
captures, <code>'a</code>.</li>
<li>The <a href="items/../expressions/block-expr.html#async-blocks"><code>async move</code> block</a> in the body captures all function
parameters, including those that are unused or bound to a <code>_</code>
pattern. This ensures that function parameters are dropped in the
same order as they would be if the function were not async, except
that the drop occurs when the returned future has been fully
awaited.</li>
</ul>
<p>For more information on the effect of async, see <a href="items/../expressions/block-expr.html#async-blocks"><code>async</code> blocks</a>.</p>
<blockquote>
<p><strong>Edition differences</strong>: Async functions are only available beginning with
Rust 2018.</p>
</blockquote>
<h3><a class="header" href="#combining-async-and-unsafe" id="combining-async-and-unsafe">Combining <code>async</code> and <code>unsafe</code></a></h3>
<p>It is legal to declare a function that is both async and unsafe. The
resulting function is unsafe to call and (like any async function)
returns a future. This future is just an ordinary future and thus an
<code>unsafe</code> context is not required to “await” it:</p>
<pre><pre class="playpen"><code class="language-rust edition2018">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Returns a future that, when awaited, dereferences `x`.
//
// Soundness condition: `x` must be safe to dereference until
// the resulting future is complete.
async unsafe fn unsafe_example(x: *const i32) -&gt; i32 {
  *x
}

async fn safe_example() {
    // An `unsafe` block is required to invoke the function initially:
    let p = 22;
    let future = unsafe { unsafe_example(&amp;p) };

    // But no `unsafe` block required here. This will
    // read the value of `p`:
    let q = future.await;
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that this behavior is a consequence of the desugaring to a
function that returns an <code>impl Future</code> -- in this case, the function
we desugar to is an <code>unsafe</code> function, but the return value remains
the same.</p>
<p>Unsafe is used on an async function in precisely the same way that it
is used on other functions: it indicates that the function imposes
some additional obligations on its caller to ensure soundness. As in any
other unsafe function, these conditions may extend beyond the initial
call itself -- in the snippet above, for example, the <code>unsafe_example</code>
function took a pointer <code>x</code> as argument, and then (when awaited)
dereferenced that pointer. This implies that <code>x</code> would have to be
valid until the future is finished executing, and it is the callers
responsibility to ensure that.</p>
<h2><a class="header" href="#attributes-on-functions" id="attributes-on-functions">Attributes on functions</a></h2>
<p><a href="items/../attributes.html">Outer attributes</a> are allowed on functions. <a href="items/../attributes.html">Inner
attributes</a> are allowed directly after the <code>{</code> inside its <a href="items/../expressions/block-expr.html">block</a>.</p>
<p>This example shows an inner attribute on a function. The function will only be
available while running tests.</p>
<pre><code>fn test_only() {
    #![test]
}
</code></pre>
<blockquote>
<p>Note: Except for lints, it is idiomatic to only use outer attributes on
function items.</p>
</blockquote>
<p>The attributes that have meaning on a function are <a href="items/../conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a>, <a href="items/../conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a>, <a href="items/../attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a>,
<a href="items/../../rustdoc/the-doc-attribute.html"><code>doc</code></a>, <a href="items/../abi.html#the-export_name-attribute"><code>export_name</code></a>, <a href="items/../abi.html#the-link_section-attribute"><code>link_section</code></a>, <a href="items/../abi.html#the-no_mangle-attribute"><code>no_mangle</code></a>, <a href="items/../attributes/diagnostics.html#lint-check-attributes">the lint check
attributes</a>, <a href="items/../attributes/diagnostics.html#the-must_use-attribute"><code>must_use</code></a>, <a href="items/../procedural-macros.html">the procedural macro attributes</a>, <a href="items/../attributes/testing.html">the testing
attributes</a>, and <a href="items/../attributes/codegen.html#optimization-hints">the optimization hint attributes</a>. Functions also accept
attributes macros.</p>
<h2><a class="header" href="#attributes-on-function-parameters" id="attributes-on-function-parameters">Attributes on function parameters</a></h2>
<p><a href="items/../attributes.html">Outer attributes</a> are allowed on function parameters and the
permitted <a href="items/../attributes.html#built-in-attributes-index">built-in attributes</a> are restricted to <code>cfg</code>, <code>cfg_attr</code>, <code>allow</code>,
<code>warn</code>, <code>deny</code>, and <code>forbid</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn len(
    #[cfg(windows)] slice: &amp;[u16],
    #[cfg(not(windows))] slice: &amp;[u8],
) -&gt; usize {
    slice.len()
}
<span class="boring">}
</span></code></pre></pre>
<p>Inert helper attributes used by procedural macro attributes applied to items are also
allowed but be careful to not include these inert attributes in your final <code>TokenStream</code>.</p>
<p>For example, the following code defines an inert <code>some_inert_attribute</code> attribute that
is not formally defined anywhere and the <code>some_proc_macro_attribute</code> procedural macro is
responsible for detecting its presence and removing it from the output token stream.</p>
<!-- ignore: requires proc macro -->
<pre><code class="language-rust ignore">#[some_proc_macro_attribute]
fn foo_oof(#[some_inert_attribute] arg: u8) {
}
</code></pre>
<h1><a class="header" href="#type-aliases" id="type-aliases">Type aliases</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>TypeAlias</em> :<br />
   <code>type</code> <a href="items/../identifiers.html">IDENTIFIER</a> <a href="items/generics.html"><em>Generics</em></a><sup>?</sup>
<a href="items/generics.html#where-clauses"><em>WhereClause</em></a><sup>?</sup> <code>=</code> <a href="items/../types.html#type-expressions"><em>Type</em></a> <code>;</code></p>
</blockquote>
<p>A <em>type alias</em> defines a new name for an existing <a href="items/../types.html">type</a>. Type aliases are
declared with the keyword <code>type</code>. Every value has a single, specific type, but
may implement several different traits, or be compatible with several different
type constraints.</p>
<p>For example, the following defines the type <code>Point</code> as a synonym for the type
<code>(u8, u8)</code>, the type of pairs of unsigned 8 bit integers:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type Point = (u8, u8);
let p: Point = (41, 68);
<span class="boring">}
</span></code></pre></pre>
<p>A type alias to an enum type cannot be used to qualify the constructors:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum E { A }
type F = E;
let _: F = E::A;  // OK
// let _: F = F::A;  // Doesn't work
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#structs" id="structs">Structs</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Struct</em> :<br />
      <em>StructStruct</em><br />
   | <em>TupleStruct</em></p>
<p><em>StructStruct</em> :<br />
   <code>struct</code>
<a href="items/../identifiers.html">IDENTIFIER</a> 
<a href="items/generics.html"><em>Generics</em></a><sup>?</sup>
<a href="items/generics.html#where-clauses"><em>WhereClause</em></a><sup>?</sup>
( <code>{</code> <em>StructFields</em><sup>?</sup> <code>}</code> | <code>;</code> )</p>
<p><em>TupleStruct</em> :<br />
   <code>struct</code>
<a href="items/../identifiers.html">IDENTIFIER</a> 
<a href="items/generics.html"><em>Generics</em></a><sup>?</sup>
<code>(</code> <em>TupleFields</em><sup>?</sup> <code>)</code>
<a href="items/generics.html#where-clauses"><em>WhereClause</em></a><sup>?</sup>
<code>;</code></p>
<p><em>StructFields</em> :<br />
   <em>StructField</em> (<code>,</code> <em>StructField</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>StructField</em> :<br />
   <a href="items/../attributes.html"><em>OuterAttribute</em></a><sup>*</sup><br />
   <a href="items/../visibility-and-privacy.html"><em>Visibility</em></a><sup>?</sup><br />
   <a href="items/../identifiers.html">IDENTIFIER</a> <code>:</code> <a href="items/../types.html#type-expressions"><em>Type</em></a></p>
<p><em>TupleFields</em> :<br />
   <em>TupleField</em> (<code>,</code> <em>TupleField</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>TupleField</em> :<br />
   <a href="items/../attributes.html"><em>OuterAttribute</em></a><sup>*</sup><br />
   <a href="items/../visibility-and-privacy.html"><em>Visibility</em></a><sup>?</sup><br />
   <a href="items/../types.html#type-expressions"><em>Type</em></a></p>
</blockquote>
<p>A <em>struct</em> is a nominal <a href="items/../types/struct.html">struct type</a> defined with the keyword <code>struct</code>.</p>
<p>An example of a <code>struct</code> item and its use:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Point {x: i32, y: i32}
let p = Point {x: 10, y: 11};
let px: i32 = p.x;
<span class="boring">}
</span></code></pre></pre>
<p>A <em>tuple struct</em> is a nominal <a href="items/../types/tuple.html">tuple type</a>, also defined with the keyword
<code>struct</code>. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Point(i32, i32);
let p = Point(10, 11);
let px: i32 = match p { Point(x, _) =&gt; x };
<span class="boring">}
</span></code></pre></pre>
<p>A <em>unit-like struct</em> is a struct without any fields, defined by leaving off the
list of fields entirely. Such a struct implicitly defines a constant of its
type with the same name. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Cookie;
let c = [Cookie, Cookie {}, Cookie, Cookie {}];
<span class="boring">}
</span></code></pre></pre>
<p>is equivalent to</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Cookie {}
const Cookie: Cookie = Cookie {};
let c = [Cookie, Cookie {}, Cookie, Cookie {}];
<span class="boring">}
</span></code></pre></pre>
<p>The precise memory layout of a struct is not specified. One can specify a
particular layout using the <a href="items/../type-layout.html#representations"><code>repr</code> attribute</a>.</p>
<h1><a class="header" href="#enumerations" id="enumerations">Enumerations</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Enumeration</em> :<br />
   <code>enum</code>
<a href="items/../identifiers.html">IDENTIFIER</a> 
<a href="items/generics.html"><em>Generics</em></a><sup>?</sup>
<a href="items/generics.html#where-clauses"><em>WhereClause</em></a><sup>?</sup>
<code>{</code> <em>EnumItems</em><sup>?</sup> <code>}</code></p>
<p><em>EnumItems</em> :<br />
   <em>EnumItem</em> ( <code>,</code> <em>EnumItem</em> )<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>EnumItem</em> :<br />
   <em>OuterAttribute</em><sup>*</sup> <a href="items/../visibility-and-privacy.html"><em>Visibility</em></a><sup>?</sup><br />
   <a href="items/../identifiers.html">IDENTIFIER</a> ( <em>EnumItemTuple</em> | <em>EnumItemStruct</em>
| <em>EnumItemDiscriminant</em> )<sup>?</sup></p>
<p><em>EnumItemTuple</em> :<br />
   <code>(</code> <a href="items/structs.html"><em>TupleFields</em></a><sup>?</sup> <code>)</code></p>
<p><em>EnumItemStruct</em> :<br />
   <code>{</code> <a href="items/structs.html"><em>StructFields</em></a><sup>?</sup> <code>}</code></p>
<p><em>EnumItemDiscriminant</em> :<br />
   <code>=</code> <a href="items/../expressions.html"><em>Expression</em></a></p>
</blockquote>
<p>An <em>enumeration</em>, also referred to as <em>enum</em> is a simultaneous definition of a
nominal <a href="items/../types/enum.html">enumerated type</a> as well as a set of <em>constructors</em>, that can be used
to create or pattern-match values of the corresponding enumerated type.</p>
<p>Enumerations are declared with the keyword <code>enum</code>.</p>
<p>An example of an <code>enum</code> item and its use:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Animal {
    Dog,
    Cat,
}

let mut a: Animal = Animal::Dog;
a = Animal::Cat;
<span class="boring">}
</span></code></pre></pre>
<p>Enum constructors can have either named or unnamed fields:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Animal {
    Dog(String, f64),
    Cat { name: String, weight: f64 },
}

let mut a: Animal = Animal::Dog(&quot;Cocoa&quot;.to_string(), 37.2);
a = Animal::Cat { name: &quot;Spotty&quot;.to_string(), weight: 2.7 };
<span class="boring">}
</span></code></pre></pre>
<p>In this example, <code>Cat</code> is a <em>struct-like enum variant</em>, whereas <code>Dog</code> is simply
called an enum variant. Each enum instance has a <em>discriminant</em> which is an
integer associated to it that is used to determine which variant it holds. An
opaque reference to this discriminant can be obtained with the
<a href="items/../../std/mem/fn.discriminant.html"><code>mem::discriminant</code></a> function.</p>
<h2><a class="header" href="#custom-discriminant-values-for-fieldless-enumerations" id="custom-discriminant-values-for-fieldless-enumerations">Custom Discriminant Values for Fieldless Enumerations</a></h2>
<p>If there is no data attached to <em>any</em> of the variants of an enumeration,
then the discriminant can be directly chosen and accessed.</p>
<p>These enumerations can be cast to integer types with the <code>as</code> operator by a
<a href="items/../expressions/operator-expr.html#semantics">numeric cast</a>. The enumeration can optionally specify which integer each
discriminant gets by following the variant name with <code>=</code> followed by a <a href="items/../const_eval.html#constant-expressions">constant
expression</a>. If the first variant in the declaration is unspecified, then it is
set to zero. For every other unspecified discriminant, it is set to one higher
than the previous variant in the declaration.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Foo {
    Bar,            // 0
    Baz = 123,      // 123
    Quux,           // 124
}

let baz_discriminant = Foo::Baz as u32;
assert_eq!(baz_discriminant, 123);
<span class="boring">}
</span></code></pre></pre>
<p>Under the <a href="items/../type-layout.html#the-default-representation">default representation</a>, the specified discriminant is interpreted as
an <code>isize</code> value although the compiler is allowed to use a smaller type in the
actual memory layout. The size and thus acceptable values can be changed by
using a <a href="items/../type-layout.html#primitive-representations">primitive representation</a> or the <a href="items/../type-layout.html#the-c-representation"><code>C</code> representation</a>.</p>
<p>It is an error when two variants share the same discriminant.</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum SharedDiscriminantError {
    SharedA = 1,
    SharedB = 1
}

enum SharedDiscriminantError2 {
    Zero,       // 0
    One,        // 1
    OneToo = 1  // 1 (collision with previous!)
}
<span class="boring">}
</span></code></pre></pre>
<p>It is also an error to have an unspecified discriminant where the previous
discriminant is the maximum value for the size of the discriminant.</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[repr(u8)]
enum OverflowingDiscriminantError {
    Max = 255,
    MaxPlusOne // Would be 256, but that overflows the enum.
}

#[repr(u8)]
enum OverflowingDiscriminantError2 {
    MaxMinusOne = 254, // 254
    Max,               // 255
    MaxPlusOne         // Would be 256, but that overflows the enum.
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#zero-variant-enums" id="zero-variant-enums">Zero-variant Enums</a></h2>
<p>Enums with zero variants are known as <em>zero-variant enums</em>. As they have
no valid values, they cannot be instantiated.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum ZeroVariants {}
<span class="boring">}
</span></code></pre></pre>
<p>Zero-variant enums are equivalent to the <a href="items/../types/never.html">never type</a>, but they cannot be
coerced into other types.</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">enum ZeroVariants {}
</span>let x: ZeroVariants = panic!();
let y: u32 = x; // mismatched type error
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#variant-visibility" id="variant-visibility">Variant visibility</a></h2>
<p>Enum variants syntactically allow a <a href="items/../visibility-and-privacy.html"><em>Visibility</em></a> annotation, but this is
rejected when the enum is validated. This allows items to be parsed with a
unified syntax across different contexts where they are used.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>macro_rules! mac_variant {
    ($vis:vis $name:ident) =&gt; {
        enum $name {
            $vis Unit,

            $vis Tuple(u8, u16),

            $vis Struct { f: u8 },
        }
    }
}

// Empty `vis` is allowed.
mac_variant! { E }

// This is allowed, since it is removed before being validated.
#[cfg(FALSE)]
enum E {
    pub U,
    pub(crate) T(u8),
    pub(super) T { f: String }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#unions" id="unions">Unions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Union</em> :<br />
   <code>union</code> <a href="items/../identifiers.html">IDENTIFIER</a> <a href="items/generics.html"><em>Generics</em></a><sup>?</sup> <a href="items/generics.html#where-clauses"><em>WhereClause</em></a><sup>?</sup>
<code>{</code><a href="items/structs.html"><em>StructFields</em></a> <code>}</code></p>
</blockquote>
<p>A union declaration uses the same syntax as a struct declaration, except with
<code>union</code> in place of <code>struct</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
union MyUnion {
    f1: u32,
    f2: f32,
}
<span class="boring">}
</span></code></pre></pre>
<p>The key property of unions is that all fields of a union share common storage.
As a result writes to one field of a union can overwrite its other fields, and
size of a union is determined by the size of its largest field.</p>
<h2><a class="header" href="#initialization-of-a-union" id="initialization-of-a-union">Initialization of a union</a></h2>
<p>A value of a union type can be created using the same syntax that is used for
struct types, except that it must specify exactly one field:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span><span class="boring">
</span>let u = MyUnion { f1: 1 };
<span class="boring">}
</span></code></pre></pre>
<p>The expression above creates a value of type <code>MyUnion</code> and initializes the
storage using field <code>f1</code>. The union can be accessed using the same syntax as
struct fields:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span><span class="boring">
</span><span class="boring">let u = MyUnion { f1: 1 };
</span>let f = unsafe { u.f1 };
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#reading-and-writing-union-fields" id="reading-and-writing-union-fields">Reading and writing union fields</a></h2>
<p>Unions have no notion of an “active field”. Instead, every union access just
interprets the storage at the type of the field used for the access. Reading a
union field reads the bits of the union at the field’s type. Fields might have a
non-zero offset (except when <code>#[repr(C)]</code> is used); in that case the bits
starting at the offset of the fields are read. It is the programmer’s
responsibility to make sure that the data is valid at the field’s type. Failing
to do so results in undefined behavior. For example, reading the value <code>3</code> at
type <code>bool</code> is undefined behavior. Effectively, writing to and then reading from
a <code>#[repr(C)]</code> union is analogous to a <a href="items/../../std/mem/fn.transmute.html"><code>transmute</code></a> from the type used for
writing to the type used for reading.</p>
<p>Consequently, all reads of union fields have to be placed in <code>unsafe</code> blocks:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span><span class="boring">let u = MyUnion { f1: 1 };
</span><span class="boring">
</span>unsafe {
    let f = u.f1;
}
<span class="boring">}
</span></code></pre></pre>
<p>Writes to <code>Copy</code> union fields do not require reads for running destructors, so
these writes don’t have to be placed in <code>unsafe</code> blocks</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span><span class="boring">let mut u = MyUnion { f1: 1 };
</span><span class="boring">
</span>u.f1 = 2;
<span class="boring">}
</span></code></pre></pre>
<p>Commonly, code using unions will provide safe wrappers around unsafe union
field accesses.</p>
<h2><a class="header" href="#pattern-matching-on-unions" id="pattern-matching-on-unions">Pattern matching on unions</a></h2>
<p>Another way to access union fields is to use pattern matching. Pattern matching
on union fields uses the same syntax as struct patterns, except that the pattern
must specify exactly one field. Since pattern matching is like reading the union
with a particular field, it has to be placed in <code>unsafe</code> blocks as well.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span><span class="boring">
</span>fn f(u: MyUnion) {
    unsafe {
        match u {
            MyUnion { f1: 10 } =&gt; { println!(&quot;ten&quot;); }
            MyUnion { f2 } =&gt; { println!(&quot;{}&quot;, f2); }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Pattern matching may match a union as a field of a larger structure. In
particular, when using a Rust union to implement a C tagged union via FFI, this
allows matching on the tag and the corresponding field simultaneously:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[repr(u32)]
enum Tag { I, F }

#[repr(C)]
union U {
    i: i32,
    f: f32,
}

#[repr(C)]
struct Value {
    tag: Tag,
    u: U,
}

fn is_zero(v: Value) -&gt; bool {
    unsafe {
        match v {
            Value { tag: Tag::I, u: U { i: 0 } } =&gt; true,
            Value { tag: Tag::F, u: U { f: num } } if num == 0.0 =&gt; true,
            _ =&gt; false,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#references-to-union-fields" id="references-to-union-fields">References to union fields</a></h2>
<p>Since union fields share common storage, gaining write access to one field of a
union can give write access to all its remaining fields. Borrow checking rules
have to be adjusted to account for this fact. As a result, if one field of a
union is borrowed, all its remaining fields are borrowed as well for the same
lifetime.</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion { f1: u32, f2: f32 }
</span>// ERROR: cannot borrow `u` (via `u.f2`) as mutable more than once at a time
fn test() {
    let mut u = MyUnion { f1: 1 };
    unsafe {
        let b1 = &amp;mut u.f1;
//                    ---- first mutable borrow occurs here (via `u.f1`)
        let b2 = &amp;mut u.f2;
//                    ^^^^ second mutable borrow occurs here (via `u.f2`)
        *b1 = 5;
    }
//  - first borrow ends here
    assert_eq!(unsafe { u.f1 }, 5);
}
<span class="boring">}
</span></code></pre></pre>
<p>As you could see, in many aspects (except for layouts, safety, and ownership)
unions behave exactly like structs, largely as a consequence of inheriting
their syntactic shape from structs. This is also true for many unmentioned
aspects of Rust language (such as privacy, name resolution, type inference,
generics, trait implementations, inherent implementations, coherence, pattern
checking, etc etc etc).</p>
<h1><a class="header" href="#constant-items" id="constant-items">Constant items</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ConstantItem</em> :<br />
   <code>const</code> ( <a href="items/../identifiers.html">IDENTIFIER</a> | <code>_</code> ) <code>:</code> <a href="items/../types.html#type-expressions"><em>Type</em></a> <code>=</code> <a href="items/../expressions.html"><em>Expression</em></a> <code>;</code></p>
</blockquote>
<p>A <em>constant item</em> is an optionally named <em><a href="items/../const_eval.html#constant-expressions">constant value</a></em> which is not associated
with a specific memory location in the program. Constants are essentially inlined
wherever they are used, meaning that they are copied directly into the relevant
context when used. References to the same constant are not necessarily
guaranteed to refer to the same memory address.</p>
<p>Constants must be explicitly typed. The type must have a <code>'static</code> lifetime: any
references it contains must have <code>'static</code> lifetimes.</p>
<p>Constants may refer to the address of other constants, in which case the
address will have elided lifetimes where applicable, otherwise – in most cases
– defaulting to the <code>static</code> lifetime. (See <a href="items/../lifetime-elision.html#static-lifetime-elision">static lifetime
elision</a>.) The compiler is, however, still at liberty to translate the constant
many times, so the address referred to may not be stable.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>const BIT1: u32 = 1 &lt;&lt; 0;
const BIT2: u32 = 1 &lt;&lt; 1;

const BITS: [u32; 2] = [BIT1, BIT2];
const STRING: &amp;'static str = &quot;bitstring&quot;;

struct BitsNStrings&lt;'a&gt; {
    mybits: [u32; 2],
    mystring: &amp;'a str,
}

const BITS_N_STRINGS: BitsNStrings&lt;'static&gt; = BitsNStrings {
    mybits: BITS,
    mystring: STRING,
};
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#constants-with-destructors" id="constants-with-destructors">Constants with Destructors</a></h2>
<p>Constants can contain destructors. Destructors are run when the value goes out
of scope.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct TypeWithDestructor(i32);

impl Drop for TypeWithDestructor {
    fn drop(&amp;mut self) {
        println!(&quot;Dropped. Held {}.&quot;, self.0);
    }
}

const ZERO_WITH_DESTRUCTOR: TypeWithDestructor = TypeWithDestructor(0);

fn create_and_drop_zero_with_destructor() {
    let x = ZERO_WITH_DESTRUCTOR;
    // x gets dropped at end of function, calling drop.
    // prints &quot;Dropped. Held 0.&quot;.
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#unnamed-constant" id="unnamed-constant">Unnamed constant</a></h2>
<p>Unlike an <a href="items/../glossary.html#associated-item">associated</a> constant, a <a href="items/../glossary.html#free-item">free</a> constant may be unnamed by using
an underscore instead of the name. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>const _: () =  { struct _SameNameTwice; };

// OK although it is the same name as above:
const _: () =  { struct _SameNameTwice; };
<span class="boring">}
</span></code></pre></pre>
<p>As with <a href="items/use-declarations.html#underscore-imports">underscore imports</a>, macros may safely emit the same unnamed constant in
the same scope more than once. For example, the following should not produce an error:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    ($item: item) =&gt; { $item $item }
}

m!(const _: () = (););
// This expands to:
// const _: () = ();
// const _: () = ();
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#static-items" id="static-items">Static items</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>StaticItem</em> :<br />
   <code>static</code> <code>mut</code><sup>?</sup> <a href="items/../identifiers.html">IDENTIFIER</a> <code>:</code> <a href="items/../types.html#type-expressions"><em>Type</em></a>
<code>=</code> <a href="items/../expressions.html"><em>Expression</em></a> <code>;</code></p>
</blockquote>
<p>A <em>static item</em> is similar to a <a href="items/constant-items.html">constant</a>, except that it represents a precise
memory location in the program. All references to the static refer to the same
memory location. Static items have the <code>static</code> lifetime, which outlives all
other lifetimes in a Rust program. Non-<code>mut</code> static items that contain a type
that is not <a href="items/../interior-mutability.html">interior mutable</a> may be placed in read-only memory. Static items
do not call <a href="items/../destructors.html"><code>drop</code></a> at the end of the program.</p>
<p>All access to a static is safe, but there are a number of restrictions on
statics:</p>
<ul>
<li>The type must have the <code>Sync</code> trait bound to allow thread-safe access.</li>
<li>Statics allow using paths to statics in the <a href="items/../const_eval.html#constant-expressions">constant expression</a> used to
initialize them, but statics may not refer to other statics by value, only
through a reference.</li>
<li>Constants cannot refer to statics.</li>
</ul>
<h2><a class="header" href="#mutable-statics" id="mutable-statics">Mutable statics</a></h2>
<p>If a static item is declared with the <code>mut</code> keyword, then it is allowed to be
modified by the program. One of Rust’s goals is to make concurrency bugs hard
to run into, and this is obviously a very large source of race conditions or
other bugs. For this reason, an <code>unsafe</code> block is required when either reading
or writing a mutable static variable. Care should be taken to ensure that
modifications to a mutable static are safe with respect to other threads
running in the same process.</p>
<p>Mutable statics are still very useful, however. They can be used with C
libraries and can also be bound from C libraries in an <code>extern</code> block.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">fn atomic_add(_: &amp;mut u32, _: u32) -&gt; u32 { 2 }
</span>
static mut LEVELS: u32 = 0;

// This violates the idea of no shared state, and this doesn't internally
// protect against races, so this function is `unsafe`
unsafe fn bump_levels_unsafe1() -&gt; u32 {
    let ret = LEVELS;
    LEVELS += 1;
    return ret;
}

// Assuming that we have an atomic_add function which returns the old value,
// this function is &quot;safe&quot; but the meaning of the return value may not be what
// callers expect, so it's still marked as `unsafe`
unsafe fn bump_levels_unsafe2() -&gt; u32 {
    return atomic_add(&amp;mut LEVELS, 1);
}
<span class="boring">}
</span></code></pre></pre>
<p>Mutable statics have the same restrictions as normal statics, except that the
type does not have to implement the <code>Sync</code> trait.</p>
<h2><a class="header" href="#using-statics-or-consts" id="using-statics-or-consts">Using Statics or Consts</a></h2>
<p>It can be confusing whether or not you should use a constant item or a static
item. Constants should, in general, be preferred over statics unless one of the
following are true:</p>
<ul>
<li>Large amounts of data are being stored</li>
<li>The single-address property of statics is required.</li>
<li>Interior mutability is required.</li>
</ul>
<h1><a class="header" href="#traits" id="traits">Traits</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Trait</em> :<br />
   <code>unsafe</code><sup>?</sup> <code>trait</code> <a href="items/../identifiers.html">IDENTIFIER</a> 
<a href="items/generics.html"><em>Generics</em></a><sup>?</sup>
( <code>:</code> <a href="items/../trait-bounds.html"><em>TypeParamBounds</em></a><sup>?</sup> )<sup>?</sup>
<a href="items/generics.html#where-clauses"><em>WhereClause</em></a><sup>?</sup> <code>{</code><br />
     <em>TraitItem</em><sup>*</sup><br />
   <code>}</code></p>
<p><em>TraitItem</em> :<br />
   <a href="items/../attributes.html"><em>OuterAttribute</em></a><sup>*</sup> <a href="items/../visibility-and-privacy.html"><em>Visibility</em></a><sup>?</sup> (<br />
         <em>TraitFunc</em><br />
      | <em>TraitMethod</em><br />
      | <em>TraitConst</em><br />
      | <em>TraitType</em><br />
      | <a href="items/../macros.html#macro-invocation"><em>MacroInvocationSemi</em></a><br />
   )</p>
<p><em>TraitFunc</em> :<br />
      <em>TraitFunctionDecl</em> ( <code>;</code> | <a href="items/../expressions/block-expr.html"><em>BlockExpression</em></a> )</p>
<p><em>TraitMethod</em> :<br />
      <em>TraitMethodDecl</em> ( <code>;</code> | <a href="items/../expressions/block-expr.html"><em>BlockExpression</em></a> )</p>
<p><em>TraitFunctionDecl</em> :<br />
   <a href="items/functions.html"><em>FunctionQualifiers</em></a> <code>fn</code> <a href="items/../identifiers.html">IDENTIFIER</a> <a href="items/generics.html"><em>Generics</em></a><sup>?</sup><br />
      <code>(</code> <em>TraitFunctionParameters</em><sup>?</sup> <code>)</code><br />
      <a href="items/functions.html"><em>FunctionReturnType</em></a><sup>?</sup> <a href="items/generics.html#where-clauses"><em>WhereClause</em></a><sup>?</sup></p>
<p><em>TraitMethodDecl</em> :<br />
   <a href="items/functions.html"><em>FunctionQualifiers</em></a> <code>fn</code> <a href="items/../identifiers.html">IDENTIFIER</a> <a href="items/generics.html"><em>Generics</em></a><sup>?</sup><br />
      <code>(</code> <a href="items/associated-items.html#methods"><em>SelfParam</em></a> (<code>,</code> <em>TraitFunctionParam</em>)<sup>*</sup> <code>,</code><sup>?</sup> <code>)</code><br />
      <a href="items/functions.html"><em>FunctionReturnType</em></a><sup>?</sup> <a href="items/generics.html#where-clauses"><em>WhereClause</em></a><sup>?</sup></p>
<p><em>TraitFunctionParameters</em> :<br />
   <em>TraitFunctionParam</em> (<code>,</code> <em>TraitFunctionParam</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>TraitFunctionParam</em><sup><a href="items/traits.html#parameter-patterns">†</a></sup> :<br />
   <a href="items/../attributes.html"><em>OuterAttribute</em></a><sup>*</sup> ( <a href="items/../patterns.html"><em>Pattern</em></a> <code>:</code> )<sup>?</sup> <a href="items/../types.html#type-expressions"><em>Type</em></a></p>
<p><em>TraitConst</em> :<br />
   <code>const</code> <a href="items/../identifiers.html">IDENTIFIER</a> <code>:</code> <a href="items/../types.html#type-expressions"><em>Type</em></a> ( <code>=</code> <a href="items/../expressions.html"><em>Expression</em></a> )<sup>?</sup> <code>;</code></p>
<p><em>TraitType</em> :<br />
   <code>type</code> <a href="items/../identifiers.html">IDENTIFIER</a> ( <code>:</code> <a href="items/../trait-bounds.html"><em>TypeParamBounds</em></a><sup>?</sup> )<sup>?</sup> <code>;</code></p>
</blockquote>
<p>A <em>trait</em> describes an abstract interface that types can implement. This
interface consists of <a href="items/associated-items.html">associated items</a>, which come in three varieties:</p>
<ul>
<li><a href="items/associated-items.html#associated-functions-and-methods">functions</a></li>
<li><a href="items/associated-items.html#associated-types">types</a></li>
<li><a href="items/associated-items.html#associated-constants">constants</a></li>
</ul>
<p>All traits define an implicit type parameter <code>Self</code> that refers to “the type
that is implementing this interface”. Traits may also contain additional type
parameters. These type parameters, including <code>Self</code>, may be constrained by
other traits and so forth <a href="items/generics.html">as usual</a>.</p>
<p>Traits are implemented for specific types through separate <a href="items/implementations.html">implementations</a>.</p>
<p>Items associated with a trait do not need to be defined in the trait, but they
may be. If the trait provides a definition, then this definition acts as a
default for any implementation which does not override it. If it does not, then
any implementation must provide a definition.</p>
<h2><a class="header" href="#trait-bounds" id="trait-bounds">Trait bounds</a></h2>
<p>Generic items may use traits as <a href="items/../trait-bounds.html">bounds</a> on their type parameters.</p>
<h2><a class="header" href="#generic-traits" id="generic-traits">Generic Traits</a></h2>
<p>Type parameters can be specified for a trait to make it generic. These appear
after the trait name, using the same syntax used in <a href="items/functions.html#generic-functions">generic functions</a>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Seq&lt;T&gt; {
    fn len(&amp;self) -&gt; u32;
    fn elt_at(&amp;self, n: u32) -&gt; T;
    fn iter&lt;F&gt;(&amp;self, f: F) where F: Fn(T);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#object-safety" id="object-safety">Object Safety</a></h2>
<p>Object safe traits can be the base trait of a <a href="items/../types/trait-object.html">trait object</a>. A trait is
<em>object safe</em> if it has the following qualities (defined in <a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">RFC 255</a>):</p>
<ul>
<li>It must not require <code>Self: Sized</code></li>
<li>All associated functions must either have a <code>where Self: Sized</code> bound, or
<ul>
<li>Not have any type parameters (although lifetime parameters are allowed),
and</li>
<li>Be a <a href="items/associated-items.html#methods">method</a> that does not use <code>Self</code> except in the type of the receiver.</li>
</ul>
</li>
<li>It must not have any associated constants.</li>
<li>All supertraits must also be object safe.</li>
</ul>
<p>When there isn’t a <code>Self: Sized</code> bound on a method, the type of a method
receiver must be one of the following types:</p>
<ul>
<li><code>&amp;Self</code></li>
<li><code>&amp;mut Self</code></li>
<li><a href="items/../special-types-and-traits.html#boxt"><code>Box&lt;Self&gt;</code></a></li>
<li><a href="items/../special-types-and-traits.html#rct"><code>Rc&lt;Self&gt;</code></a></li>
<li><a href="items/../special-types-and-traits.html#arct"><code>Arc&lt;Self&gt;</code></a></li>
<li><a href="items/../special-types-and-traits.html#pinp"><code>Pin&lt;P&gt;</code></a> where <code>P</code> is one of the types above</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::pin::Pin;
</span>// Examples of object safe methods.
trait TraitMethods {
    fn by_ref(self: &amp;Self) {}
    fn by_ref_mut(self: &amp;mut Self) {}
    fn by_box(self: Box&lt;Self&gt;) {}
    fn by_rc(self: Rc&lt;Self&gt;) {}
    fn by_arc(self: Arc&lt;Self&gt;) {}
    fn by_pin(self: Pin&lt;&amp;Self&gt;) {}
    fn with_lifetime&lt;'a&gt;(self: &amp;'a Self) {}
    fn nested_pin(self: Pin&lt;Arc&lt;Self&gt;&gt;) {}
}
<span class="boring">struct S;
</span><span class="boring">impl TraitMethods for S {}
</span><span class="boring">let t: Box&lt;dyn TraitMethods&gt; = Box::new(S);
</span><span class="boring">}
</span></code></pre></pre>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// This trait is object-safe, but these methods cannot be dispatched on a trait object.
trait NonDispatchable {
    // Non-methods cannot be dispatched.
    fn foo() where Self: Sized {}
    // Self type isn't known until runtime.
    fn returns(&amp;self) -&gt; Self where Self: Sized;
    // `other` may be a different concrete type of the receiver.
    fn param(&amp;self, other: Self) where Self: Sized {}
    // Generics are not compatible with vtables.
    fn typed&lt;T&gt;(&amp;self, x: T) where Self: Sized {}
}

struct S;
impl NonDispatchable for S {
    fn returns(&amp;self) -&gt; Self where Self: Sized { S }
}
let obj: Box&lt;dyn NonDispatchable&gt; = Box::new(S);
obj.returns(); // ERROR: cannot call with Self return
obj.param(S);  // ERROR: cannot call with Self parameter
obj.typed(1);  // ERROR: cannot call with generic type
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::rc::Rc;
</span>// Examples of non-object safe traits.
trait NotObjectSafe {
    const CONST: i32 = 1;  // ERROR: cannot have associated const

    fn foo() {}  // ERROR: associated function without Sized
    fn returns(&amp;self) -&gt; Self; // ERROR: Self in return type
    fn typed&lt;T&gt;(&amp;self, x: T) {} // ERROR: has generic type parameters
    fn nested(self: Rc&lt;Box&lt;Self&gt;&gt;) {} // ERROR: nested receiver not yet supported
}

struct S;
impl NotObjectSafe for S {
    fn returns(&amp;self) -&gt; Self { S }
}
let obj: Box&lt;dyn NotObjectSafe&gt; = Box::new(S); // ERROR
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Self: Sized traits are not object-safe.
trait TraitWithSize where Self: Sized {}

struct S;
impl TraitWithSize for S {}
let obj: Box&lt;dyn TraitWithSize&gt; = Box::new(S); // ERROR
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Not object safe if `Self` is a type argument.
trait Super&lt;A&gt; {}
trait WithSelf: Super&lt;Self&gt; where Self: Sized {}

struct S;
impl&lt;A&gt; Super&lt;A&gt; for S {}
impl WithSelf for S {}
let obj: Box&lt;dyn WithSelf&gt; = Box::new(S); // ERROR: cannot use `Self` type parameter
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#supertraits" id="supertraits">Supertraits</a></h2>
<p><strong>Supertraits</strong> are traits that are required to be implemented for a type to
implement a specific trait. Furthermore, anywhere a <a href="items/generics.html">generic</a> or <a href="items/../types/trait-object.html">trait object</a>
is bounded by a trait, it has access to the associated items of its supertraits.</p>
<p>Supertraits are declared by trait bounds on the <code>Self</code> type of a trait and
transitively the supertraits of the traits declared in those trait bounds. It is
an error for a trait to be its own supertrait.</p>
<p>The trait with a supertrait is called a <strong>subtrait</strong> of its supertrait.</p>
<p>The following is an example of declaring <code>Shape</code> to be a supertrait of <code>Circle</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Shape { fn area(&amp;self) -&gt; f64; }
trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
<span class="boring">}
</span></code></pre></pre>
<p>And the following is the same example, except using <a href="items/generics.html#where-clauses">where clauses</a>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Shape { fn area(&amp;self) -&gt; f64; }
trait Circle where Self: Shape { fn radius(&amp;self) -&gt; f64; }
<span class="boring">}
</span></code></pre></pre>
<p>This next example gives <code>radius</code> a default implementation using the <code>area</code>
function from <code>Shape</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Shape { fn area(&amp;self) -&gt; f64; }
</span>trait Circle where Self: Shape {
    fn radius(&amp;self) -&gt; f64 {
        // A = pi * r^2
        // so algebraically,
        // r = sqrt(A / pi)
        (self.area() /std::f64::consts::PI).sqrt()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This next example calls a supertrait method on a generic parameter.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Shape { fn area(&amp;self) -&gt; f64; }
</span><span class="boring">trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
</span>fn print_area_and_radius&lt;C: Circle&gt;(c: C) {
    // Here we call the area method from the supertrait `Shape` of `Circle`.
    println!(&quot;Area: {}&quot;, c.area());
    println!(&quot;Radius: {}&quot;, c.radius());
}
<span class="boring">}
</span></code></pre></pre>
<p>Similarly, here is an example of calling supertrait methods on trait objects.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Shape { fn area(&amp;self) -&gt; f64; }
</span><span class="boring">trait Circle : Shape { fn radius(&amp;self) -&gt; f64; }
</span><span class="boring">struct UnitCircle;
</span><span class="boring">impl Shape for UnitCircle { fn area(&amp;self) -&gt; f64 { std::f64::consts::PI } }
</span><span class="boring">impl Circle for UnitCircle { fn radius(&amp;self) -&gt; f64 { 1.0 } }
</span><span class="boring">let circle = UnitCircle;
</span>let circle = Box::new(circle) as Box&lt;dyn Circle&gt;;
let nonsense = circle.radius() * circle.area();
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#unsafe-traits" id="unsafe-traits">Unsafe traits</a></h2>
<p>Traits items that begin with the <code>unsafe</code> keyword indicate that <em>implementing</em> the
trait may be <a href="items/../unsafety.html">unsafe</a>. It is safe to use a correctly implemented unsafe trait.
The <a href="items/implementations.html#trait-implementations">trait implementation</a> must also begin with the <code>unsafe</code> keyword.</p>
<p><a href="items/../special-types-and-traits.html#sync"><code>Sync</code></a> and <a href="items/../special-types-and-traits.html#send"><code>Send</code></a> are examples of unsafe traits.</p>
<h2><a class="header" href="#parameter-patterns" id="parameter-patterns">Parameter patterns</a></h2>
<p>Function or method declarations without a body only allow <a href="items/../identifiers.html">IDENTIFIER</a> or
<code>_</code> <a href="items/../patterns.html#wildcard-pattern">wild card</a> patterns. <code>mut</code> <a href="items/../identifiers.html">IDENTIFIER</a> is currently
allowed, but it is deprecated and will become a hard error in the future.</p>
<!-- https://github.com/rust-lang/rust/issues/35203 -->
<p>In the 2015 edition, the pattern for a trait function or method parameter is
optional:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait T {
    fn f(i32);  // Parameter identifiers are not required.
}
<span class="boring">}
</span></code></pre></pre>
<p>The kinds of patterns for parameters is limited to one of the following:</p>
<ul>
<li><a href="items/../identifiers.html">IDENTIFIER</a></li>
<li><code>mut</code> <a href="items/../identifiers.html">IDENTIFIER</a></li>
<li><a href="items/../patterns.html#wildcard-pattern"><code>_</code></a></li>
<li><code>&amp;</code> <a href="items/../identifiers.html">IDENTIFIER</a></li>
<li><code>&amp;&amp;</code> <a href="items/../identifiers.html">IDENTIFIER</a></li>
</ul>
<p>Beginning in the 2018 edition, function or method parameter patterns are no
longer optional. Also, all irrefutable patterns are allowed as long as there
is a body. Without a body, the limitations listed above are still in effect.</p>
<pre><pre class="playpen"><code class="language-rust edition2018">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait T {
    fn f1((a, b): (i32, i32)) {}
    fn f2(_: (i32, i32));  // Cannot use tuple pattern without a body.
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#item-visibility" id="item-visibility">Item visibility</a></h2>
<p>Trait items syntactically allow a <a href="items/../visibility-and-privacy.html"><em>Visibility</em></a> annotation, but this is
rejected when the trait is validated. This allows items to be parsed with a
unified syntax across different contexts where they are used. As an example,
an empty <code>vis</code> macro fragment specifier can be used for trait items, where the
macro rule may be used in other situations where visibility is allowed.</p>
<pre><pre class="playpen"><code class="language-rust">macro_rules! create_method {
    ($vis:vis $name:ident) =&gt; {
        $vis fn $name(&amp;self) {}
    };
}

trait T1 {
    // Empty `vis` is allowed.
    create_method! { method_of_t1 }
}

struct S;

impl S {
    // Visibility is allowed here.
    create_method! { pub method_of_s }
}

impl T1 for S {}

fn main() {
    let s = S;
    s.method_of_t1();
    s.method_of_s();
}
</code></pre></pre>
<h1><a class="header" href="#implementations" id="implementations">Implementations</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Implementation</em> :<br />
   <em>InherentImpl</em> | <em>TraitImpl</em></p>
<p><em>InherentImpl</em> :<br />
   <code>impl</code> <a href="items/generics.html"><em>Generics</em></a><sup>?</sup> <a href="items/../types.html#type-expressions"><em>Type</em></a> <a href="items/generics.html#where-clauses"><em>WhereClause</em></a><sup>?</sup> <code>{</code><br />
      <a href="items/../attributes.html"><em>InnerAttribute</em></a><sup>*</sup><br />
      <em>InherentImplItem</em><sup>*</sup><br />
   <code>}</code></p>
<p><em>InherentImplItem</em> :<br />
   <a href="items/../attributes.html"><em>OuterAttribute</em></a><sup>*</sup> (<br />
         <a href="items/../macros.html#macro-invocation"><em>MacroInvocationSemi</em></a><br />
      | ( <a href="items/../visibility-and-privacy.html"><em>Visibility</em></a><sup>?</sup> ( <a href="items/constant-items.html"><em>ConstantItem</em></a> | <a href="items/functions.html"><em>Function</em></a> | <a href="items/associated-items.html#methods"><em>Method</em></a> ) )<br />
   )</p>
<p><em>TraitImpl</em> :<br />
   <code>unsafe</code><sup>?</sup> <code>impl</code> <a href="items/generics.html"><em>Generics</em></a><sup>?</sup> <code>!</code><sup>?</sup>
<a href="items/../paths.html#paths-in-types"><em>TypePath</em></a> <code>for</code> <a href="items/../types.html#type-expressions"><em>Type</em></a><br />
   <a href="items/generics.html#where-clauses"><em>WhereClause</em></a><sup>?</sup><br />
   <code>{</code><br />
      <a href="items/../attributes.html"><em>InnerAttribute</em></a><sup>*</sup><br />
      <em>TraitImplItem</em><sup>*</sup><br />
   <code>}</code></p>
<p><em>TraitImplItem</em> :<br />
   <a href="items/../attributes.html"><em>OuterAttribute</em></a><sup>*</sup> (<br />
         <a href="items/../macros.html#macro-invocation"><em>MacroInvocationSemi</em></a><br />
      | ( <a href="items/../visibility-and-privacy.html"><em>Visibility</em></a><sup>?</sup> ( <a href="items/type-aliases.html"><em>TypeAlias</em></a> | <a href="items/constant-items.html"><em>ConstantItem</em></a> | <a href="items/functions.html"><em>Function</em></a> | <a href="items/associated-items.html#methods"><em>Method</em></a> ) )<br />
   )</p>
</blockquote>
<p>An <em>implementation</em> is an item that associates items with an <em>implementing type</em>.
Implementations are defined with the keyword <code>impl</code> and contain functions
that belong to an instance of the type that is being implemented or to the
type statically.</p>
<p>There are two types of implementations:</p>
<ul>
<li>inherent implementations</li>
<li><a href="items/traits.html">trait</a> implementations</li>
</ul>
<h2><a class="header" href="#inherent-implementations" id="inherent-implementations">Inherent Implementations</a></h2>
<p>An inherent implementation is defined as the sequence of the <code>impl</code> keyword,
generic type declarations, a path to a nominal type, a where clause, and a
bracketed set of associable items.</p>
<p>The nominal type is called the <em>implementing type</em> and the associable items are
the <em>associated items</em> to the implementing type.</p>
<p>Inherent implementations associate the contained items to the
implementing type.  Inherent implementations can contain <a href="items/associated-items.html#associated-functions-and-methods">associated
functions</a> (including methods) and <a href="items/associated-items.html#associated-constants">associated constants</a>. They cannot
contain associated type aliases.</p>
<p>The <a href="items/../paths.html">path</a> to an associated item is any path to the implementing type,
followed by the associated item’s identifier as the final path
component.</p>
<p>A type can also have multiple inherent implementations. An implementing type
must be defined within the same crate as the original type definition.</p>
<pre><pre class="playpen"><code class="language-rust">pub mod color {
    pub struct Color(pub u8, pub u8, pub u8);

    impl Color {
        pub const WHITE: Color = Color(255, 255, 255);
    }
}

mod values {
    use super::color::Color;
    impl Color {
        pub fn red() -&gt; Color {
            Color(255, 0, 0)
        }
    }
}

pub use self::color::Color;
fn main() {
    // Actual path to the implementing type and impl in the same module.
    color::Color::WHITE;

    // Impl blocks in different modules are still accessed through a path to the type.
    color::Color::red();

    // Re-exported paths to the implementing type also work.
    Color::red();

    // Does not work, because use in `values` is not pub.
    // values::Color::red();
}
</code></pre></pre>
<h2><a class="header" href="#trait-implementations" id="trait-implementations">Trait Implementations</a></h2>
<p>A <em>trait implementation</em> is defined like an inherent implementation except that
the optional generic type declarations is followed by a <a href="items/traits.html">trait</a> followed
by the keyword <code>for</code>. Followed by a path to a nominal type.</p>
<!-- To understand this, you have to back-reference to the previous section. :( -->
<p>The trait is known as the <em>implemented trait</em>. The implementing type
implements the implemented trait.</p>
<p>A trait implementation must define all non-default associated items declared
by the implemented trait, may redefine default associated items defined by the
implemented trait, and cannot define any other items.</p>
<p>The path to the associated items is <code>&lt;</code> followed by a path to the implementing
type followed by <code>as</code> followed by a path to the trait followed by <code>&gt;</code> as a path
component followed by the associated item’s path component.</p>
<p><a href="items/traits.html#unsafe-traits">Unsafe traits</a> require the trait implementation to begin with the <code>unsafe</code>
keyword.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Copy, Clone)]
</span><span class="boring">struct Point {x: f64, y: f64};
</span><span class="boring">type Surface = i32;
</span><span class="boring">struct BoundingBox {x: f64, y: f64, width: f64, height: f64};
</span><span class="boring">trait Shape { fn draw(&amp;self, Surface); fn bounding_box(&amp;self) -&gt; BoundingBox; }
</span><span class="boring">fn do_draw_circle(s: Surface, c: Circle) { }
</span>struct Circle {
    radius: f64,
    center: Point,
}

impl Copy for Circle {}

impl Clone for Circle {
    fn clone(&amp;self) -&gt; Circle { *self }
}

impl Shape for Circle {
    fn draw(&amp;self, s: Surface) { do_draw_circle(s, *self); }
    fn bounding_box(&amp;self) -&gt; BoundingBox {
        let r = self.radius;
        BoundingBox {
            x: self.center.x - r,
            y: self.center.y - r,
            width: 2.0 * r,
            height: 2.0 * r,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#trait-implementation-coherence" id="trait-implementation-coherence">Trait Implementation Coherence</a></h3>
<p>A trait implementation is considered incoherent if either the orphan rules check fails
or there are overlapping implementation instances.</p>
<p>Two trait implementations overlap when there is a non-empty intersection of the
traits the implementation is for, the implementations can be instantiated with
the same type. <!-- This is probably wrong? Source: No two implementations can
be instantiable with the same set of types for the input type parameters. --></p>
<h4><a class="header" href="#orphan-rules" id="orphan-rules">Orphan rules</a></h4>
<p>Given <code>impl&lt;P1..=Pn&gt; Trait&lt;T1..=Tn&gt; for T0</code>, an <code>impl</code> is valid only if at
least one of the following is true:</p>
<ul>
<li><code>Trait</code> is a <a href="items/../glossary.html#local-trait">local trait</a></li>
<li>All of
<ul>
<li>At least one of the types <code>T0..=Tn</code> must be a <a href="items/../glossary.html#local-type">local type</a>. Let <code>Ti</code> be the
first such type.</li>
<li>No <a href="items/../glossary.html#uncovered-type">uncovered type</a> parameters <code>P1..=Pn</code> may appear in <code>T0..Ti</code> (excluding
<code>Ti</code>)</li>
</ul>
</li>
</ul>
<p>Only the appearance of <em>uncovered</em> type parameters is restricted.
Note that for the purposes of coherence, <a href="items/../glossary.html#fundamental-type-constructors">fundamental types</a> are
special. The <code>T</code> in <code>Box&lt;T&gt;</code> is not considered covered, and <code>Box&lt;LocalType&gt;</code> 
is considered local.</p>
<h2><a class="header" href="#generic-implementations" id="generic-implementations">Generic Implementations</a></h2>
<p>An implementation can take type and lifetime parameters, which can be used in
the rest of the implementation. Type parameters declared for an implementation
must be used at least once in either the trait or the implementing type of an
implementation. Implementation parameters are written directly after the <code>impl</code>
keyword.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Seq&lt;T&gt; { fn dummy(&amp;self, _: T) { } }
</span>impl&lt;T&gt; Seq&lt;T&gt; for Vec&lt;T&gt; {
    /* ... */
}
impl Seq&lt;bool&gt; for u32 {
    /* Treat the integer as a sequence of bits */
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#attributes-on-implementations" id="attributes-on-implementations">Attributes on Implementations</a></h2>
<p>Implementations may contain outer <a href="items/../attributes.html">attributes</a> before the <code>impl</code> keyword and
inner <a href="items/../attributes.html">attributes</a> inside the brackets that contain the associated items. Inner
attributes must come before any associated items. That attributes that have
meaning here are <a href="items/../conditional-compilation.html"><code>cfg</code></a>, <a href="items/../attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a>, <a href="items/../../rustdoc/the-doc-attribute.html"><code>doc</code></a>, and <a href="items/../attributes/diagnostics.html#lint-check-attributes">the lint check
attributes</a>.</p>
<h1><a class="header" href="#external-blocks" id="external-blocks">External blocks</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ExternBlock</em> :<br />
   <code>extern</code> <a href="items/functions.html"><em>Abi</em></a><sup>?</sup> <code>{</code><br />
      <a href="items/../attributes.html"><em>InnerAttribute</em></a><sup>*</sup><br />
      <em>ExternalItem</em><sup>*</sup><br />
   <code>}</code></p>
<p><em>ExternalItem</em> :<br />
   <a href="items/../attributes.html"><em>OuterAttribute</em></a><sup>*</sup> (<br />
         <a href="items/../macros.html#macro-invocation"><em>MacroInvocationSemi</em></a><br />
      | ( <a href="items/../visibility-and-privacy.html"><em>Visibility</em></a><sup>?</sup> ( <em>ExternalStaticItem</em> | <em>ExternalFunctionItem</em> ) )<br />
   )</p>
<p><em>ExternalStaticItem</em> :<br />
   <code>static</code> <code>mut</code><sup>?</sup> <a href="items/../identifiers.html">IDENTIFIER</a> <code>:</code> <a href="items/../types.html#type-expressions"><em>Type</em></a> <code>;</code></p>
<p><em>ExternalFunctionItem</em> :<br />
   <code>fn</code> <a href="items/../identifiers.html">IDENTIFIER</a> <a href="items/generics.html"><em>Generics</em></a><sup>?</sup><br />
   <code>(</code> ( <em>NamedFunctionParameters</em> | <em>NamedFunctionParametersWithVariadics</em> )<sup>?</sup> <code>)</code><br />
   <a href="items/functions.html"><em>FunctionReturnType</em></a><sup>?</sup> <a href="items/generics.html#where-clauses"><em>WhereClause</em></a><sup>?</sup> <code>;</code></p>
<p><em>NamedFunctionParameters</em> :<br />
   <em>NamedFunctionParam</em> ( <code>,</code> <em>NamedFunctionParam</em> )<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>NamedFunctionParam</em> :<br />
   <a href="items/../attributes.html"><em>OuterAttribute</em></a><sup>*</sup> ( <a href="items/../identifiers.html">IDENTIFIER</a> | <code>_</code> ) <code>:</code> <a href="items/../types.html#type-expressions"><em>Type</em></a></p>
<p><em>NamedFunctionParametersWithVariadics</em> :<br />
   ( <em>NamedFunctionParam</em> <code>,</code> )<sup>*</sup> <em>NamedFunctionParam</em> <code>,</code> <a href="items/../attributes.html"><em>OuterAttribute</em></a><sup>*</sup> <code>...</code></p>
</blockquote>
<p>External blocks provide <em>declarations</em> of items that are not <em>defined</em> in the
current crate and are the basis of Rust’s foreign function interface. These are
akin to unchecked imports.</p>
<p>Two kind of item <em>declarations</em> are allowed in external blocks: <a href="items/functions.html">functions</a> and
<a href="items/static-items.html">statics</a>. Calling functions or accessing statics that are declared in external
blocks is only allowed in an <code>unsafe</code> context.</p>
<h2><a class="header" href="#functions-1" id="functions-1">Functions</a></h2>
<p>Functions within external blocks are declared in the same way as other Rust
functions, with the exception that they may not have a body and are instead
terminated by a semicolon. Patterns are not allowed in parameters, only
<a href="items/../identifiers.html">IDENTIFIER</a> or <code>_</code> may be used.</p>
<p>Functions within external blocks may be called by Rust code, just like
functions defined in Rust. The Rust compiler automatically translates between
the Rust ABI and the foreign ABI.</p>
<p>A function declared in an extern block is implicitly <code>unsafe</code>. When coerced to
a function pointer, a function declared in an extern block has type <code>unsafe extern &quot;abi&quot; for&lt;'l1, ..., 'lm&gt; fn(A1, ..., An) -&gt; R</code>, where <code>'l1</code>, ... <code>'lm</code>
are its lifetime parameters, <code>A1</code>, ..., <code>An</code> are the declared types of its
parameters and <code>R</code> is the declared return type.</p>
<h2><a class="header" href="#statics" id="statics">Statics</a></h2>
<p>Statics within external blocks are declared in the same way as <a href="items/static-items.html">statics</a> outside of external blocks,
except that they do not have an expression initializing their value.
It is <code>unsafe</code> to access a static item declared in an extern block, whether or
not it’s mutable, because there is nothing guaranteeing that the bit pattern at the static’s
memory is valid for the type it is declared with, since some arbitrary (e.g. C) code is in charge
of initializing the static.</p>
<p>Extern statics can be either immutable or mutable just like <a href="items/static-items.html">statics</a> outside of external blocks.
An immutable static <em>must</em> be initialized before any Rust code is executed. It is not enough for
the static to be initialized before Rust code reads from it.</p>
<h2><a class="header" href="#abi" id="abi">ABI</a></h2>
<p>By default external blocks assume that the library they are calling uses the
standard C ABI on the specific platform. Other ABIs may be specified using an
<code>abi</code> string, as shown here:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Interface to the Windows API
extern &quot;stdcall&quot; { }
<span class="boring">}
</span></code></pre></pre>
<p>There are three ABI strings which are cross-platform, and which all compilers
are guaranteed to support:</p>
<ul>
<li><code>extern &quot;Rust&quot;</code> -- The default ABI when you write a normal <code>fn foo()</code> in any
Rust code.</li>
<li><code>extern &quot;C&quot;</code> -- This is the same as <code>extern fn foo()</code>; whatever the default
your C compiler supports.</li>
<li><code>extern &quot;system&quot;</code> -- Usually the same as <code>extern &quot;C&quot;</code>, except on Win32, in
which case it’s <code>&quot;stdcall&quot;</code>, or what you should use to link to the Windows
API itself</li>
</ul>
<p>There are also some platform-specific ABI strings:</p>
<ul>
<li><code>extern &quot;cdecl&quot;</code> -- The default for x86_32 C code.</li>
<li><code>extern &quot;stdcall&quot;</code> -- The default for the Win32 API on x86_32.</li>
<li><code>extern &quot;win64&quot;</code> -- The default for C code on x86_64 Windows.</li>
<li><code>extern &quot;sysv64&quot;</code> -- The default for C code on non-Windows x86_64.</li>
<li><code>extern &quot;aapcs&quot;</code> -- The default for ARM.</li>
<li><code>extern &quot;fastcall&quot;</code> -- The <code>fastcall</code> ABI -- corresponds to MSVC’s
<code>__fastcall</code> and GCC and clang’s <code>__attribute__((fastcall))</code></li>
<li><code>extern &quot;vectorcall&quot;</code> -- The <code>vectorcall</code> ABI -- corresponds to MSVC’s
<code>__vectorcall</code> and clang’s <code>__attribute__((vectorcall))</code></li>
</ul>
<h2><a class="header" href="#variadic-functions" id="variadic-functions">Variadic functions</a></h2>
<p>Functions within external blocks may be variadic by specifying <code>...</code> after one
or more named arguments in the argument list:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>extern {
    fn foo(x: i32, ...);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#attributes-on-extern-blocks" id="attributes-on-extern-blocks">Attributes on extern blocks</a></h2>
<p>The following <a href="items/../attributes.html">attributes</a> control the behavior of external blocks.</p>
<h3><a class="header" href="#the-link-attribute" id="the-link-attribute">The <code>link</code> attribute</a></h3>
<p>The <em><code>link</code> attribute</em> specifies the name of a native library that the
compiler should link with for the items within an <code>extern</code> block. It uses the
<a href="items/../attributes.html#meta-item-attribute-syntax"><em>MetaListNameValueStr</em></a> syntax to specify its inputs. The <code>name</code> key is the
name of the native library to link. The <code>kind</code> key is an optional value which
specifies the kind of library with the following possible values:</p>
<ul>
<li><code>dylib</code> — Indicates a dynamic library. This is the default if <code>kind</code> is not
specified.</li>
<li><code>static</code> — Indicates a static library.</li>
<li><code>framework</code> — Indicates a macOS framework. This is only valid for macOS
targets.</li>
</ul>
<p>The <code>name</code> key must be included if <code>kind</code> is specified.</p>
<p>The <code>wasm_import_module</code> key may be used to specify the <a href="https://webassembly.github.io/spec/core/syntax/modules.html">WebAssembly module</a>
name for the items within an <code>extern</code> block when importing symbols from the
host environment. The default module name is <code>env</code> if <code>wasm_import_module</code> is
not specified.</p>
<!-- ignore: requires extern linking -->
<pre><code class="language-rust ignore">#[link(name = &quot;crypto&quot;)]
extern {
    // …
}

#[link(name = &quot;CoreFoundation&quot;, kind = &quot;framework&quot;)]
extern {
    // …
}

#[link(wasm_import_module = &quot;foo&quot;)]
extern {
    // …
}
</code></pre>
<p>It is valid to add the <code>link</code> attribute on an empty extern block. You can use
this to satisfy the linking requirements of extern blocks elsewhere in your
code (including upstream crates) instead of adding the attribute to each extern
block.</p>
<h3><a class="header" href="#the-link_name-attribute" id="the-link_name-attribute">The <code>link_name</code> attribute</a></h3>
<p>The <code>link_name</code> attribute may be specified on declarations inside an <code>extern</code>
block to indicate the symbol to import for the given function or static. It
uses the <a href="items/../attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> syntax to specify the name of the symbol.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>extern {
    #[link_name = &quot;actual_symbol_name&quot;]
    fn name_in_rust();
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#attributes-on-function-parameters-1" id="attributes-on-function-parameters-1">Attributes on function parameters</a></h3>
<p>Attributes on extern function parameters follow the same rules and
restrictions as <a href="items/functions.html#attributes-on-function-parameters">regular function parameters</a>.</p>
<h1><a class="header" href="#type-and-lifetime-parameters" id="type-and-lifetime-parameters">Type and Lifetime Parameters</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Generics</em> :<br />
   <code>&lt;</code> <em>GenericParams</em> <code>&gt;</code></p>
<p><em>GenericParams</em> :<br />
      <em>LifetimeParams</em><br />
   | ( <em>LifetimeParam</em> <code>,</code> )<sup>*</sup> <em>TypeParams</em></p>
<p><em>LifetimeParams</em> :<br />
   ( <em>LifetimeParam</em> <code>,</code> )<sup>*</sup> <em>LifetimeParam</em><sup>?</sup></p>
<p><em>LifetimeParam</em> :<br />
   <a href="items/../attributes.html"><em>OuterAttribute</em></a><sup>?</sup> <a href="items/../tokens.html#lifetimes-and-loop-labels">LIFETIME_OR_LABEL</a> ( <code>:</code> <a href="items/../trait-bounds.html"><em>LifetimeBounds</em></a> )<sup>?</sup></p>
<p><em>TypeParams</em>:<br />
   ( <em>TypeParam</em> <code>,</code> )<sup>*</sup> <em>TypeParam</em><sup>?</sup></p>
<p><em>TypeParam</em> :<br />
   <a href="items/../attributes.html"><em>OuterAttribute</em></a><sup>?</sup> <a href="items/../identifiers.html">IDENTIFIER</a> ( <code>:</code> <a href="items/../trait-bounds.html"><em>TypeParamBounds</em></a><sup>?</sup> )<sup>?</sup> ( <code>=</code> <a href="items/../types.html#type-expressions"><em>Type</em></a> )<sup>?</sup></p>
</blockquote>
<p>Functions, type aliases, structs, enumerations, unions, traits, and
implementations may be <em>parameterized</em> by types and lifetimes. These parameters
are listed in angle <span class="parenthetical">brackets (<code>&lt;...&gt;</code>)</span>,
usually immediately after the name of the item and before its definition. For
implementations, which don’t have a name, they come directly after <code>impl</code>.
Lifetime parameters must be declared before type parameters. Some examples of
items with type and lifetime parameters:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a, T&gt;() {}
trait A&lt;U&gt; {}
struct Ref&lt;'a, T&gt; where T: 'a { r: &amp;'a T }
<span class="boring">}
</span></code></pre></pre>
<p><a href="items/../types/pointer.html#shared-references-">References</a>, <a href="items/../types/pointer.html#raw-pointers-const-and-mut">raw pointers</a>, <a href="items/../types/array.html">arrays</a>, <a href="items/../types/array.html">slices</a>, <a href="items/../types/tuple.html">tuples</a>, and
<a href="items/../types/function-pointer.html">function pointers</a> have lifetime or type parameters as well, but are not
referred to with path syntax.</p>
<h2><a class="header" href="#where-clauses" id="where-clauses">Where clauses</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>WhereClause</em> :<br />
   <code>where</code> ( <em>WhereClauseItem</em> <code>,</code> )<sup>*</sup> <em>WhereClauseItem</em> <sup>?</sup></p>
<p><em>WhereClauseItem</em> :<br />
      <em>LifetimeWhereClauseItem</em><br />
   | <em>TypeBoundWhereClauseItem</em></p>
<p><em>LifetimeWhereClauseItem</em> :<br />
   <a href="items/../trait-bounds.html"><em>Lifetime</em></a> <code>:</code> <a href="items/../trait-bounds.html"><em>LifetimeBounds</em></a></p>
<p><em>TypeBoundWhereClauseItem</em> :<br />
   <em>ForLifetimes</em><sup>?</sup> <a href="items/../types.html#type-expressions"><em>Type</em></a> <code>:</code> <a href="items/../trait-bounds.html"><em>TypeParamBounds</em></a><sup>?</sup></p>
<p><em>ForLifetimes</em> :<br />
   <code>for</code> <code>&lt;</code> <a href="items/generics.html#type-and-lifetime-parameters"><em>LifetimeParams</em></a> <code>&gt;</code></p>
</blockquote>
<p><em>Where clauses</em> provide another way to specify bounds on type and lifetime
parameters as well as a way to specify bounds on types that aren’t type
parameters.</p>
<p>Bounds that don’t use the item’s parameters or higher-ranked lifetimes are
checked when the item is defined. It is an error for such a bound to be false.</p>
<p><a href="items/../special-types-and-traits.html#copy"><code>Copy</code></a>, <a href="items/../special-types-and-traits.html#clone"><code>Clone</code></a>, and <a href="items/../special-types-and-traits.html#sized"><code>Sized</code></a> bounds are also checked for certain generic
types when defining the item. It is an error to have <code>Copy</code> or <code>Clone</code>as a
bound on a mutable reference, <a href="items/../types/trait-object.html">trait object</a> or <a href="items/../types/array.html">slice</a> or <code>Sized</code> as a
bound on a trait object or slice.</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct A&lt;T&gt;
where
    T: Iterator,            // Could use A&lt;T: Iterator&gt; instead
    T::Item: Copy,
    String: PartialEq&lt;T&gt;,
    i32: Default,           // Allowed, but not useful
    i32: Iterator,          // Error: the trait bound is not satisfied
    [T]: Copy,              // Error: the trait bound is not satisfied
{
    f: T,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#attributes" id="attributes">Attributes</a></h2>
<p>Generic lifetime and type parameters allow <a href="items/../attributes.html">attributes</a> on them. There are no
built-in attributes that do anything in this position, although custom derive
attributes may give meaning to it.</p>
<p>This example shows using a custom derive attribute to modify the meaning of a
generic parameter.</p>
<!-- ignore: requires proc macro derive -->
<pre><code class="language-rust ignore">// Assume that the derive for MyFlexibleClone declared `my_flexible_clone` as
// an attribute it understands.
#[derive(MyFlexibleClone)]
struct Foo&lt;#[my_flexible_clone(unbounded)] H&gt; {
    a: *const H
}
</code></pre>
<h1><a class="header" href="#associated-items" id="associated-items">Associated Items</a></h1>
<p><em>Associated Items</em> are the items declared in <a href="items/traits.html">traits</a> or defined in
<a href="items/implementations.html">implementations</a>. They are called this because they are defined on an associate
type — the type in the implementation. They are a subset of the kinds of
items you can declare in a module. Specifically, there are <a href="items/associated-items.html#associated-functions-and-methods">associated
functions</a> (including methods), <a href="items/associated-items.html#associated-types">associated types</a>, and <a href="items/associated-items.html#associated-constants">associated constants</a>.</p>
<p>Associated items are useful when the associated item logically is related to the
associating item. For example, the <code>is_some</code> method on <code>Option</code> is intrinsically
related to Options, so should be associated.</p>
<p>Every associated item kind comes in two varieties: definitions that contain the
actual implementation and declarations that declare signatures for
definitions.</p>
<p>It is the declarations that make up the contract of traits and what is available
on generic types.</p>
<h2><a class="header" href="#associated-functions-and-methods" id="associated-functions-and-methods">Associated functions and methods</a></h2>
<p><em>Associated functions</em> are <a href="items/functions.html">functions</a> associated with a type.</p>
<p>An <em>associated function declaration</em> declares a signature for an associated
function definition. It is written as a function item, except the
function body is replaced with a <code>;</code>.</p>
<p>The identifier is the name of the function. The generics, parameter list,
return type, and where clause of the associated function must be the same as the
associated function declarations’s.</p>
<p>An <em>associated function definition</em> defines a function associated with another
type. It is written the same as a <a href="items/../types/function-item.html">function item</a>.</p>
<p>An example of a common associated function is a <code>new</code> function that returns
a value of the type the associated function is associated with.</p>
<pre><pre class="playpen"><code class="language-rust">struct Struct {
    field: i32
}

impl Struct {
    fn new() -&gt; Struct {
        Struct {
            field: 0i32
        }
    }
}

fn main () {
    let _struct = Struct::new();
}
</code></pre></pre>
<p>When the associated function is declared on a trait, the function can also be
called with a <a href="items/../paths.html">path</a> that is a path to the trait appended by the name of the
trait. When this happens, it is substituted for <code>&lt;_ as Trait&gt;::function_name</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Num {
    fn from_i32(n: i32) -&gt; Self;
}

impl Num for f64 {
    fn from_i32(n: i32) -&gt; f64 { n as f64 }
}

// These 4 are all equivalent in this case.
let _: f64 = Num::from_i32(42);
let _: f64 = &lt;_ as Num&gt;::from_i32(42);
let _: f64 = &lt;f64 as Num&gt;::from_i32(42);
let _: f64 = f64::from_i32(42);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#methods" id="methods">Methods</a></h3>
<blockquote>
<p><em>Method</em> :<br />
   <a href="items/functions.html"><em>FunctionQualifiers</em></a> <code>fn</code> <a href="items/../identifiers.html">IDENTIFIER</a> <a href="items/generics.html"><em>Generics</em></a><sup>?</sup><br />
      <code>(</code> <em>SelfParam</em> (<code>,</code> <a href="items/functions.html"><em>FunctionParam</em></a>)<sup>*</sup> <code>,</code><sup>?</sup> <code>)</code><br />
      <a href="items/functions.html"><em>FunctionReturnType</em></a><sup>?</sup> <a href="items/generics.html#where-clauses"><em>WhereClause</em></a><sup>?</sup><br />
      <a href="items/../expressions/block-expr.html"><em>BlockExpression</em></a></p>
<p><em>SelfParam</em> :<br />
   <a href="items/../attributes.html"><em>OuterAttribute</em></a><sup>*</sup> ( <em>ShorthandSelf</em> | <em>TypedSelf</em> )</p>
<p><em>ShorthandSelf</em> :<br />
    (<code>&amp;</code> | <code>&amp;</code> <a href="items/../trait-bounds.html"><em>Lifetime</em></a>)<sup>?</sup> <code>mut</code><sup>?</sup> <code>self</code></p>
<p><em>TypedSelf</em> :<br />
   <code>mut</code><sup>?</sup> <code>self</code> <code>:</code> <a href="items/../types.html#type-expressions"><em>Type</em></a></p>
</blockquote>
<p>Associated functions whose first parameter is named <code>self</code> are called <em>methods</em>
and may be invoked using the <a href="items/../expressions/method-call-expr.html">method call operator</a>, for example, <code>x.foo()</code>, as
well as the usual function call notation.</p>
<p>If the type of the <code>self</code> parameter is specified, it is limited to types resolving
to one generated by the following grammar (where <code>'lt</code> denotes some arbitrary
lifetime):</p>
<pre><code class="language-text">P = &amp;'lt S | &amp;'lt mut S | Box&lt;S&gt; | Rc&lt;S&gt; | Arc&lt;S&gt; | Pin&lt;P&gt;
S = Self | P
</code></pre>
<p>The <code>Self</code> terminal in this grammar denotes a type resolving to the implementing type.
This can also include the contextual type alias <code>Self</code>, other type aliases,
or associated type projections resolving to the implementing type.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">use std::pin::Pin;
</span>// Examples of methods implemented on struct `Example`.
struct Example;
type Alias = Example;
trait Trait { type Output; }
impl Trait for Example { type Output = Example; }
impl Example {
    fn by_value(self: Self) {}
    fn by_ref(self: &amp;Self) {}
    fn by_ref_mut(self: &amp;mut Self) {}
    fn by_box(self: Box&lt;Self&gt;) {}
    fn by_rc(self: Rc&lt;Self&gt;) {}
    fn by_arc(self: Arc&lt;Self&gt;) {}
    fn by_pin(self: Pin&lt;&amp;Self&gt;) {}
    fn explicit_type(self: Arc&lt;Example&gt;) {}
    fn with_lifetime&lt;'a&gt;(self: &amp;'a Self) {}
    fn nested&lt;'a&gt;(self: &amp;mut &amp;'a Arc&lt;Rc&lt;Box&lt;Alias&gt;&gt;&gt;) {}
    fn via_projection(self: &lt;Example as Trait&gt;::Output) {}
}
<span class="boring">}
</span></code></pre></pre>
<p>Shorthand syntax can be used without specifying a type, which have the
following equivalents:</p>
<table><thead><tr><th>Shorthand</th><th>Equivalent</th></tr></thead><tbody>
<tr><td><code>self</code></td><td><code>self: Self</code></td></tr>
<tr><td><code>&amp;'lifetime self</code></td><td><code>self: &amp;'lifetime Self</code></td></tr>
<tr><td><code>&amp;'lifetime mut self</code></td><td><code>self: &amp;'lifetime mut Self</code></td></tr>
</tbody></table>
<blockquote>
<p><strong>Note</strong>: Lifetimes can be, and usually are, elided with this shorthand.</p>
</blockquote>
<p>If the <code>self</code> parameter is prefixed with <code>mut</code>, it becomes a mutable variable,
similar to regular parameters using a <code>mut</code> <a href="items/../patterns.html#identifier-patterns">identifier pattern</a>. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Changer: Sized {
    fn change(mut self) {}
    fn modify(mut self: Box&lt;Self&gt;) {}
}
<span class="boring">}
</span></code></pre></pre>
<p>As an example of methods on a trait, consider the following:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">type Surface = i32;
</span><span class="boring">type BoundingBox = i32;
</span>trait Shape {
    fn draw(&amp;self, surface: Surface);
    fn bounding_box(&amp;self) -&gt; BoundingBox;
}
<span class="boring">}
</span></code></pre></pre>
<p>This defines a trait with two methods. All values that have <a href="items/implementations.html">implementations</a>
of this trait while the trait is in scope can have their <code>draw</code> and
<code>bounding_box</code> methods called.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">type Surface = i32;
</span><span class="boring">type BoundingBox = i32;
</span><span class="boring">trait Shape {
</span><span class="boring">    fn draw(&amp;self, surface: Surface);
</span><span class="boring">    fn bounding_box(&amp;self) -&gt; BoundingBox;
</span><span class="boring">}
</span><span class="boring">
</span>struct Circle {
    // ...
}

impl Shape for Circle {
    // ...
<span class="boring">  fn draw(&amp;self, _: Surface) {}
</span><span class="boring">  fn bounding_box(&amp;self) -&gt; BoundingBox { 0i32 }
</span>}

<span class="boring">impl Circle {
</span><span class="boring">    fn new() -&gt; Circle { Circle{} }
</span><span class="boring">}
</span><span class="boring">
</span>let circle_shape = Circle::new();
let bounding_box = circle_shape.bounding_box();
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Edition Differences</strong>: In the 2015 edition, it is possible to declare trait
methods with anonymous parameters (e.g. <code>fn foo(u8)</code>). This is deprecated and
an error as of the 2018 edition. All parameters must have an argument name.</p>
</blockquote>
<h4><a class="header" href="#attributes-on-method-parameters" id="attributes-on-method-parameters">Attributes on method parameters</a></h4>
<p>Attributes on method parameters follow the same rules and restrictions as
<a href="items/functions.html#attributes-on-function-parameters">regular function parameters</a>.</p>
<h2><a class="header" href="#associated-types" id="associated-types">Associated Types</a></h2>
<p><em>Associated types</em> are <a href="items/type-aliases.html">type aliases</a> associated with another type. Associated
types cannot be defined in <a href="items/implementations.html#inherent-implementations">inherent implementations</a> nor can they be given a
default implementation in traits.</p>
<p>An <em>associated type declaration</em> declares a signature for associated type
definitions. It is written as <code>type</code>, then an <a href="items/../identifiers.html">identifier</a>, and
finally an optional list of trait bounds.</p>
<p>The identifier is the name of the declared type alias. The optional trait bounds
must be fulfilled by the implementations of the type alias.</p>
<p>An <em>associated type definition</em> defines a type alias on another type. It is
written as <code>type</code>, then an <a href="items/../identifiers.html">identifier</a>, then an <code>=</code>, and finally a <a href="items/../types.html#type-expressions">type</a>.</p>
<p>If a type <code>Item</code> has an associated type <code>Assoc</code> from a trait <code>Trait</code>, then
<code>&lt;Item as Trait&gt;::Assoc</code> is a type that is an alias of the type specified in the
associated type definition. Furthermore, if <code>Item</code> is a type parameter, then
<code>Item::Assoc</code> can be used in type parameters.</p>
<pre><pre class="playpen"><code class="language-rust">trait AssociatedType {
    // Associated type declaration
    type Assoc;
}

struct Struct;

struct OtherStruct;

impl AssociatedType for Struct {
    // Associated type definition
    type Assoc = OtherStruct;
}

impl OtherStruct {
    fn new() -&gt; OtherStruct {
        OtherStruct
    }
}

fn main() {
    // Usage of the associated type to refer to OtherStruct as &lt;Struct as AssociatedType&gt;::Assoc
    let _other_struct: OtherStruct = &lt;Struct as AssociatedType&gt;::Assoc::new();
}
</code></pre></pre>
<h3><a class="header" href="#associated-types-container-example" id="associated-types-container-example">Associated Types Container Example</a></h3>
<p>Consider the following example of a <code>Container</code> trait. Notice that the type is
available for use in the method signatures:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Container {
    type E;
    fn empty() -&gt; Self;
    fn insert(&amp;mut self, elem: Self::E);
}
<span class="boring">}
</span></code></pre></pre>
<p>In order for a type to implement this trait, it must not only provide
implementations for every method, but it must specify the type <code>E</code>. Here’s an
implementation of <code>Container</code> for the standard library type <code>Vec</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Container {
</span><span class="boring">    type E;
</span><span class="boring">    fn empty() -&gt; Self;
</span><span class="boring">    fn insert(&amp;mut self, elem: Self::E);
</span><span class="boring">}
</span>impl&lt;T&gt; Container for Vec&lt;T&gt; {
    type E = T;
    fn empty() -&gt; Vec&lt;T&gt; { Vec::new() }
    fn insert(&amp;mut self, x: T) { self.push(x); }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#associated-constants" id="associated-constants">Associated Constants</a></h2>
<p><em>Associated constants</em> are <a href="items/constant-items.html">constants</a> associated with a type.</p>
<p>An <em>associated constant declaration</em> declares a signature for associated
constant definitions. It is written as <code>const</code>, then an identifier,
then <code>:</code>, then a type, finished by a <code>;</code>.</p>
<p>The identifier is the name of the constant used in the path. The type is the
type that the definition has to implement.</p>
<p>An <em>associated constant definition</em> defines a constant associated with a
type. It is written the same as a <a href="items/constant-items.html">constant item</a>.</p>
<h3><a class="header" href="#associated-constants-examples" id="associated-constants-examples">Associated Constants Examples</a></h3>
<p>A basic example:</p>
<pre><pre class="playpen"><code class="language-rust">trait ConstantId {
    const ID: i32;
}

struct Struct;

impl ConstantId for Struct {
    const ID: i32 = 1;
}

fn main() {
    assert_eq!(1, Struct::ID);
}
</code></pre></pre>
<p>Using default values:</p>
<pre><pre class="playpen"><code class="language-rust">trait ConstantIdDefault {
    const ID: i32 = 1;
}

struct Struct;
struct OtherStruct;

impl ConstantIdDefault for Struct {}

impl ConstantIdDefault for OtherStruct {
    const ID: i32 = 5;
}

fn main() {
    assert_eq!(1, Struct::ID);
    assert_eq!(5, OtherStruct::ID);
}
</code></pre></pre>
<h1><a class="header" href="#visibility-and-privacy" id="visibility-and-privacy">Visibility and Privacy</a></h1>
<blockquote>
<p><strong><sup>Syntax<sup></strong><br />
<em>Visibility</em> :<br />
      <code>pub</code><br />
   | <code>pub</code> <code>(</code> <code>crate</code> <code>)</code><br />
   | <code>pub</code> <code>(</code> <code>self</code> <code>)</code><br />
   | <code>pub</code> <code>(</code> <code>super</code> <code>)</code><br />
   | <code>pub</code> <code>(</code> <code>in</code> <a href="paths.html#simple-paths"><em>SimplePath</em></a> <code>)</code></p>
</blockquote>
<p>These two terms are often used interchangeably, and what they are attempting to
convey is the answer to the question “Can this item be used at this location?”</p>
<p>Rust’s name resolution operates on a global hierarchy of namespaces. Each level
in the hierarchy can be thought of as some item. The items are one of those
mentioned above, but also include external crates. Declaring or defining a new
module can be thought of as inserting a new tree into the hierarchy at the
location of the definition.</p>
<p>To control whether interfaces can be used across modules, Rust checks each use
of an item to see whether it should be allowed or not. This is where privacy
warnings are generated, or otherwise “you used a private item of another module
and weren’t allowed to.”</p>
<p>By default, everything in Rust is <em>private</em>, with two exceptions: Associated
items in a <code>pub</code> Trait are public by default; Enum variants
in a <code>pub</code> enum are also public by default. When an item is declared as <code>pub</code>,
it can be thought of as being accessible to the outside world. For example:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {}
</span>// Declare a private struct
struct Foo;

// Declare a public struct with a private field
pub struct Bar {
    field: i32,
}

// Declare a public enum with two public variants
pub enum State {
    PubliclyAccessibleState,
    PubliclyAccessibleState2,
}
</code></pre></pre>
<p>With the notion of an item being either public or private, Rust allows item
accesses in two cases:</p>
<ol>
<li>If an item is public, then it can be accessed externally from some module
<code>m</code> if you can access all the item’s parent modules from <code>m</code>. You can
also potentially be able to name the item through re-exports. See below.</li>
<li>If an item is private, it may be accessed by the current module and its
descendants.</li>
</ol>
<p>These two cases are surprisingly powerful for creating module hierarchies
exposing public APIs while hiding internal implementation details. To help
explain, here’s a few use cases and what they would entail:</p>
<ul>
<li>
<p>A library developer needs to expose functionality to crates which link
against their library. As a consequence of the first case, this means that
anything which is usable externally must be <code>pub</code> from the root down to the
destination item. Any private item in the chain will disallow external
accesses.</p>
</li>
<li>
<p>A crate needs a global available “helper module” to itself, but it doesn’t
want to expose the helper module as a public API. To accomplish this, the
root of the crate’s hierarchy would have a private module which then
internally has a “public API”. Because the entire crate is a descendant of
the root, then the entire local crate can access this private module through
the second case.</p>
</li>
<li>
<p>When writing unit tests for a module, it’s often a common idiom to have an
immediate child of the module to-be-tested named <code>mod test</code>. This module
could access any items of the parent module through the second case, meaning
that internal implementation details could also be seamlessly tested from the
child module.</p>
</li>
</ul>
<p>In the second case, it mentions that a private item “can be accessed” by the
current module and its descendants, but the exact meaning of accessing an item
depends on what the item is. Accessing a module, for example, would mean
looking inside of it (to import more items). On the other hand, accessing a
function would mean that it is invoked. Additionally, path expressions and
import statements are considered to access an item in the sense that the
import/expression is only valid if the destination is in the current visibility
scope.</p>
<p>Here’s an example of a program which exemplifies the three cases outlined
above:</p>
<pre><pre class="playpen"><code class="language-rust">// This module is private, meaning that no external crate can access this
// module. Because it is private at the root of this current crate, however, any
// module in the crate may access any publicly visible item in this module.
mod crate_helper_module {

    // This function can be used by anything in the current crate
    pub fn crate_helper() {}

    // This function *cannot* be used by anything else in the crate. It is not
    // publicly visible outside of the `crate_helper_module`, so only this
    // current module and its descendants may access it.
    fn implementation_detail() {}
}

// This function is &quot;public to the root&quot; meaning that it's available to external
// crates linking against this one.
pub fn public_api() {}

// Similarly to 'public_api', this module is public so external crates may look
// inside of it.
pub mod submodule {
    use crate_helper_module;

    pub fn my_method() {
        // Any item in the local crate may invoke the helper module's public
        // interface through a combination of the two rules above.
        crate_helper_module::crate_helper();
    }

    // This function is hidden to any module which is not a descendant of
    // `submodule`
    fn my_implementation() {}

    #[cfg(test)]
    mod test {

        #[test]
        fn test_my_implementation() {
            // Because this module is a descendant of `submodule`, it's allowed
            // to access private items inside of `submodule` without a privacy
            // violation.
            super::my_implementation();
        }
    }
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<p>For a Rust program to pass the privacy checking pass, all paths must be valid
accesses given the two rules above. This includes all use statements,
expressions, types, etc.</p>
<h2><a class="header" href="#pubin-path-pubcrate-pubsuper-and-pubself" id="pubin-path-pubcrate-pubsuper-and-pubself"><code>pub(in path)</code>, <code>pub(crate)</code>, <code>pub(super)</code>, and <code>pub(self)</code></a></h2>
<p>In addition to public and private, Rust allows users to declare an item as
visible within a given scope. The rules for <code>pub</code> restrictions are as follows:</p>
<ul>
<li><code>pub(in path)</code> makes an item visible within the provided <code>path</code>. <code>path</code> must
be a parent module of the item whose visibility is being declared.</li>
<li><code>pub(crate)</code> makes an item visible within the current crate.</li>
<li><code>pub(super)</code> makes an item visible to the parent module. This is equivalent
to <code>pub(in super)</code>.</li>
<li><code>pub(self)</code> makes an item visible to the current module. This is equivalent
to <code>pub(in self)</code>.</li>
</ul>
<blockquote>
<p><strong>Edition Differences</strong>: Starting with the 2018 edition, paths for
<code>pub(in path)</code> must start with <code>crate</code>, <code>self</code>, or <code>super</code>. The 2015 edition
may also use paths starting with <code>::</code> or modules from the crate root.</p>
</blockquote>
<p>Here’s an example:</p>
<pre><pre class="playpen"><code class="language-rust">pub mod outer_mod {
    pub mod inner_mod {
        // This function is visible within `outer_mod`
        pub(in crate::outer_mod) fn outer_mod_visible_fn() {}
        // Same as above, this is only valid in the 2015 edition.
        pub(in outer_mod) fn outer_mod_visible_fn_2015() {}

        // This function is visible to the entire crate
        pub(crate) fn crate_visible_fn() {}

        // This function is visible within `outer_mod`
        pub(super) fn super_mod_visible_fn() {
            // This function is visible since we're in the same `mod`
            inner_mod_visible_fn();
        }

        // This function is visible
        pub(self) fn inner_mod_visible_fn() {}
    }
    pub fn foo() {
        inner_mod::outer_mod_visible_fn();
        inner_mod::crate_visible_fn();
        inner_mod::super_mod_visible_fn();

        // This function is no longer visible since we're outside of `inner_mod`
        // Error! `inner_mod_visible_fn` is private
        //inner_mod::inner_mod_visible_fn();
    }
}

fn bar() {
    // This function is still visible since we're in the same crate
    outer_mod::inner_mod::crate_visible_fn();

    // This function is no longer visible since we're outside of `outer_mod`
    // Error! `super_mod_visible_fn` is private
    //outer_mod::inner_mod::super_mod_visible_fn();

    // This function is no longer visible since we're outside of `outer_mod`
    // Error! `outer_mod_visible_fn` is private
    //outer_mod::inner_mod::outer_mod_visible_fn();

    outer_mod::foo();
}

fn main() { bar() }
</code></pre></pre>
<h2><a class="header" href="#re-exporting-and-visibility" id="re-exporting-and-visibility">Re-exporting and Visibility</a></h2>
<p>Rust allows publicly re-exporting items through a <code>pub use</code> directive. Because
this is a public directive, this allows the item to be used in the current
module through the rules above. It essentially allows public access into the
re-exported item. For example, this program is valid:</p>
<pre><pre class="playpen"><code class="language-rust">pub use self::implementation::api;

mod implementation {
    pub mod api {
        pub fn f() {}
    }
}

<span class="boring">fn main() {}
</span></code></pre></pre>
<p>This means that any external crate referencing <code>implementation::api::f</code> would
receive a privacy violation, while the path <code>api::f</code> would be allowed.</p>
<p>When re-exporting a private item, it can be thought of as allowing the “privacy
chain” being short-circuited through the reexport instead of passing through
the namespace hierarchy as it normally would.</p>
<script>
(function() {
    var fragments = {
        "#cold-attribute": "attributes/codegen.html#the-cold-attribute",
        "#conditional-compilation": "conditional-compilation.html",
        "#deprecation": "attributes/diagnostics.html#the-deprecated-attribute",
        "#derive": "attributes/derive.html",
        "#documentation": "../rustdoc/the-doc-attribute.html",
        "#ffi-attributes": "attributes.html#built-in-attributes-index",
        "#inline-attribute": "attributes/codegen.html#the-inline-attribute",
        "#lint-check-attributes": "attributes/diagnostics.html#lint-check-attributes",
        "#macro-related-attributes": "attributes.html#built-in-attributes-index",
        "#miscellaneous-attributes": "attributes.html#built-in-attributes-index",
        "#must_use": "attributes/diagnostics.html#the-must_use-attribute",
        "#optimization-hints": "attributes/codegen.html#optimization-hints",
        "#path": "items/modules.html#the-path-attribute",
        "#preludes": "crates-and-source-files.html#preludes-and-no_std",
        "#testing": "attributes/testing.html",
        "#tool-lint-attributes": "attributes/diagnostics.html#tool-lint-attributes",
        "#crate-only-attributes": "attributes.html#built-in-attributes-index",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>
<h1><a class="header" href="#attributes-1" id="attributes-1">Attributes</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>InnerAttribute</em> :<br />
   <code>#</code> <code>!</code> <code>[</code> <em>Attr</em> <code>]</code></p>
<p><em>OuterAttribute</em> :<br />
   <code>#</code> <code>[</code> <em>Attr</em> <code>]</code></p>
<p><em>Attr</em> :<br />
   <a href="paths.html#simple-paths"><em>SimplePath</em></a> <em>AttrInput</em><sup>?</sup></p>
<p><em>AttrInput</em> :<br />
      <a href="macros.html"><em>DelimTokenTree</em></a><br />
   | <code>=</code> <a href="expressions/literal-expr.html"><em>LiteralExpression</em></a><sub><em>without suffix</em></sub></p>
</blockquote>
<p>An <em>attribute</em> is a general, free-form metadatum that is interpreted according
to name, convention, language, and compiler version. Attributes are modeled
on Attributes in <a href="https://www.ecma-international.org/publications/standards/Ecma-335.htm">ECMA-335</a>, with the syntax coming from <a href="https://www.ecma-international.org/publications/standards/Ecma-334.htm">ECMA-334</a> (C#).</p>
<p><em>Inner attributes</em>, written with a bang (<code>!</code>) after the hash (<code>#</code>), apply to the
item that the attribute is declared within. <em>Outer attributes</em>, written without
the bang after the hash, apply to the thing that follows the attribute.</p>
<p>The attribute consists of a path to the attribute, followed by an optional
delimited token tree whose interpretation is defined by the attribute.
Attributes other than macro attributes also allow the input to be an equals
sign (<code>=</code>) followed by a literal expression. See the <a href="attributes.html#meta-item-attribute-syntax">meta item
syntax</a> below for more details.</p>
<p>Attributes can be classified into the following kinds:</p>
<ul>
<li><a href="attributes.html#built-in-attributes-index">Built-in attributes</a></li>
<li><a href="procedural-macros.html#attribute-macros">Macro attributes</a></li>
<li><a href="procedural-macros.html#derive-macro-helper-attributes">Derive macro helper attributes</a></li>
<li><a href="attributes.html#tool-attributes">Tool attributes</a></li>
</ul>
<p>Attributes may be applied to many things in the language:</p>
<ul>
<li>All <a href="items.html">item declarations</a> accept outer attributes while <a href="items/external-blocks.html">external blocks</a>,
<a href="items/functions.html">functions</a>, <a href="items/implementations.html">implementations</a>, and <a href="items/modules.html">modules</a> accept inner attributes.</li>
<li>Most <a href="statements.html">statements</a> accept outer attributes (see <a href="expressions.html#expression-attributes">Expression Attributes</a> for
limitations on expression statements).</li>
<li><a href="expressions/block-expr.html">Block expressions</a> accept outer and inner attributes, but only when they are
the outer expression of an <a href="statements.html#expression-statements">expression statement</a> or the final expression of
another block expression.</li>
<li><a href="items/enumerations.html">Enum</a> variants and <a href="items/structs.html">struct</a> and <a href="items/unions.html">union</a> fields accept outer attributes.</li>
<li><a href="expressions/match-expr.html">Match expression arms</a> accept outer attributes.</li>
<li><a href="items/generics.html">Generic lifetime or type parameter</a> accept outer attributes.</li>
<li>Expressions accept outer attributes in limited situations, see <a href="expressions.html#expression-attributes">Expression
Attributes</a> for details.</li>
<li><a href="items/functions.html">Function</a>, <a href="expressions/closure-expr.html">closure</a> and <a href="types/function-pointer.html">function pointer</a>
parameters accept outer attributes. This includes attributes on variadic parameters
denoted with <code>...</code> in function pointers and <a href="items/external-blocks.html#variadic-functions">external blocks</a>.</li>
</ul>
<p>Some examples of attributes:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// General metadata applied to the enclosing module or crate.
#![crate_type = &quot;lib&quot;]

// A function marked as a unit test
#[test]
fn test_foo() {
    /* ... */
}

// A conditionally-compiled module
#[cfg(target_os = &quot;linux&quot;)]
mod bar {
    /* ... */
}

// A lint attribute used to suppress a warning/error
#[allow(non_camel_case_types)]
type int8_t = i8;

// Inner attribute applies to the entire function.
fn some_unused_variables() {
  #![allow(unused_variables)]

  let x = ();
  let y = ();
  let z = ();
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#meta-item-attribute-syntax" id="meta-item-attribute-syntax">Meta Item Attribute Syntax</a></h2>
<p>A “meta item” is the syntax used for the <em>Attr</em> rule by most <a href="attributes.html#built-in-attributes-index">built-in
attributes</a>. It has the following grammar:</p>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>MetaItem</em> :<br />
      <a href="paths.html#simple-paths"><em>SimplePath</em></a><br />
   | <a href="paths.html#simple-paths"><em>SimplePath</em></a> <code>=</code> <a href="expressions/literal-expr.html"><em>LiteralExpression</em></a><sub><em>without suffix</em></sub><br />
   | <a href="paths.html#simple-paths"><em>SimplePath</em></a> <code>(</code> <em>MetaSeq</em><sup>?</sup> <code>)</code></p>
<p><em>MetaSeq</em> :<br />
   <em>MetaItemInner</em> ( <code>,</code> MetaItemInner )<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>MetaItemInner</em> :<br />
      <em>MetaItem</em><br />
   | <a href="expressions/literal-expr.html"><em>LiteralExpression</em></a><sub><em>without suffix</em></sub></p>
</blockquote>
<p>Literal expressions in meta items must not include integer or float type
suffixes.</p>
<p>Various built-in attributes use different subsets of the meta item syntax to
specify their inputs. The following grammar rules show some commonly used
forms:</p>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>MetaWord</em>:<br />
   <a href="identifiers.html">IDENTIFIER</a></p>
<p><em>MetaNameValueStr</em>:<br />
   <a href="identifiers.html">IDENTIFIER</a> <code>=</code> (<a href="tokens.html#string-literals">STRING_LITERAL</a> | <a href="tokens.html#raw-string-literals">RAW_STRING_LITERAL</a>)</p>
<p><em>MetaListPaths</em>:<br />
   <a href="identifiers.html">IDENTIFIER</a> <code>(</code> ( <a href="paths.html#simple-paths"><em>SimplePath</em></a> (<code>,</code> <a href="paths.html#simple-paths"><em>SimplePath</em></a>)* <code>,</code><sup>?</sup> )<sup>?</sup> <code>)</code></p>
<p><em>MetaListIdents</em>:<br />
   <a href="identifiers.html">IDENTIFIER</a> <code>(</code> ( <a href="identifiers.html">IDENTIFIER</a> (<code>,</code> <a href="identifiers.html">IDENTIFIER</a>)* <code>,</code><sup>?</sup> )<sup>?</sup> <code>)</code></p>
<p><em>MetaListNameValueStr</em>:<br />
   <a href="identifiers.html">IDENTIFIER</a> <code>(</code> ( <em>MetaNameValueStr</em> (<code>,</code> <em>MetaNameValueStr</em>)* <code>,</code><sup>?</sup> )<sup>?</sup> <code>)</code></p>
</blockquote>
<p>Some examples of meta items are:</p>
<table><thead><tr><th>Style</th><th>Example</th></tr></thead><tbody>
<tr><td><em>MetaWord</em></td><td><code>no_std</code></td></tr>
<tr><td><em>MetaNameValueStr</em></td><td><code>doc = &quot;example&quot;</code></td></tr>
<tr><td><em>MetaListPaths</em></td><td><code>allow(unused, clippy::inline_always)</code></td></tr>
<tr><td><em>MetaListIdents</em></td><td><code>macro_use(foo, bar)</code></td></tr>
<tr><td><em>MetaListNameValueStr</em></td><td><code>link(name = &quot;CoreFoundation&quot;, kind = &quot;framework&quot;)</code></td></tr>
</tbody></table>
<h2><a class="header" href="#active-and-inert-attributes" id="active-and-inert-attributes">Active and inert attributes</a></h2>
<p>An attribute is either active or inert. During attribute processing, <em>active
attributes</em> remove themselves from the thing they are on while <em>inert attributes</em>
stay on.</p>
<p>The <a href="conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a> and <a href="conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a> attributes are active. The <a href="attributes/testing.html#the-test-attribute"><code>test</code></a> attribute is
inert when compiling for tests and active otherwise. <a href="procedural-macros.html#attribute-macros">Attribute macros</a> are
active. All other attributes are inert.</p>
<h2><a class="header" href="#tool-attributes" id="tool-attributes">Tool attributes</a></h2>
<p>The compiler may allow attributes for external tools where each tool resides
in its own namespace. The first segment of the attribute path is the name of
the tool, with one or more additional segments whose interpretation is up to
the tool.</p>
<p>When a tool is not in use, the tool’s attributes are accepted without a
warning. When the tool is in use, the tool is responsible for processing and
interpretation of its attributes.</p>
<p>Tool attributes are not available if the <a href="items/modules.html#prelude-items"><code>no_implicit_prelude</code></a> attribute is
used.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Tells the rustfmt tool to not format the following element.
#[rustfmt::skip]
struct S {
}

// Controls the &quot;cyclomatic complexity&quot; threshold for the clippy tool.
#[clippy::cyclomatic_complexity = &quot;100&quot;]
pub fn f() {}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: <code>rustc</code> currently recognizes the tools “clippy” and “rustfmt”.</p>
</blockquote>
<h2><a class="header" href="#built-in-attributes-index" id="built-in-attributes-index">Built-in attributes index</a></h2>
<p>The following is an index of all built-in attributes.</p>
<ul>
<li>Conditional compilation
<ul>
<li><a href="conditional-compilation.html#the-cfg-attribute"><code>cfg</code></a> — Controls conditional compilation.</li>
<li><a href="conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a> — Conditionally includes attributes.</li>
</ul>
</li>
<li>Testing
<ul>
<li><a href="attributes/testing.html#the-test-attribute"><code>test</code></a> — Marks a function as a test.</li>
<li><a href="attributes/testing.html#the-ignore-attribute"><code>ignore</code></a> — Disables a test function.</li>
<li><a href="attributes/testing.html#the-should_panic-attribute"><code>should_panic</code></a> — Indicates a test should generate a panic.</li>
</ul>
</li>
<li>Derive
<ul>
<li><a href="attributes/derive.html"><code>derive</code></a> — Automatic trait implementations.</li>
</ul>
</li>
<li>Macros
<ul>
<li><a href="macros-by-example.html#path-based-scope"><code>macro_export</code></a> — Exports a <code>macro_rules</code> macro for cross-crate usage.</li>
<li><a href="macros-by-example.html#the-macro_use-attribute"><code>macro_use</code></a> — Expands macro visibility, or imports macros from other
crates.</li>
<li><a href="procedural-macros.html#function-like-procedural-macros"><code>proc_macro</code></a> — Defines a function-like macro.</li>
<li><a href="procedural-macros.html#derive-macros"><code>proc_macro_derive</code></a> — Defines a derive macro.</li>
<li><a href="procedural-macros.html#attribute-macros"><code>proc_macro_attribute</code></a> — Defines an attribute macro.</li>
</ul>
</li>
<li>Diagnostics
<ul>
<li><a href="attributes/diagnostics.html#lint-check-attributes"><code>allow</code></a>, <a href="attributes/diagnostics.html#lint-check-attributes"><code>warn</code></a>, <a href="attributes/diagnostics.html#lint-check-attributes"><code>deny</code></a>, <a href="attributes/diagnostics.html#lint-check-attributes"><code>forbid</code></a> — Alters the default lint level.</li>
<li><a href="attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code></a> — Generates deprecation notices.</li>
<li><a href="attributes/diagnostics.html#the-must_use-attribute"><code>must_use</code></a> — Generates a lint for unused values.</li>
</ul>
</li>
<li>ABI, linking, symbols, and FFI
<ul>
<li><a href="items/external-blocks.html#the-link-attribute"><code>link</code></a> — Specifies a native library to link with an <code>extern</code> block.</li>
<li><a href="items/external-blocks.html#the-link_name-attribute"><code>link_name</code></a> — Specifies the name of the symbol for functions or statics
in an <code>extern</code> block.</li>
<li><a href="items/extern-crates.html#the-no_link-attribute"><code>no_link</code></a> — Prevents linking an extern crate.</li>
<li><a href="type-layout.html#representations"><code>repr</code></a> — Controls type layout.</li>
<li><a href="linkage.html"><code>crate_type</code></a> — Specifies the type of crate (library, executable, etc.).</li>
<li><a href="crates-and-source-files.html#the-no_main-attribute"><code>no_main</code></a> — Disables emitting the <code>main</code> symbol.</li>
<li><a href="abi.html#the-export_name-attribute"><code>export_name</code></a> — Specifies the exported symbol name for a function or
static.</li>
<li><a href="abi.html#the-link_section-attribute"><code>link_section</code></a> — Specifies the section of an object file to use for a
function or static.</li>
<li><a href="abi.html#the-no_mangle-attribute"><code>no_mangle</code></a> — Disables symbol name encoding.</li>
<li><a href="abi.html#the-used-attribute"><code>used</code></a> — Forces the compiler to keep a static item in the output
object file.</li>
<li><a href="crates-and-source-files.html#the-crate_name-attribute"><code>crate_name</code></a> — Specifies the crate name.</li>
</ul>
</li>
<li>Code generation
<ul>
<li><a href="attributes/codegen.html#the-inline-attribute"><code>inline</code></a> — Hint to inline code.</li>
<li><a href="attributes/codegen.html#the-cold-attribute"><code>cold</code></a> — Hint that a function is unlikely to be called.</li>
<li><a href="attributes/codegen.html#the-no_builtins-attribute"><code>no_builtins</code></a> — Disables use of certain built-in functions.</li>
<li><a href="attributes/codegen.html#the-target_feature-attribute"><code>target_feature</code></a> — Configure platform-specific code generation.</li>
</ul>
</li>
<li>Documentation
<ul>
<li><code>doc</code> — Specifies documentation. See <a href="../rustdoc/the-doc-attribute.html">The Rustdoc Book</a> for more
information. <a href="comments.html#doc-comments">Doc comments</a> are transformed into <code>doc</code> attributes.</li>
</ul>
</li>
<li>Preludes
<ul>
<li><a href="crates-and-source-files.html#preludes-and-no_std"><code>no_std</code></a> — Removes std from the prelude.</li>
<li><a href="items/modules.html#prelude-items"><code>no_implicit_prelude</code></a> — Disables prelude lookups within a module.</li>
</ul>
</li>
<li>Modules
<ul>
<li><a href="items/modules.html#the-path-attribute"><code>path</code></a> — Specifies the filename for a module.</li>
</ul>
</li>
<li>Limits
<ul>
<li><a href="attributes/limits.html#the-recursion_limit-attribute"><code>recursion_limit</code></a> — Sets the maximum recursion limit for certain
compile-time operations.</li>
<li><a href="attributes/limits.html#the-type_length_limit-attribute"><code>type_length_limit</code></a> — Sets the maximum size of a polymorphic type.</li>
</ul>
</li>
<li>Runtime
<ul>
<li><a href="runtime.html#the-panic_handler-attribute"><code>panic_handler</code></a> — Sets the function to handle panics.</li>
<li><a href="runtime.html#the-global_allocator-attribute"><code>global_allocator</code></a> — Sets the global memory allocator.</li>
<li><a href="runtime.html#the-windows_subsystem-attribute"><code>windows_subsystem</code></a> — Specifies the windows subsystem to link with.</li>
</ul>
</li>
<li>Features
<ul>
<li><code>feature</code> — Used to enable unstable or experimental compiler features. See
<a href="../unstable-book/index.html">The Unstable Book</a> for features implemented in <code>rustc</code>.</li>
</ul>
</li>
<li>Type System
<ul>
<li><a href="attributes/type_system.html#the-non_exhaustive-attribute"><code>non_exhaustive</code></a> — Indicate that a type will have more fields/variants
added in future.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#testing-attributes" id="testing-attributes">Testing attributes</a></h1>
<p>The following <a href="attributes/../attributes.html">attributes</a> are used for specifying functions for performing
tests. Compiling a crate in “test” mode enables building the test functions
along with a test harness for executing the tests. Enabling the test mode also
enables the <a href="attributes/../conditional-compilation.html#test"><code>test</code> conditional compilation option</a>.</p>
<h2><a class="header" href="#the-test-attribute" id="the-test-attribute">The <code>test</code> attribute</a></h2>
<p>The <em><code>test</code> attribute</em> marks a function to be executed as a test. These
functions are only compiled when in test mode. Test functions must be free,
monomorphic functions that take no arguments, and the return type must be one
of the following:</p>
<ul>
<li><code>()</code></li>
<li><code>Result&lt;(), E&gt; where E: Error</code></li>
</ul>
<!-- * `!` -->
<!-- * Result<!, E> where E: Error` -->
<blockquote>
<p>Note: The implementation of which return types are allowed is determined by
the unstable <a href="attributes/../../std/process/trait.Termination.html"><code>Termination</code></a> trait.</p>
</blockquote>
<!-- If the previous section needs updating (from "must take no arguments"
  onwards, also update it in the crates-and-source-files.md file -->
<blockquote>
<p>Note: The test mode is enabled by passing the <code>--test</code> argument to <code>rustc</code>
or using <code>cargo test</code>.</p>
</blockquote>
<p>Tests that return <code>()</code> pass as long as they terminate and do not panic. Tests
that return a <code>Result&lt;(), E&gt;</code> pass as long as they return <code>Ok(())</code>. Tests that
do not terminate neither pass nor fail.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io;
</span><span class="boring">fn setup_the_thing() -&gt; io::Result&lt;i32&gt; { Ok(1) }
</span><span class="boring">fn do_the_thing(s: &amp;i32) -&gt; io::Result&lt;()&gt; { Ok(()) }
</span>#[test]
fn test_the_thing() -&gt; io::Result&lt;()&gt; {
    let state = setup_the_thing()?; // expected to succeed
    do_the_thing(&amp;state)?;          // expected to succeed
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#the-ignore-attribute" id="the-ignore-attribute">The <code>ignore</code> attribute</a></h2>
<p>A function annotated with the <code>test</code> attribute can also be annotated with the
<code>ignore</code> attribute. The <em><code>ignore</code> attribute</em> tells the test harness to not
execute that function as a test. It will still be compiled when in test mode.</p>
<p>The <code>ignore</code> attribute may optionally be written with the <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a>
syntax to specify a reason why the test is ignored.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[test]
#[ignore = &quot;not yet implemented&quot;]
fn mytest() {
    // …
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: The <code>rustc</code> test harness supports the <code>--include-ignored</code> flag to
force ignored tests to be run.</p>
</blockquote>
<h2><a class="header" href="#the-should_panic-attribute" id="the-should_panic-attribute">The <code>should_panic</code> attribute</a></h2>
<p>A function annotated with the <code>test</code> attribute that returns <code>()</code> can also be
annotated with the <code>should_panic</code> attribute. The <em><code>should_panic</code> attribute</em>
makes the test only pass if it actually panics.</p>
<p>The <code>should_panic</code> attribute may optionally take an input string that must
appear within the panic message. If the string is not found in the message,
then the test will fail. The string may be passed using the
<a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> syntax or the <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaListNameValueStr</em></a> syntax with an
<code>expected</code> field.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[test]
#[should_panic(expected = &quot;values don't match&quot;)]
fn mytest() {
    assert_eq!(1, 2, &quot;values don't match&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#derive" id="derive">Derive</a></h1>
<p>The <em><code>derive</code> attribute</em> allows new <a href="attributes/../items.html">items</a> to be automatically generated for
data structures. It uses the <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaListPaths</em></a> syntax to specify a list of
traits to implement or paths to <a href="attributes/../procedural-macros.html#derive-macros">derive macros</a> to process.</p>
<p>For example, the following will create an <a href="attributes/../items/implementations.html"><code>impl</code> item</a> for the
<a href="attributes/../../std/cmp/trait.PartialEq.html"><code>PartialEq</code></a> and <a href="attributes/../../std/clone/trait.Clone.html"><code>Clone</code></a> traits for <code>Foo</code>, and the type parameter <code>T</code> will be
given the <code>PartialEq</code> or <code>Clone</code> constraints for the appropriate <code>impl</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Clone)]
struct Foo&lt;T&gt; {
    a: i32,
    b: T,
}
<span class="boring">}
</span></code></pre></pre>
<p>The generated <code>impl</code> for <code>PartialEq</code> is equivalent to</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo&lt;T&gt; { a: i32, b: T }
</span>impl&lt;T: PartialEq&gt; PartialEq for Foo&lt;T&gt; {
    fn eq(&amp;self, other: &amp;Foo&lt;T&gt;) -&gt; bool {
        self.a == other.a &amp;&amp; self.b == other.b
    }

    fn ne(&amp;self, other: &amp;Foo&lt;T&gt;) -&gt; bool {
        self.a != other.a || self.b != other.b
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>You can implement <code>derive</code> for your own traits through <a href="attributes/../procedural-macros.html#derive-macros">procedural macros</a>.</p>
<h1><a class="header" href="#diagnostic-attributes" id="diagnostic-attributes">Diagnostic attributes</a></h1>
<p>The following <a href="attributes/../attributes.html">attributes</a> are used for controlling or generating diagnostic
messages during compilation.</p>
<h2><a class="header" href="#lint-check-attributes" id="lint-check-attributes">Lint check attributes</a></h2>
<p>A lint check names a potentially undesirable coding pattern, such as
unreachable code or omitted documentation. The lint attributes <code>allow</code>,
<code>warn</code>, <code>deny</code>, and <code>forbid</code> use the <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaListPaths</em></a> syntax to specify a
list of lint names to change the lint level for the entity to which the
attribute applies.</p>
<p>For any lint check <code>C</code>:</p>
<ul>
<li><code>allow(C)</code> overrides the check for <code>C</code> so that violations will go
unreported,</li>
<li><code>warn(C)</code> warns about violations of <code>C</code> but continues compilation.</li>
<li><code>deny(C)</code> signals an error after encountering a violation of <code>C</code>,</li>
<li><code>forbid(C)</code> is the same as <code>deny(C)</code>, but also forbids changing the lint
level afterwards,</li>
</ul>
<blockquote>
<p>Note: The lint checks supported by <code>rustc</code> can be found via <code>rustc -W help</code>,
along with their default settings and are documented in the <a href="attributes/../../rustc/lints/index.html">rustc book</a>.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub mod m1 {
    // Missing documentation is ignored here
    #[allow(missing_docs)]
    pub fn undocumented_one() -&gt; i32 { 1 }

    // Missing documentation signals a warning here
    #[warn(missing_docs)]
    pub fn undocumented_too() -&gt; i32 { 2 }

    // Missing documentation signals an error here
    #[deny(missing_docs)]
    pub fn undocumented_end() -&gt; i32 { 3 }
}
<span class="boring">}
</span></code></pre></pre>
<p>This example shows how one can use <code>allow</code> and <code>warn</code> to toggle a particular
check on and off:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[warn(missing_docs)]
pub mod m2{
    #[allow(missing_docs)]
    pub mod nested {
        // Missing documentation is ignored here
        pub fn undocumented_one() -&gt; i32 { 1 }

        // Missing documentation signals a warning here,
        // despite the allow above.
        #[warn(missing_docs)]
        pub fn undocumented_two() -&gt; i32 { 2 }
    }

    // Missing documentation signals a warning here
    pub fn undocumented_too() -&gt; i32 { 3 }
}
<span class="boring">}
</span></code></pre></pre>
<p>This example shows how one can use <code>forbid</code> to disallow uses of <code>allow</code> for
that lint check:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[forbid(missing_docs)]
pub mod m3 {
    // Attempting to toggle warning signals an error here
    #[allow(missing_docs)]
    /// Returns 2.
    pub fn undocumented_too() -&gt; i32 { 2 }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#tool-lint-attributes" id="tool-lint-attributes">Tool lint attributes</a></h3>
<p>Tool lints allows using scoped lints, to <code>allow</code>, <code>warn</code>, <code>deny</code> or <code>forbid</code>
lints of certain tools.</p>
<p>Currently <code>clippy</code> is the only available lint tool.</p>
<p>Tool lints only get checked when the associated tool is active. If a lint
attribute, such as <code>allow</code>, references a nonexistent tool lint, the compiler
will not warn about the nonexistent lint until you use the tool.</p>
<p>Otherwise, they work just like regular lint attributes:</p>
<pre><pre class="playpen"><code class="language-rust">// set the entire `pedantic` clippy lint group to warn
#![warn(clippy::pedantic)]
// silence warnings from the `filter_map` clippy lint
#![allow(clippy::filter_map)]

fn main() {
    // ...
}

// silence the `cmp_nan` clippy lint just for this function
#[allow(clippy::cmp_nan)]
fn foo() {
    // ...
}
</code></pre></pre>
<h2><a class="header" href="#the-deprecated-attribute" id="the-deprecated-attribute">The <code>deprecated</code> attribute</a></h2>
<p>The <em><code>deprecated</code> attribute</em> marks an item as deprecated. <code>rustc</code> will issue
warnings on usage of <code>#[deprecated]</code> items. <code>rustdoc</code> will show item
deprecation, including the <code>since</code> version and <code>note</code>, if available.</p>
<p>The <code>deprecated</code> attribute has several forms:</p>
<ul>
<li><code>deprecated</code> — Issues a generic message.</li>
<li><code>deprecated = &quot;message&quot;</code> — Includes the given string in the deprecation
message.</li>
<li><a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaListNameValueStr</em></a> syntax with two optional fields:
<ul>
<li><code>since</code> — Specifies a version number when the item was deprecated. <code>rustc</code>
does not currently interpret the string, but external tools like <a href="https://github.com/rust-lang/rust-clippy">Clippy</a>
may check the validity of the value.</li>
<li><code>note</code> — Specifies a string that should be included in the deprecation
message. This is typically used to provide an explanation about the
deprecation and preferred alternatives.</li>
</ul>
</li>
</ul>
<p>The <code>deprecated</code> attribute may be applied to any <a href="attributes/../items.html">item</a>, <a href="attributes/../items/traits.html">trait item</a>, <a href="attributes/../items/enumerations.html">enum
variant</a>, <a href="attributes/../items/structs.html">struct field</a>, or <a href="attributes/../items/external-blocks.html">external block item</a>. It cannot be applied to <a href="attributes/../items/implementations.html#trait-implementations">trait
implementation items</a>. When applied to an item containing other items, such as
a <a href="attributes/../items/modules.html">module</a> or <a href="attributes/../items/implementations.html">implementation</a>, all child items inherit the deprecation attribute.</p>
<!-- NOTE: Currently broken for macros, see https://github.com/rust-lang/rust/issues/49912
Also, it is only rejected for trait impl items (AnnotationKind::Prohibited). In all
other locations, it is silently ignored. Tuple struct fields are ignored.
-->
<p>Here is an example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[deprecated(since = &quot;5.2&quot;, note = &quot;foo was rarely used. Users should instead use bar&quot;)]
pub fn foo() {}

pub fn bar() {}
<span class="boring">}
</span></code></pre></pre>
<p>The <a href="https://github.com/rust-lang/rfcs/blob/master/text/1270-deprecation.md">RFC</a> contains motivations and more details.</p>
<h2><a class="header" href="#the-must_use-attribute" id="the-must_use-attribute">The <code>must_use</code> attribute</a></h2>
<p>The <em><code>must_use</code> attribute</em> is used to issue a diagnostic warning when a value
is not “used”. It can be applied to user-defined composite types
(<a href="attributes/../items/structs.html"><code>struct</code>s</a>, <a href="attributes/../items/enumerations.html"><code>enum</code>s</a>, and <a href="attributes/../items/unions.html"><code>union</code>s</a>), <a href="attributes/../items/functions.html">functions</a>,
and <a href="attributes/../items/traits.html">traits</a>.</p>
<p>The <code>must_use</code> attribute may include a message by using the
<a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> syntax such as <code>#[must_use = &quot;example message&quot;]</code>. The
message will be given alongside the warning.</p>
<p>When used on user-defined composite types, if the <a href="attributes/../expressions.html">expression</a> of an
<a href="attributes/../statements.html#expression-statements">expression statement</a> has that type, then the <code>unused_must_use</code> lint is
violated.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[must_use]
struct MustUse {
    // some fields
}

<span class="boring">impl MustUse {
</span><span class="boring">  fn new() -&gt; MustUse { MustUse {} }
</span><span class="boring">}
</span><span class="boring">
</span>// Violates the `unused_must_use` lint.
MustUse::new();
<span class="boring">}
</span></code></pre></pre>
<p>When used on a function, if the <a href="attributes/../expressions.html">expression</a> of an <a href="attributes/../statements.html#expression-statements">expression statement</a> is a
<a href="attributes/../expressions/call-expr.html">call expression</a> to that function, then the <code>unused_must_use</code> lint is
violated.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[must_use]
fn five() -&gt; i32 { 5i32 }

// Violates the unused_must_use lint.
five();
<span class="boring">}
</span></code></pre></pre>
<p>When used on a <a href="attributes/../items/traits.html">trait declaration</a>, a <a href="attributes/../expressions/call-expr.html">call expression</a> of an <a href="attributes/../statements.html#expression-statements">expression
statement</a> to a function that returns an <a href="attributes/../types/impl-trait.html">impl trait</a> of that trait violates
the <code>unused_must_use</code> lint.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[must_use]
trait Critical {}
impl Critical for i32 {}

fn get_critical() -&gt; impl Critical {
    4i32
}

// Violates the `unused_must_use` lint.
get_critical();
<span class="boring">}
</span></code></pre></pre>
<p>When used on a function in a trait declaration, then the behavior also applies
when the call expression is a function from an implementation of the trait.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Trait {
    #[must_use]
    fn use_me(&amp;self) -&gt; i32;
}

impl Trait for i32 {
    fn use_me(&amp;self) -&gt; i32 { 0i32 }
}

// Violates the `unused_must_use` lint.
5i32.use_me();
<span class="boring">}
</span></code></pre></pre>
<p>When used on a function in a trait implementation, the attribute does nothing.</p>
<blockquote>
<p>Note: Trivial no-op expressions containing the value will not violate the
lint. Examples include wrapping the value in a type that does not implement
<a href="attributes/../special-types-and-traits.html#drop"><code>Drop</code></a> and then not using that type and being the final expression of a
<a href="attributes/../expressions/block-expr.html">block expression</a> that is not used.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[must_use]
fn five() -&gt; i32 { 5i32 }

// None of these violate the unused_must_use lint.
(five(),);
Some(five());
{ five() };
if true { five() } else { 0i32 };
match true {
    _ =&gt; five()
};
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<blockquote>
<p>Note: It is idiomatic to use a <a href="attributes/../statements.html#let-statements">let statement</a> with a pattern of <code>_</code>
when a must-used value is purposely discarded.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[must_use]
fn five() -&gt; i32 { 5i32 }

// Does not violate the unused_must_use lint.
let _ = five();
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<h1><a class="header" href="#code-generation-attributes" id="code-generation-attributes">Code generation attributes</a></h1>
<p>The following <a href="attributes/../attributes.html">attributes</a> are used for controlling code generation.</p>
<h2><a class="header" href="#optimization-hints" id="optimization-hints">Optimization hints</a></h2>
<p>The <code>cold</code> and <code>inline</code> <a href="attributes/../attributes.html">attributes</a> give suggestions to generate code in a
way that may be faster than what it would do without the hint. The attributes
are only hints, and may be ignored.</p>
<p>Both attributes can be used on <a href="attributes/../items/functions.html">functions</a>. When applied to a function in a
<a href="attributes/../items/traits.html">trait</a>, they apply only to that function when used as a default function for
a trait implementation and not to all trait implementations. The attributes
have no effect on a trait function without a body.</p>
<h3><a class="header" href="#the-inline-attribute" id="the-inline-attribute">The <code>inline</code> attribute</a></h3>
<p>The <em><code>inline</code> <a href="attributes/../attributes.html">attribute</a></em> suggests that a copy of the attributed function
should be placed in the caller, rather than generating code to call the
function where it is defined.</p>
<blockquote>
<p><em><strong>Note</strong></em>: The <code>rustc</code> compiler automatically inlines functions based on
internal heuristics. Incorrectly inlining functions can make the program
slower, so this attribute should be used with care.</p>
</blockquote>
<p>There are three ways to use the inline attribute:</p>
<ul>
<li><code>#[inline]</code> suggests performing an inline expansion.</li>
<li><code>#[inline(always)]</code> suggests that an inline expansion should always be
performed.</li>
<li><code>#[inline(never)]</code> suggests that an inline expansion should never be
performed.</li>
</ul>
<h3><a class="header" href="#the-cold-attribute" id="the-cold-attribute">The <code>cold</code> attribute</a></h3>
<p>The <em><code>cold</code> <a href="attributes/../attributes.html">attribute</a></em> suggests that the attributed function is unlikely to
be called.</p>
<h2><a class="header" href="#the-no_builtins-attribute" id="the-no_builtins-attribute">The <code>no_builtins</code> attribute</a></h2>
<p>The <em><code>no_builtins</code> <a href="attributes/../attributes.html">attribute</a></em> may be applied at the crate level to disable
optimizing certain code patterns to invocations of library functions that are
assumed to exist.</p>
<h2><a class="header" href="#the-target_feature-attribute" id="the-target_feature-attribute">The <code>target_feature</code> attribute</a></h2>
<p>The <em><code>target_feature</code> <a href="attributes/../attributes.html">attribute</a></em> may be applied to an <a href="attributes/../unsafe-functions.html">unsafe function</a> to
enable code generation of that function for specific platform architecture
features. It uses the <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaListNameValueStr</em></a> syntax with a single key of
<code>enable</code> whose value is a string of comma-separated feature names to enable.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#[cfg(target_feature = &quot;avx2&quot;)]
</span>#[target_feature(enable = &quot;avx2&quot;)]
unsafe fn foo_avx2() {}
<span class="boring">}
</span></code></pre></pre>
<p>Each <a href="attributes/../conditional-compilation.html#target_arch">target architecture</a> has a set of features that may be enabled. It is an
error to specify a feature for a target architecture that the crate is not
being compiled for.</p>
<p>It is <a href="attributes/../behavior-considered-undefined.html">undefined behavior</a> to call a function that is compiled with a feature
that is not supported on the current platform the code is running on.</p>
<p>Functions marked with <code>target_feature</code> are not inlined into a context that
does not support the given features. The <code>#[inline(always)]</code> attribute may not
be used with a <code>target_feature</code> attribute.</p>
<h3><a class="header" href="#available-features" id="available-features">Available features</a></h3>
<p>The following is a list of the available feature names.</p>
<h4><a class="header" href="#x86-or-x86_64" id="x86-or-x86_64"><code>x86</code> or <code>x86_64</code></a></h4>
<table><thead><tr><th>Feature</th><th>Implicitly Enables</th><th>Description</th></tr></thead><tbody>
<tr><td><code>aes</code></td><td><code>sse2</code></td><td><a href="https://en.wikipedia.org/wiki/AES_instruction_set">AES</a> — Advanced Encryption Standard</td></tr>
<tr><td><code>avx</code></td><td><code>sse4.2</code></td><td><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a> — Advanced Vector Extensions</td></tr>
<tr><td><code>avx2</code></td><td><code>avx</code></td><td><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#AVX2">AVX2</a> — Advanced Vector Extensions 2</td></tr>
<tr><td><code>bmi1</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets">BMI1</a> — Bit Manipulation Instruction Sets</td></tr>
<tr><td><code>bmi2</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets#BMI2">BMI2</a> — Bit Manipulation Instruction Sets 2</td></tr>
<tr><td><code>fma</code></td><td><code>avx</code></td><td><a href="https://en.wikipedia.org/wiki/FMA_instruction_set">FMA3</a> — Three-operand fused multiply-add</td></tr>
<tr><td><code>fxsr</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/fxsave"><code>fxsave</code></a> and <a href="https://www.felixcloutier.com/x86/fxrstor"><code>fxrstor</code></a> — Save and restore x87 FPU, MMX Technology, and SSE State</td></tr>
<tr><td><code>lzcnt</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/lzcnt"><code>lzcnt</code></a> — Leading zeros count</td></tr>
<tr><td><code>pclmulqdq</code></td><td><code>sse2</code></td><td><a href="https://www.felixcloutier.com/x86/pclmulqdq"><code>pclmulqdq</code></a> — Packed carry-less multiplication quadword</td></tr>
<tr><td><code>popcnt</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/popcnt"><code>popcnt</code></a> — Count of bits set to 1</td></tr>
<tr><td><code>rdrand</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/RdRand"><code>rdrand</code></a> — Read random number</td></tr>
<tr><td><code>rdseed</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/RdRand"><code>rdseed</code></a> — Read random seed</td></tr>
<tr><td><code>sha</code></td><td><code>sse2</code></td><td><a href="https://en.wikipedia.org/wiki/Intel_SHA_extensions">SHA</a> — Secure Hash Algorithm</td></tr>
<tr><td><code>sse</code></td><td></td><td><a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</a> — Streaming <abbr title="Single Instruction Multiple Data">SIMD</abbr> Extensions</td></tr>
<tr><td><code>sse2</code></td><td><code>sse</code></td><td><a href="https://en.wikipedia.org/wiki/SSE2">SSE2</a> — Streaming SIMD Extensions 2</td></tr>
<tr><td><code>sse3</code></td><td><code>sse2</code></td><td><a href="https://en.wikipedia.org/wiki/SSE3">SSE3</a> — Streaming SIMD Extensions 3</td></tr>
<tr><td><code>sse4.1</code></td><td><code>sse3</code></td><td><a href="https://en.wikipedia.org/wiki/SSE4#SSE4.1">SSE4.1</a> — Streaming SIMD Extensions 4.1</td></tr>
<tr><td><code>sse4.2</code></td><td><code>sse4.1</code></td><td><a href="https://en.wikipedia.org/wiki/SSE4#SSE4.2">SSE4.2</a> — Streaming SIMD Extensions 4.2</td></tr>
<tr><td><code>ssse3</code></td><td><code>sse3</code></td><td><a href="https://en.wikipedia.org/wiki/SSSE3">SSSE3</a> — Supplemental Streaming SIMD Extensions 3</td></tr>
<tr><td><code>xsave</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/xsave"><code>xsave</code></a> — Save processor extended states</td></tr>
<tr><td><code>xsavec</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/xsavec"><code>xsavec</code></a> — Save processor extended states with compaction</td></tr>
<tr><td><code>xsaveopt</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/xsaveopt"><code>xsaveopt</code></a> — Save processor extended states optimized</td></tr>
<tr><td><code>xsaves</code></td><td></td><td><a href="https://www.felixcloutier.com/x86/xsaves"><code>xsaves</code></a> — Save processor extended states supervisor</td></tr>
</tbody></table>
<!-- Keep links near each table to make it easier to move and update. -->
<h3><a class="header" href="#additional-information" id="additional-information">Additional information</a></h3>
<p>See the <a href="attributes/../conditional-compilation.html#target_feature"><code>target_feature</code> conditional compilation option</a> for selectively
enabling or disabling compilation of code based on compile-time settings. Note
that this option is not affected by the <code>target_feature</code> attribute, and is
only driven by the features enabled for the entire crate.</p>
<p>See the <a href="attributes/../../std/macro.is_x86_feature_detected.html"><code>is_x86_feature_detected</code></a> macro in the standard library for runtime
feature detection on the x86 platforms.</p>
<blockquote>
<p>Note: <code>rustc</code> has a default set of features enabled for each target and CPU.
The CPU may be chosen with the <a href="attributes/../../rustc/codegen-options/index.html#target-cpu"><code>-C target-cpu</code></a> flag. Individual features
may be enabled or disabled for an entire crate with the
<a href="attributes/../../rustc/codegen-options/index.html#target-feature"><code>-C target-feature</code></a> flag.</p>
</blockquote>
<h1><a class="header" href="#limits" id="limits">Limits</a></h1>
<p>The following <a href="attributes/../attributes.html">attributes</a> affect compile-time limits.</p>
<h2><a class="header" href="#the-recursion_limit-attribute" id="the-recursion_limit-attribute">The <code>recursion_limit</code> attribute</a></h2>
<p>The <em><code>recursion_limit</code> attribute</em> may be applied at the <a href="attributes/../crates-and-source-files.html">crate</a> level to set the
maximum depth for potentially infinitely-recursive compile-time operations
like macro expansion or auto-dereference. It uses the <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a>
syntax to specify the recursion depth.</p>
<blockquote>
<p>Note: The default in <code>rustc</code> is 128.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span>#![recursion_limit = &quot;4&quot;]

<span class="boring">fn main() {
</span>macro_rules! a {
    () =&gt; { a!(1) };
    (1) =&gt; { a!(2) };
    (2) =&gt; { a!(3) };
    (3) =&gt; { a!(4) };
    (4) =&gt; { };
}

// This fails to expand because it requires a recursion depth greater than 4.
a!{}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span>#![recursion_limit = &quot;1&quot;]

<span class="boring">fn main() {
</span>// This fails because it requires two recursive steps to auto-derefence.
(|_: &amp;u8| {})(&amp;&amp;1);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#the-type_length_limit-attribute" id="the-type_length_limit-attribute">The <code>type_length_limit</code> attribute</a></h2>
<p>The <em><code>type_length_limit</code> attribute</em> limits the maximum number of type
substitutions made when constructing a concrete type during monomorphization.
It is applied at the <a href="attributes/../crates-and-source-files.html">crate</a> level, and uses the <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> syntax
to set the limit based on the number of type substitutions.</p>
<blockquote>
<p>Note: The default in <code>rustc</code> is 1048576.</p>
</blockquote>
<!-- This code should fail to compile. Unfortunately rustdoc's `compile_fail`
     stops after analysis phase, and this error is generated after that. So
     this needs to be `ignore` for now. -->
<pre><code class="language-rust compile_fail ignore">#![type_length_limit = &quot;8&quot;]

fn f&lt;T&gt;(x: T) {}

// This fails to compile because monomorphizing to
// `f::&lt;(i32, i32, i32, i32, i32, i32, i32, i32, i32)&gt;&gt;` requires more
// than 8 type elements.
f((1, 2, 3, 4, 5, 6, 7, 8, 9));
</code></pre>
<h1><a class="header" href="#type-system-attributes" id="type-system-attributes">Type system attributes</a></h1>
<p>The following <a href="attributes/../attributes.html">attributes</a> are used for changing how a type can be used.</p>
<h2><a class="header" href="#the-non_exhaustive-attribute" id="the-non_exhaustive-attribute">The <code>non_exhaustive</code> attribute</a></h2>
<p>The <em><code>non_exhaustive</code> attribute</em> indicates that a type or variant may have
more fields or variants added in the future. It can be applied to
<a href="attributes/../items/structs.html"><code>struct</code>s</a>, <a href="attributes/../items/enumerations.html"><code>enum</code>s</a>, and <code>enum</code> variants.</p>
<p>The <code>non_exhaustive</code> attribute uses the <a href="attributes/../attributes.html#meta-item-attribute-syntax"><em>MetaWord</em></a> syntax and thus does not
take any inputs.</p>
<p>Within the defining crate, <code>non_exhaustive</code> has no effect.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
pub struct Config {
    pub window_width: u16,
    pub window_height: u16,
}

#[non_exhaustive]
pub enum Error {
    Message(String),
    Other,
}

pub enum Message {
    #[non_exhaustive] Send { from: u32, to: u32, contents: String },
    #[non_exhaustive] Reaction(u32),
    #[non_exhaustive] Quit,
}

// Non-exhaustive structs can be constructed as normal within the defining crate.
let config = Config { window_width: 640, window_height: 480 };

// Non-exhaustive structs can be matched on exhaustively within the defining crate.
if let Config { window_width, window_height } = config {
    // ...
}

let error = Error::Other;
let message = Message::Reaction(3);

// Non-exhaustive enums can be matched on exhaustively within the defining crate.
match error {
    Error::Message(ref s) =&gt; { },
    Error::Other =&gt; { },
}

match message {
    // Non-exhaustive variants can be matched on exhaustively within the defining crate.
    Message::Send { from, to, contents } =&gt; { },
    Message::Reaction(id) =&gt; { },
    Message::Quit =&gt; { },
}
<span class="boring">}
</span></code></pre></pre>
<p>Outside of the defining crate, types annotated with <code>non_exhaustive</code> have limitations that
preserve backwards compatibility when new fields or variants are added.</p>
<p>Non-exhaustive types cannot be constructed outside of the defining crate:</p>
<ul>
<li>Non-exhaustive variants (<a href="attributes/../items/structs.html"><code>struct</code></a> or <a href="attributes/../items/enumerations.html"><code>enum</code> variant</a>) cannot be constructed
with a <a href="attributes/../expressions/struct-expr.html"><em>StructExpression</em></a> (including with <a href="attributes/../expressions/struct-expr.html#functional-update-syntax">functional update syntax</a>).</li>
<li><a href="attributes/../items/enumerations.html"><code>enum</code></a> instances can be constructed in an <a href="attributes/../expressions/enum-variant-expr.html"><em>EnumerationVariantExpression</em></a>.</li>
</ul>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">// `Config`, `Error`, and `Message` are types defined in an upstream crate that have been
// annotated as `#[non_exhaustive]`.
use upstream::{Config, Error, Message};

// Cannot construct an instance of `Config`, if new fields were added in
// a new version of `upstream` then this would fail to compile, so it is
// disallowed.
let config = Config { window_width: 640, window_height: 480 };

// Can construct an instance of `Error`, new variants being introduced would
// not result in this failing to compile.
let error = Error::Message(&quot;foo&quot;.to_string());

// Cannot construct an instance of `Message::Send` or `Message::Reaction`,
// if new fields were added in a new version of `upstream` then this would
// fail to compile, so it is disallowed.
let message = Message::Send { from: 0, to: 1, contents: &quot;foo&quot;.to_string(), };
let message = Message::Reaction(0);

// Cannot construct an instance of `Message::Quit`, if this were converted to
// a tuple-variant `upstream` then this would fail to compile.
let message = Message::Quit;
</code></pre>
<p>There are limitations when matching on non-exhaustive types outside of the defining crate:</p>
<ul>
<li>When pattern matching on a non-exhaustive variant (<a href="attributes/../items/structs.html"><code>struct</code></a> or <a href="attributes/../items/enumerations.html"><code>enum</code> variant</a>),
a <a href="attributes/../patterns.html#struct-patterns"><em>StructPattern</em></a> must be used which must include a <code>..</code>. Tuple variant constructor visibility
is lowered to <code>min($vis, pub(crate))</code>.</li>
<li>When pattern matching on a non-exhaustive <a href="attributes/../items/enumerations.html"><code>enum</code></a>, matching on a variant does not
contribute towards the exhaustiveness of the arms.</li>
</ul>
<!-- ignore: requires external crates -->
<pre><code class="language-rust ignore">// `Config`, `Error`, and `Message` are types defined in an upstream crate that have been
// annotated as `#[non_exhaustive]`.
use upstream::{Config, Error, Message};

// Cannot match on a non-exhaustive enum without including a wildcard arm.
match error {
  Error::Message(ref s) =&gt; { },
  Error::Other =&gt; { },
  // would compile with: `_ =&gt; {},`
}

// Cannot match on a non-exhaustive struct without a wildcard.
if let Ok(Config { window_width, window_height }) = config {
    // would compile with: `..`
}

match message {
  // Cannot match on a non-exhaustive struct enum variant without including a wildcard.
  Message::Send { from, to, contents } =&gt; { },
  // Cannot match on a non-exhaustive tuple or unit enum variant.
  Message::Reaction(type) =&gt; { },
  Message::Quit =&gt; { },
}
</code></pre>
<p>Non-exhaustive types are always considered inhabited in downstream crates.</p>
<h1><a class="header" href="#statements-and-expressions" id="statements-and-expressions">Statements and expressions</a></h1>
<p>Rust is <em>primarily</em> an expression language. This means that most forms of
value-producing or effect-causing evaluation are directed by the uniform syntax
category of <em>expressions</em>. Each kind of expression can typically <em>nest</em> within
each other kind of expression, and rules for evaluation of expressions involve
specifying both the value produced by the expression and the order in which its
sub-expressions are themselves evaluated.</p>
<p>In contrast, statements in Rust serve <em>mostly</em> to contain and explicitly
sequence expression evaluation.</p>
<h1><a class="header" href="#statements" id="statements">Statements</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Statement</em> :<br />
      <code>;</code><br />
   | <a href="items.html"><em>Item</em></a><br />
   | <a href="statements.html#let-statements"><em>LetStatement</em></a><br />
   | <a href="statements.html#expression-statements"><em>ExpressionStatement</em></a><br />
   | <a href="macros.html#macro-invocation"><em>MacroInvocationSemi</em></a></p>
</blockquote>
<p>A <em>statement</em> is a component of a <a href="expressions/block-expr.html">block</a>, which is in turn a component of an
outer <a href="expressions.html">expression</a> or <a href="items/functions.html">function</a>.</p>
<p>Rust has two kinds of statement: <a href="statements.html#declaration-statements">declaration
statements</a> and <a href="statements.html#expression-statements">expression
statements</a>.</p>
<h2><a class="header" href="#declaration-statements" id="declaration-statements">Declaration statements</a></h2>
<p>A <em>declaration statement</em> is one that introduces one or more <em>names</em> into the
enclosing statement block. The declared names may denote new variables or new
<a href="items.html">items</a>.</p>
<p>The two kinds of declaration statements are item declarations and <code>let</code>
statements.</p>
<h3><a class="header" href="#item-declarations" id="item-declarations">Item declarations</a></h3>
<p>An <em>item declaration statement</em> has a syntactic form identical to an
<a href="items.html">item declaration</a> within a <a href="items/modules.html">module</a>. Declaring an item within a statement
block restricts its scope to the block containing the statement. The item is not
given a <a href="paths.html#canonical-paths">canonical path</a> nor are any sub-items it may declare. The exception to
this is that associated items defined by <a href="items/implementations.html">implementations</a> are still accessible
in outer scopes as long as the item and, if applicable, trait are accessible.
It is otherwise identical in meaning to declaring the item inside a module.</p>
<p>There is no implicit capture of the containing function’s generic parameters,
parameters, and local variables. For example, <code>inner</code> may not access
<code>outer_var</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn outer() {
  let outer_var = true;

  fn inner() { /* outer_var is not in scope here */ }

  inner();
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#let-statements" id="let-statements"><code>let</code> statements</a></h3>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>LetStatement</em> :<br />
   <a href="attributes.html"><em>OuterAttribute</em></a><sup>*</sup> <code>let</code> <a href="patterns.html"><em>Pattern</em></a>
( <code>:</code> <a href="types.html"><em>Type</em></a> )<sup>?</sup> (<code>=</code> <a href="expressions.html"><em>Expression</em></a> )<sup>?</sup> <code>;</code></p>
</blockquote>
<p>A <em><code>let</code> statement</em> introduces a new set of <a href="variables.html">variables</a>, given by an
irrefutable <a href="patterns.html">pattern</a>. The pattern is followed optionally by a type
annotation and then optionally by an initializer expression. When no
type annotation is given, the compiler will infer the type, or signal
an error if insufficient type information is available for definite
inference. Any variables introduced by a variable declaration are visible
from the point of declaration until the end of the enclosing block scope.</p>
<h2><a class="header" href="#expression-statements" id="expression-statements">Expression statements</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ExpressionStatement</em> :<br />
      <a href="expressions.html"><em>ExpressionWithoutBlock</em></a> <code>;</code><br />
   | <a href="expressions.html"><em>ExpressionWithBlock</em></a> <code>;</code><sup>?</sup></p>
</blockquote>
<p>An <em>expression statement</em> is one that evaluates an <a href="expressions.html">expression</a> and ignores its
result. As a rule, an expression statement’s purpose is to trigger the effects
of evaluating its expression.</p>
<p>An expression that consists of only a <a href="expressions/block-expr.html">block expression</a> or control flow
expression, if used in a context where a statement is permitted, can omit the
trailing semicolon. This can cause an ambiguity between it being parsed as a
standalone statement and as a part of another expression; in this case, it is
parsed as a statement. The type of <a href="expressions.html"><em>ExpressionWithBlock</em></a>
expressions when used as statements must be the unit type.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut v = vec![1, 2, 3];
</span>v.pop();          // Ignore the element returned from pop
if v.is_empty() {
    v.push(5);
} else {
    v.remove(0);
}                 // Semicolon can be omitted.
[1];              // Separate expression statement, not an indexing expression.
<span class="boring">}
</span></code></pre></pre>
<p>When the trailing semicolon is omitted, the result must be type <code>()</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// bad: the block's type is i32, not ()
// Error: expected `()` because of default return type
// if true {
//   1
// }

// good: the block's type is i32
if true {
  1
} else {
  2
};
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#attributes-on-statements" id="attributes-on-statements">Attributes on Statements</a></h2>
<p>Statements accept <a href="attributes.html">outer attributes</a>. The attributes that have meaning on a
statement are <a href="conditional-compilation.html"><code>cfg</code></a>, and <a href="attributes/diagnostics.html#lint-check-attributes">the lint check attributes</a>.</p>
<h1><a class="header" href="#expressions" id="expressions">Expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Expression</em> :<br />
      <em>ExpressionWithoutBlock</em><br />
   | <em>ExpressionWithBlock</em></p>
<p><em>ExpressionWithoutBlock</em> :<br />
   <a href="attributes.html"><em>OuterAttribute</em></a><sup>*</sup><a href="expressions.html#expression-attributes">†</a><br />
   (<br />
         <a href="expressions/literal-expr.html"><em>LiteralExpression</em></a><br />
      | <a href="expressions/path-expr.html"><em>PathExpression</em></a><br />
      | <a href="expressions/operator-expr.html"><em>OperatorExpression</em></a><br />
      | <a href="expressions/grouped-expr.html"><em>GroupedExpression</em></a><br />
      | <a href="expressions/array-expr.html"><em>ArrayExpression</em></a><br />
      | <a href="expressions/await-expr.html"><em>AwaitExpression</em></a><br />
      | <a href="expressions/array-expr.html#array-and-slice-indexing-expressions"><em>IndexExpression</em></a><br />
      | <a href="expressions/tuple-expr.html"><em>TupleExpression</em></a><br />
      | <a href="expressions/tuple-expr.html#tuple-indexing-expressions"><em>TupleIndexingExpression</em></a><br />
      | <a href="expressions/struct-expr.html"><em>StructExpression</em></a><br />
      | <a href="expressions/enum-variant-expr.html"><em>EnumerationVariantExpression</em></a><br />
      | <a href="expressions/call-expr.html"><em>CallExpression</em></a><br />
      | <a href="expressions/method-call-expr.html"><em>MethodCallExpression</em></a><br />
      | <a href="expressions/field-expr.html"><em>FieldExpression</em></a><br />
      | <a href="expressions/closure-expr.html"><em>ClosureExpression</em></a><br />
      | <a href="expressions/loop-expr.html#continue-expressions"><em>ContinueExpression</em></a><br />
      | <a href="expressions/loop-expr.html#break-expressions"><em>BreakExpression</em></a><br />
      | <a href="expressions/range-expr.html"><em>RangeExpression</em></a><br />
      | <a href="expressions/return-expr.html"><em>ReturnExpression</em></a><br />
      | <a href="macros.html#macro-invocation"><em>MacroInvocation</em></a><br />
   )</p>
<p><em>ExpressionWithBlock</em> :<br />
   <a href="attributes.html"><em>OuterAttribute</em></a><sup>*</sup><a href="expressions.html#expression-attributes">†</a><br />
   (<br />
         <a href="expressions/block-expr.html"><em>BlockExpression</em></a><br />
      | <a href="expressions/block-expr.html#async-blocks"><em>AsyncBlockExpression</em></a><br />
      | <a href="expressions/block-expr.html#unsafe-blocks"><em>UnsafeBlockExpression</em></a><br />
      | <a href="expressions/loop-expr.html"><em>LoopExpression</em></a><br />
      | <a href="expressions/if-expr.html#if-expressions"><em>IfExpression</em></a><br />
      | <a href="expressions/if-expr.html#if-let-expressions"><em>IfLetExpression</em></a><br />
      | <a href="expressions/match-expr.html"><em>MatchExpression</em></a><br />
   )</p>
</blockquote>
<p>An expression may have two roles: it always produces a <em>value</em>, and it may have
<em>effects</em> (otherwise known as “side effects”). An expression <em>evaluates to</em> a
value, and has effects during <em>evaluation</em>. Many expressions contain
sub-expressions (operands). The meaning of each kind of expression dictates
several things:</p>
<ul>
<li>Whether or not to evaluate the sub-expressions when evaluating the expression</li>
<li>The order in which to evaluate the sub-expressions</li>
<li>How to combine the sub-expressions’ values to obtain the value of the
expression</li>
</ul>
<p>In this way, the structure of expressions dictates the structure of execution.
Blocks are just another kind of expression, so blocks, statements, expressions,
and blocks again can recursively nest inside each other to an arbitrary depth.</p>
<h2><a class="header" href="#expression-precedence" id="expression-precedence">Expression precedence</a></h2>
<p>The precedence of Rust operators and expressions is ordered as follows, going
from strong to weak. Binary Operators at the same precedence level are grouped
in the order given by their associativity.</p>
<table><thead><tr><th>Operator/Expression</th><th>Associativity</th></tr></thead><tbody>
<tr><td>Paths</td><td></td></tr>
<tr><td>Method calls</td><td></td></tr>
<tr><td>Field expressions</td><td>left to right</td></tr>
<tr><td>Function calls, array indexing</td><td></td></tr>
<tr><td><code>?</code></td><td></td></tr>
<tr><td>Unary <code>-</code> <code>*</code> <code>!</code> <code>&amp;</code> <code>&amp;mut</code></td><td></td></tr>
<tr><td><code>as</code></td><td>left to right</td></tr>
<tr><td><code>*</code> <code>/</code> <code>%</code></td><td>left to right</td></tr>
<tr><td><code>+</code> <code>-</code></td><td>left to right</td></tr>
<tr><td><code>&lt;&lt;</code> <code>&gt;&gt;</code></td><td>left to right</td></tr>
<tr><td><code>&amp;</code></td><td>left to right</td></tr>
<tr><td><code>^</code></td><td>left to right</td></tr>
<tr><td><code>|</code></td><td>left to right</td></tr>
<tr><td><code>==</code> <code>!=</code> <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code></td><td>Require parentheses</td></tr>
<tr><td><code>&amp;&amp;</code></td><td>left to right</td></tr>
<tr><td><code>||</code></td><td>left to right</td></tr>
<tr><td><code>..</code> <code>..=</code></td><td>Require parentheses</td></tr>
<tr><td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <br> <code>&amp;=</code> <code>|=</code> <code>^=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code></td><td>right to left</td></tr>
<tr><td><code>return</code> <code>break</code> closures</td><td></td></tr>
</tbody></table>
<h2><a class="header" href="#place-expressions-and-value-expressions" id="place-expressions-and-value-expressions">Place Expressions and Value Expressions</a></h2>
<p>Expressions are divided into two main categories: place expressions and
value expressions. Likewise within each expression, sub-expressions may occur
in either place context or value context. The evaluation of an expression
depends both on its own category and the context it occurs within.</p>
<p>A <em>place expression</em> is an expression that represents a memory location. These
expressions are <a href="expressions/path-expr.html">paths</a> which refer to local variables, <a href="items/static-items.html">static variables</a>,
<a href="expressions/operator-expr.html#the-dereference-operator">dereferences</a> (<code>*expr</code>), <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">array indexing</a> expressions (<code>expr[expr]</code>),
<a href="expressions/field-expr.html">field</a> references (<code>expr.f</code>) and parenthesized place expressions. All other
expressions are value expressions.</p>
<p>A <em>value expression</em> is an expression that represents an actual value.</p>
<p>The following contexts are <em>place expression</em> contexts:</p>
<ul>
<li>The left operand of an <a href="expressions/operator-expr.html#assignment-expressions">assignment</a> or <a href="expressions/operator-expr.html#compound-assignment-expressions">compound assignment</a>
expression.</li>
<li>The operand of a unary <a href="expressions/operator-expr.html#borrow-operators">borrow</a> or <a href="expressions/operator-expr.html#the-dereference-operator">dereference</a> operator.</li>
<li>The operand of a field expression.</li>
<li>The indexed operand of an array indexing expression.</li>
<li>The operand of any <a href="expressions.html#implicit-borrows">implicit borrow</a>.</li>
<li>The initializer of a <a href="statements.html#let-statements">let statement</a>.</li>
<li>The <a href="glossary.html#scrutinee">scrutinee</a> of an <a href="expressions/if-expr.html#if-let-expressions"><code>if let</code></a>, <a href="expressions/match-expr.html"><code>match</code></a>, or <a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a>
expression.</li>
<li>The base of a <a href="expressions/struct-expr.html#functional-update-syntax">functional update</a> struct expression.</li>
</ul>
<blockquote>
<p>Note: Historically, place expressions were called <em>lvalues</em> and value
expressions were called <em>rvalues</em>.</p>
</blockquote>
<h3><a class="header" href="#moved-and-copied-types" id="moved-and-copied-types">Moved and copied types</a></h3>
<p>When a place expression is evaluated in a value expression context, or is bound
by value in a pattern, it denotes the value held <em>in</em> that memory location. If
the type of that value implements <a href="special-types-and-traits.html#copy"><code>Copy</code></a>, then the value will be copied. In
the remaining situations if that type is <a href="special-types-and-traits.html#sized"><code>Sized</code></a>, then it may be possible to
move the value. Only the following place expressions may be moved out of:</p>
<ul>
<li><a href="variables.html">Variables</a> which are not currently borrowed.</li>
<li><a href="expressions.html#temporary-lifetimes">Temporary values</a>.</li>
<li><a href="expressions/field-expr.html">Fields</a> of a place expression which can be moved out of and
doesn’t implement <a href="special-types-and-traits.html#drop"><code>Drop</code></a>.</li>
<li>The result of <a href="expressions/operator-expr.html#the-dereference-operator">dereferencing</a> an expression with type <a href="../std/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> and
that can also be moved out of.</li>
</ul>
<p>Moving out of a place expression that evaluates to a local variable, the
location is deinitialized and cannot be read from again until it is
reinitialized. In all other cases, trying to use a place expression in a value
expression context is an error.</p>
<h3><a class="header" href="#mutability" id="mutability">Mutability</a></h3>
<p>For a place expression to be <a href="expressions/operator-expr.html#assignment-expressions">assigned</a> to, mutably <a href="expressions/operator-expr.html#borrow-operators">borrowed</a>,
<a href="expressions.html#implicit-borrows">implicitly mutably borrowed</a>, or bound to a pattern containing <code>ref mut</code> it
must be <em>mutable</em>. We call these <em>mutable place expressions</em>. In contrast,
other place expressions are called <em>immutable place expressions</em>.</p>
<p>The following expressions can be mutable place expression contexts:</p>
<ul>
<li>Mutable <a href="variables.html">variables</a>, which are not currently borrowed.</li>
<li><a href="items/static-items.html#mutable-statics">Mutable <code>static</code> items</a>.</li>
<li><a href="expressions.html#temporary-lifetimes">Temporary values</a>.</li>
<li><a href="expressions/field-expr.html">Fields</a>, this evaluates the subexpression in a mutable place
expression context.</li>
<li><a href="expressions/operator-expr.html#the-dereference-operator">Dereferences</a> of a <code>*mut T</code> pointer.</li>
<li>Dereference of a variable, or field of a variable, with type <code>&amp;mut T</code>. Note:
This is an exception to the requirement of the next rule.</li>
<li>Dereferences of a type that implements <code>DerefMut</code>, this then requires that
the value being dereferenced is evaluated is a mutable place expression context.</li>
<li><a href="expressions/array-expr.html#array-and-slice-indexing-expressions">Array indexing</a> of a type that implements <code>DerefMut</code>, this
then evaluates the value being indexed, but not the index, in mutable place
expression context.</li>
</ul>
<h3><a class="header" href="#temporary-lifetimes" id="temporary-lifetimes">Temporary lifetimes</a></h3>
<p>When using a value expression in most place expression contexts, a temporary
unnamed memory location is created initialized to that value and the expression
evaluates to that location instead, except if promoted to <code>'static</code>. Promotion
of a value expression to a <code>'static</code> slot occurs when the expression could be
written in a constant, borrowed, and dereferencing that borrow where the
expression was originally written, without changing the runtime behavior. That
is, the promoted expression can be evaluated at compile-time and the resulting
value does not contain <a href="interior-mutability.html">interior mutability</a> or <a href="destructors.html">destructors</a> (these properties
are determined based on the value where possible, e.g. <code>&amp;None</code> always has the
type <code>&amp;'static Option&lt;_&gt;</code>, as it contains nothing disallowed). Otherwise, the
lifetime of temporary values is typically</p>
<ul>
<li>the innermost enclosing statement; the tail expression of a block is
considered part of the statement that encloses the block, or</li>
<li>the condition expression or the loop conditional expression if the
temporary is created in the condition expression of an <code>if</code> or in the loop
conditional expression of a <code>while</code> expression.</li>
</ul>
<p>When a temporary value expression is being created that is assigned into a
<a href="statements.html#let-statements"><code>let</code> declaration</a>, however, the temporary is created with the lifetime of
the enclosing block instead, as using the enclosing <a href="statements.html#let-statements"><code>let</code> declaration</a>
would be a guaranteed error (since a pointer to the temporary
would be stored into a variable, but the temporary would be freed before the
variable could be used). The compiler uses simple syntactic rules to decide
which values are being assigned into a <code>let</code> binding, and therefore deserve a
longer temporary lifetime.</p>
<p>Here are some examples:</p>
<ul>
<li><code>let x = foo(&amp;temp())</code>. The expression <code>temp()</code> is a value expression. As it
is being borrowed, a temporary is created which will be freed after
the innermost enclosing statement; in this case, the <code>let</code> declaration.</li>
<li><code>let x = temp().foo()</code>. This is the same as the previous example,
except that the value of <code>temp()</code> is being borrowed via autoref on a
method-call. Here we are assuming that <code>foo()</code> is an <code>&amp;self</code> method
defined in some trait, say <code>Foo</code>. In other words, the expression
<code>temp().foo()</code> is equivalent to <code>Foo::foo(&amp;temp())</code>.</li>
<li><code>let x = if foo(&amp;temp()) {bar()} else {baz()};</code>. The expression <code>temp()</code> is
a value expression. As the temporary is created in the condition expression
of an <code>if</code>, it will be freed at the end of the condition expression;
in this example before the call to <code>bar</code> or <code>baz</code> is made.</li>
<li><code>let x = if temp().must_run_bar {bar()} else {baz()};</code>.
Here we assume the type of <code>temp()</code> is a struct with a boolean field
<code>must_run_bar</code>. As the previous example, the temporary corresponding to
<code>temp()</code> will be freed at the end of the condition expression.</li>
<li><code>while foo(&amp;temp()) {bar();}</code>. The temporary containing the return value from
the call to <code>temp()</code> is created in the loop conditional expression. Hence it
will be freed at the end of the loop conditional expression; in this example
before the call to <code>bar</code> if the loop body is executed.</li>
<li><code>let x = &amp;temp()</code>. Here, the same temporary is being assigned into
<code>x</code>, rather than being passed as a parameter, and hence the
temporary’s lifetime is considered to be the enclosing block.</li>
<li><code>let x = SomeStruct { foo: &amp;temp() }</code>. As in the previous case, the
temporary is assigned into a struct which is then assigned into a
binding, and hence it is given the lifetime of the enclosing block.</li>
<li><code>let x = [ &amp;temp() ]</code>. As in the previous case, the
temporary is assigned into an array which is then assigned into a
binding, and hence it is given the lifetime of the enclosing block.</li>
<li><code>let ref x = temp()</code>. In this case, the temporary is created using a ref
binding, but the result is the same: the lifetime is extended to the enclosing
block.</li>
</ul>
<h3><a class="header" href="#implicit-borrows" id="implicit-borrows">Implicit Borrows</a></h3>
<p>Certain expressions will treat an expression as a place expression by implicitly
borrowing it. For example, it is possible to compare two unsized <a href="types/slice.html">slices</a> for
equality directly, because the <code>==</code> operator implicitly borrows it’s operands:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let c = [1, 2, 3];
</span><span class="boring">let d = vec![1, 2, 3];
</span>let a: &amp;[i32];
let b: &amp;[i32];
<span class="boring">a = &amp;c;
</span><span class="boring">b = &amp;d;
</span>// ...
*a == *b;
// Equivalent form:
::std::cmp::PartialEq::eq(&amp;*a, &amp;*b);
<span class="boring">}
</span></code></pre></pre>
<p>Implicit borrows may be taken in the following expressions:</p>
<ul>
<li>Left operand in <a href="expressions/method-call-expr.html">method-call</a> expressions.</li>
<li>Left operand in <a href="expressions/field-expr.html">field</a> expressions.</li>
<li>Left operand in <a href="expressions/call-expr.html">call expressions</a>.</li>
<li>Left operand in <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">array indexing</a> expressions.</li>
<li>Operand of the <a href="expressions/operator-expr.html#the-dereference-operator">dereference operator</a> (<code>*</code>).</li>
<li>Operands of <a href="expressions/operator-expr.html#comparison-operators">comparison</a>.</li>
<li>Left operands of the <a href="expressions/operator-expr.html#compound-assignment-expressions">compound assignment</a>.</li>
</ul>
<h2><a class="header" href="#overloading-traits" id="overloading-traits">Overloading Traits</a></h2>
<p>Many of the following operators and expressions can also be overloaded for
other types using traits in <code>std::ops</code> or <code>std::cmp</code>. These traits also
exist in <code>core::ops</code> and <code>core::cmp</code> with the same names.</p>
<h2><a class="header" href="#expression-attributes" id="expression-attributes">Expression Attributes</a></h2>
<p><a href="attributes.html">Outer attributes</a> before an expression are allowed only in
a few specific cases:</p>
<ul>
<li>Before an expression used as a <a href="statements.html">statement</a>.</li>
<li>Elements of <a href="expressions/array-expr.html">array expressions</a>, <a href="expressions/tuple-expr.html">tuple expressions</a>, <a href="expressions/call-expr.html">call expressions</a>,
and tuple-style <a href="expressions/struct-expr.html">struct</a> and <a href="expressions/enum-variant-expr.html">enum variant</a> expressions.<!--
  These were likely stabilized inadvertently.
  See https://github.com/rust-lang/rust/issues/32796 and
      https://github.com/rust-lang/rust/issues/15701
-->
</li>
<li>The tail expression of <a href="expressions/block-expr.html">block expressions</a>.</li>
</ul>
<!-- Keep list in sync with block-expr.md -->
<p>They are never allowed before:</p>
<ul>
<li><a href="expressions/if-expr.html#if-expressions"><code>if</code></a> and <a href="expressions/if-expr.html#if-let-expressions"><code>if let</code></a> expressions.</li>
<li><a href="expressions/range-expr.html">Range</a> expressions.</li>
<li>Binary operator expressions (<a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators"><em>ArithmeticOrLogicalExpression</em></a>,
<a href="expressions/operator-expr.html#comparison-operators"><em>ComparisonExpression</em></a>, <a href="expressions/operator-expr.html#lazy-boolean-operators"><em>LazyBooleanExpression</em></a>, <a href="expressions/operator-expr.html#type-cast-expressions"><em>TypeCastExpression</em></a>,
<a href="expressions/operator-expr.html#assignment-expressions"><em>AssignmentExpression</em></a>, <a href="expressions/operator-expr.html#compound-assignment-expressions"><em>CompoundAssignmentExpression</em></a>).</li>
</ul>
<h1><a class="header" href="#literal-expressions" id="literal-expressions">Literal expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>LiteralExpression</em> :<br />
      <a href="expressions/../tokens.html#character-literals">CHAR_LITERAL</a><br />
   | <a href="expressions/../tokens.html#string-literals">STRING_LITERAL</a><br />
   | <a href="expressions/../tokens.html#raw-string-literals">RAW_STRING_LITERAL</a><br />
   | <a href="expressions/../tokens.html#byte-literals">BYTE_LITERAL</a><br />
   | <a href="expressions/../tokens.html#byte-string-literals">BYTE_STRING_LITERAL</a><br />
   | <a href="expressions/../tokens.html#raw-byte-string-literals">RAW_BYTE_STRING_LITERAL</a><br />
   | <a href="expressions/../tokens.html#integer-literals">INTEGER_LITERAL</a><br />
   | <a href="expressions/../tokens.html#floating-point-literals">FLOAT_LITERAL</a><br />
   | <a href="expressions/../tokens.html#boolean-literals">BOOLEAN_LITERAL</a></p>
</blockquote>
<p>A <em>literal expression</em> consists of one of the <a href="expressions/../tokens.html#literals">literal</a>
forms described earlier. It directly describes a number, character, string,
or boolean value.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>&quot;hello&quot;;   // string type
'5';       // character type
5;         // integer type
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#path-expressions" id="path-expressions">Path expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>PathExpression</em> :<br />
      <a href="expressions/../paths.html#paths-in-expressions"><em>PathInExpression</em></a><br />
   | <a href="expressions/../paths.html#qualified-paths"><em>QualifiedPathInExpression</em></a></p>
</blockquote>
<p>A <a href="expressions/../paths.html">path</a> used as an expression context denotes either a local
variable or an item. Path expressions that resolve to local or static variables
are <a href="expressions/../expressions.html#place-expressions-and-value-expressions">place expressions</a>, other paths are <a href="expressions/../expressions.html#place-expressions-and-value-expressions">value expressions</a>. Using a
<a href="expressions/../items/static-items.html#mutable-statics"><code>static mut</code></a> variable requires an <a href="expressions/block-expr.html#unsafe-blocks"><code>unsafe</code> block</a>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">mod globals {
</span><span class="boring">    pub static STATIC_VAR: i32 = 5;
</span><span class="boring">    pub static mut STATIC_MUT_VAR: i32 = 7;
</span><span class="boring">}
</span><span class="boring">let local_var = 3;
</span>local_var;
globals::STATIC_VAR;
unsafe { globals::STATIC_MUT_VAR };
let some_constructor = Some::&lt;i32&gt;;
let push_integer = Vec::&lt;i32&gt;::push;
let slice_reverse = &lt;[i32]&gt;::reverse;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#block-expressions" id="block-expressions">Block expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>BlockExpression</em> :<br />
   <code>{</code><br />
      <a href="expressions/../attributes.html"><em>InnerAttribute</em></a><sup>*</sup><br />
      <em>Statements</em><sup>?</sup><br />
   <code>}</code></p>
<p><em>Statements</em> :<br />
      <a href="expressions/../statements.html"><em>Statement</em></a><sup>+</sup><br />
   | <a href="expressions/../statements.html"><em>Statement</em></a><sup>+</sup> <a href="expressions/../expressions.html"><em>ExpressionWithoutBlock</em></a><br />
   | <a href="expressions/../expressions.html"><em>ExpressionWithoutBlock</em></a></p>
</blockquote>
<p>A <em>block expression</em>, or <em>block</em>, is a control flow expression and anonymous
namespace scope for items and variable declarations. As a control flow
expression, a block sequentially executes its component non-item declaration
statements and then its final optional expression. As an anonymous namespace
scope, item declarations are only in scope inside the block itself and variables
declared by <code>let</code> statements are in scope from the next statement until the end
of the block.</p>
<p>Blocks are written as <code>{</code>, then any <a href="expressions/../attributes.html">inner attributes</a>, then <a href="expressions/../statements.html">statements</a>,
then an optional expression, and finally a <code>}</code>. Statements are usually required
to be followed by a semicolon, with two exceptions. Item declaration statements do
not need to be followed by a semicolon. Expression statements usually require
a following semicolon except if its outer expression is a flow control
expression. Furthermore, extra semicolons between statements are allowed, but
these semicolons do not affect semantics.</p>
<p>When evaluating a block expression, each statement, except for item declaration
statements, is executed sequentially. Then the final expression is executed,
if given.</p>
<p>The type of a block is the type of the final expression, or <code>()</code> if the final
expression is omitted.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">fn fn_call() {}
</span>let _: () = {
    fn_call();
};

let five: i32 = {
    fn_call();
    5
};

assert_eq!(5, five);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: As a control flow expression, if a block expression is the outer
expression of an expression statement, the expected type is <code>()</code> unless it
is followed immediately by a semicolon.</p>
</blockquote>
<p>Blocks are always <a href="expressions/../expressions.html#place-expressions-and-value-expressions">value expressions</a> and evaluate the last expression in
value expression context. This can be used to force moving a value if really
needed. For example, the following example fails on the call to <code>consume_self</code>
because the struct was moved out of <code>s</code> in the block expression.</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Struct;

impl Struct {
    fn consume_self(self) {}
    fn borrow_self(&amp;self) {}
}

fn move_by_block_expression() {
    let s = Struct;

    // Move the value out of `s` in the block expression.
    (&amp;{ s }).borrow_self();

    // Fails to execute because `s` is moved out of.
    s.consume_self();
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#async-blocks" id="async-blocks"><code>async</code> blocks</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>AsyncBlockExpression</em> :<br />
   <code>async</code> <code>move</code><sup>?</sup> <em>BlockExpression</em></p>
</blockquote>
<p>An <em>async block</em> is a variant of a block expression which evaluates to
a <em>future</em>. The final expression of the block, if present, determines
the result value of the future.</p>
<p>Executing an async block is similar to executing a closure expression:
its immediate effect is to produce and return an anonymous type.
Whereas closures return a type that implements one or more of the
<a href="expressions/../../std/ops/trait.Fn.html"><code>std::ops::Fn</code></a> traits, however, the type returned for an async block
implements the <a href="expressions/../../std/future/trait.Future.html"><code>std::future::Future</code></a> trait. The actual data format for
this type is unspecified.</p>
<blockquote>
<p><strong>Note:</strong> The future type that rustc generates is roughly equivalent
to an enum with one variant per <code>await</code> point, where each variant
stores the data needed to resume from its corresponding point.</p>
</blockquote>
<blockquote>
<p><strong>Edition differences</strong>: Async blocks are only available beginning with Rust 2018.</p>
</blockquote>
<h3><a class="header" href="#capture-modes" id="capture-modes">Capture modes</a></h3>
<p>Async blocks capture variables from their environment using the same
<a href="expressions/../types/closure.html#capture-modes">capture modes</a> as closures. Like closures, when written <code>async { .. }</code> the capture mode for each variable will be inferred from the
content of the block. <code>async move { .. }</code> blocks however will move all
referenced variables into the resulting future.</p>
<h3><a class="header" href="#async-context" id="async-context">Async context</a></h3>
<p>Because async blocks construct a future, they define an <strong>async
context</strong> which can in turn contain <a href="expressions/await-expr.html"><code>await</code> expressions</a>.  Async
contexts are established by async blocks as well as the bodies of
async functions, whose semantics are defined in terms of async blocks.</p>
<h3><a class="header" href="#control-flow-operators" id="control-flow-operators">Control-flow operators</a></h3>
<p>Async blocks act like a function boundary, much like
closures. Therefore, the <code>?</code> operator and <code>return</code> expressions both
affect the output of the future, not the enclosing function or other
context. That is, <code>return &lt;expr&gt;</code> from within a closure will return
the result of <code>&lt;expr&gt;</code> as the output of the future. Similarly, if
<code>&lt;expr&gt;?</code> propagates an error, that error is propagated as the result
of the future.</p>
<p>Finally, the <code>break</code> and <code>continue</code> keywords cannot be used to branch
out from an async block. Therefore the following is illegal:</p>
<pre><pre class="playpen"><code class="language-rust edition2018 compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>loop {
    async move {
        break; // This would break out of the loop.
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#unsafe-blocks" id="unsafe-blocks"><code>unsafe</code> blocks</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>UnsafeBlockExpression</em> :<br />
   <code>unsafe</code> <em>BlockExpression</em></p>
</blockquote>
<p><em>See <a href="expressions/../unsafe-blocks.html"><code>unsafe</code> block</a> for more information on when to use <code>unsafe</code></em></p>
<p>A block of code can be prefixed with the <code>unsafe</code> keyword to permit <a href="expressions/../unsafety.html">unsafe
operations</a>. Examples:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>unsafe {
    let b = [13u8, 17u8];
    let a = &amp;b[0] as *const u8;
    assert_eq!(*a, 13);
    assert_eq!(*a.offset(1), 17);
}

<span class="boring">unsafe fn an_unsafe_fn() -&gt; i32 { 10 }
</span>let a = unsafe { an_unsafe_fn() };
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#attributes-on-block-expressions" id="attributes-on-block-expressions">Attributes on block expressions</a></h2>
<p><a href="expressions/../attributes.html">Inner attributes</a> are allowed directly after the opening brace of a block
expression in the following situations:</p>
<ul>
<li><a href="expressions/../items/functions.html">Function</a> and <a href="expressions/../items/associated-items.html#methods">method</a> bodies.</li>
<li>Loop bodies (<a href="expressions/loop-expr.html#infinite-loops"><code>loop</code></a>, <a href="expressions/loop-expr.html#predicate-loops"><code>while</code></a>, <a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a>, and <a href="expressions/loop-expr.html#iterator-loops"><code>for</code></a>).</li>
<li>Block expressions used as a <a href="expressions/../statements.html">statement</a>.</li>
<li>Block expressions as elements of <a href="expressions/array-expr.html">array expressions</a>, <a href="expressions/tuple-expr.html">tuple expressions</a>,
<a href="expressions/call-expr.html">call expressions</a>, and tuple-style <a href="expressions/struct-expr.html">struct</a> and <a href="expressions/enum-variant-expr.html">enum variant</a> expressions.</li>
<li>A block expression as the tail expression of another block expression.</li>
</ul>
<!-- Keep list in sync with expressions.md -->
<p>The attributes that have meaning on a block expression are <a href="expressions/../conditional-compilation.html"><code>cfg</code></a> and <a href="expressions/../attributes/diagnostics.html#lint-check-attributes">the
lint check attributes</a>.</p>
<p>For example, this function returns <code>true</code> on unix platforms and <code>false</code> on other
platforms.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn is_unix_platform() -&gt; bool {
    #[cfg(unix)] { true }
    #[cfg(not(unix))] { false }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#operator-expressions" id="operator-expressions">Operator expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>OperatorExpression</em> :<br />
      <a href="expressions/operator-expr.html#borrow-operators"><em>BorrowExpression</em></a><br />
   | <a href="expressions/operator-expr.html#the-dereference-operator"><em>DereferenceExpression</em></a><br />
   | <a href="expressions/operator-expr.html#the-question-mark-operator"><em>ErrorPropagationExpression</em></a><br />
   | <a href="expressions/operator-expr.html#negation-operators"><em>NegationExpression</em></a><br />
   | <a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators"><em>ArithmeticOrLogicalExpression</em></a><br />
   | <a href="expressions/operator-expr.html#comparison-operators"><em>ComparisonExpression</em></a><br />
   | <a href="expressions/operator-expr.html#lazy-boolean-operators"><em>LazyBooleanExpression</em></a><br />
   | <a href="expressions/operator-expr.html#type-cast-expressions"><em>TypeCastExpression</em></a><br />
   | <a href="expressions/operator-expr.html#assignment-expressions"><em>AssignmentExpression</em></a><br />
   | <a href="expressions/operator-expr.html#compound-assignment-expressions"><em>CompoundAssignmentExpression</em></a></p>
</blockquote>
<p>Operators are defined for built in types by the Rust language. Many of the
following operators can also be overloaded using traits in <code>std::ops</code> or
<code>std::cmp</code>.</p>
<h2><a class="header" href="#overflow" id="overflow">Overflow</a></h2>
<p>Integer operators will panic when they overflow when compiled in debug mode.
The <code>-C debug-assertions</code> and <code>-C overflow-checks</code> compiler flags can be used
to control this more directly. The following things are considered to be
overflow:</p>
<ul>
<li>When <code>+</code>, <code>*</code> or <code>-</code> create a value greater than the maximum value, or less
than the minimum value that can be stored. This includes unary <code>-</code> on the
smallest value of any signed integer type.</li>
<li>Using <code>/</code> or <code>%</code>, where the left-hand argument is the smallest integer of a
signed integer type and the right-hand argument is <code>-1</code>.</li>
<li>Using <code>&lt;&lt;</code> or <code>&gt;&gt;</code> where the right-hand argument is greater than or equal to
the number of bits in the type of the left-hand argument, or is negative.</li>
</ul>
<h2><a class="header" href="#borrow-operators" id="borrow-operators">Borrow operators</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>BorrowExpression</em> :<br />
      (<code>&amp;</code>|<code>&amp;&amp;</code>) <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | (<code>&amp;</code>|<code>&amp;&amp;</code>) <code>mut</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
</blockquote>
<p>The <code>&amp;</code> (shared borrow) and <code>&amp;mut</code> (mutable borrow) operators are unary prefix
operators. When applied to a <a href="expressions/../expressions.html#place-expressions-and-value-expressions">place expression</a>, this expressions produces a
reference (pointer) to the location that the value refers to. The memory
location is also placed into a borrowed state for the duration of the reference.
For a shared borrow (<code>&amp;</code>), this implies that the place may not be mutated, but
it may be read or shared again. For a mutable borrow (<code>&amp;mut</code>), the place may not
be accessed in any way until the borrow expires. <code>&amp;mut</code> evaluates its operand in
a mutable place expression context. If the <code>&amp;</code> or <code>&amp;mut</code> operators are applied
to a <a href="expressions/../expressions.html#place-expressions-and-value-expressions">value expression</a>, then a <a href="expressions/../expressions.html#temporary-lifetimes">temporary value</a> is created.</p>
<p>These operators cannot be overloaded.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>{
    // a temporary with value 7 is created that lasts for this scope.
    let shared_reference = &amp;7;
}
let mut array = [-2, 3, 9];
{
    // Mutably borrows `array` for this scope.
    // `array` may only be used through `mutable_reference`.
    let mutable_reference = &amp;mut array;
}
<span class="boring">}
</span></code></pre></pre>
<p>Even though <code>&amp;&amp;</code> is a single token (<a href="expressions/operator-expr.html#lazy-boolean-operators">the lazy ‘and’ operator</a>),
when used in the context of borrow expressions it works as two borrows:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// same meanings:
let a = &amp;&amp;  10;
let a = &amp; &amp; 10;

// same meanings:
let a = &amp;&amp;&amp;&amp;  mut 10;
let a = &amp;&amp; &amp;&amp; mut 10;
let a = &amp; &amp; &amp; &amp; mut 10;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#the-dereference-operator" id="the-dereference-operator">The dereference operator</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>DereferenceExpression</em> :<br />
   <code>*</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
</blockquote>
<p>The <code>*</code> (dereference) operator is also a unary prefix operator. When applied to
a <a href="expressions/../types/pointer.html">pointer</a> it denotes the pointed-to location. If
the expression is of type <code>&amp;mut T</code> and <code>*mut T</code>, and is either a local
variable, a (nested) field of a local variable or is a mutable <a href="expressions/../expressions.html#place-expressions-and-value-expressions">place
expression</a>, then the resulting memory location can be assigned to.
Dereferencing a raw pointer requires <code>unsafe</code>.</p>
<p>On non-pointer types <code>*x</code> is equivalent to <code>*std::ops::Deref::deref(&amp;x)</code> in an
<a href="expressions/../expressions.html#mutability">immutable place expression context</a> and
<code>*std::ops::DerefMut::deref_mut(&amp;mut x)</code> in a mutable place expression context.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = &amp;7;
assert_eq!(*x, 7);
let y = &amp;mut 9;
*y = 11;
assert_eq!(*y, 11);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#the-question-mark-operator" id="the-question-mark-operator">The question mark operator</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ErrorPropagationExpression</em> :<br />
   <a href="expressions/../expressions.html"><em>Expression</em></a> <code>?</code></p>
</blockquote>
<p>The question mark operator (<code>?</code>) unwraps valid values or returns erroneous
values, propagating them to the calling function. It is a unary postfix
operator that can only be applied to the types <code>Result&lt;T, E&gt;</code> and <code>Option&lt;T&gt;</code>.</p>
<p>When applied to values of the <code>Result&lt;T, E&gt;</code> type, it propagates errors. If
the value is <code>Err(e)</code>, then it will return <code>Err(From::from(e))</code> from the
enclosing function or closure. If applied to <code>Ok(x)</code>, then it will unwrap the
value to evaluate to <code>x</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::num::ParseIntError;
</span>fn try_to_parse() -&gt; Result&lt;i32, ParseIntError&gt; {
    let x: i32 = &quot;123&quot;.parse()?; // x = 123
    let y: i32 = &quot;24a&quot;.parse()?; // returns an Err() immediately
    Ok(x + y)                    // Doesn't run.
}

let res = try_to_parse();
println!(&quot;{:?}&quot;, res);
<span class="boring">assert!(res.is_err())
</span><span class="boring">}
</span></code></pre></pre>
<p>When applied to values of the <code>Option&lt;T&gt;</code> type, it propagates <code>None</code>s. If the
value is <code>None</code>, then it will return <code>None</code>. If applied to <code>Some(x)</code>, then it
will unwrap the value to evaluate to <code>x</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn try_option_some() -&gt; Option&lt;u8&gt; {
    let val = Some(1)?;
    Some(val)
}
assert_eq!(try_option_some(), Some(1));

fn try_option_none() -&gt; Option&lt;u8&gt; {
    let val = None?;
    Some(val)
}
assert_eq!(try_option_none(), None);
<span class="boring">}
</span></code></pre></pre>
<p><code>?</code> cannot be overloaded.</p>
<h2><a class="header" href="#negation-operators" id="negation-operators">Negation operators</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>NegationExpression</em> :<br />
      <code>-</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <code>!</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
</blockquote>
<p>These are the last two unary operators. This table summarizes the behavior of
them on primitive types and which traits are used to overload these operators
for other types. Remember that signed integers are always represented using
two’s complement. The operands of all of these operators are evaluated in
<a href="expressions/../expressions.html#place-expressions-and-value-expressions">value expression context</a> so are moved or copied.</p>
<table><thead><tr><th>Symbol</th><th>Integer</th><th><code>bool</code></th><th>Floating Point</th><th>Overloading Trait</th></tr></thead><tbody>
<tr><td><code>-</code></td><td>Negation*</td><td></td><td>Negation</td><td><code>std::ops::Neg</code></td></tr>
<tr><td><code>!</code></td><td>Bitwise NOT</td><td>Logical NOT</td><td></td><td><code>std::ops::Not</code></td></tr>
</tbody></table>
<p>* Only for signed integer types.</p>
<p>Here are some example of these operators</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 6;
assert_eq!(-x, -6);
assert_eq!(!x, -7);
assert_eq!(true, !false);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#arithmetic-and-logical-binary-operators" id="arithmetic-and-logical-binary-operators">Arithmetic and Logical Binary Operators</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ArithmeticOrLogicalExpression</em> :<br />
      <a href="expressions/../expressions.html"><em>Expression</em></a> <code>+</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>-</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>*</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>/</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>%</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>&amp;</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>|</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>^</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>&lt;&lt;</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>&gt;&gt;</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
</blockquote>
<p>Binary operators expressions are all written with infix notation. This table
summarizes the behavior of arithmetic and logical binary operators on
primitive types and which traits are used to overload these operators for other
types. Remember that signed integers are always represented using two’s
complement. The operands of all of these operators are evaluated in <a href="expressions/../expressions.html#place-expressions-and-value-expressions">value
expression context</a> so are moved or copied.</p>
<table><thead><tr><th>Symbol</th><th>Integer</th><th><code>bool</code></th><th>Floating Point</th><th>Overloading Trait</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>Addition</td><td></td><td>Addition</td><td><code>std::ops::Add</code></td></tr>
<tr><td><code>-</code></td><td>Subtraction</td><td></td><td>Subtraction</td><td><code>std::ops::Sub</code></td></tr>
<tr><td><code>*</code></td><td>Multiplication</td><td></td><td>Multiplication</td><td><code>std::ops::Mul</code></td></tr>
<tr><td><code>/</code></td><td>Division*</td><td></td><td>Division</td><td><code>std::ops::Div</code></td></tr>
<tr><td><code>%</code></td><td>Remainder</td><td></td><td>Remainder</td><td><code>std::ops::Rem</code></td></tr>
<tr><td><code>&amp;</code></td><td>Bitwise AND</td><td>Logical AND</td><td></td><td><code>std::ops::BitAnd</code></td></tr>
<tr><td><code>|</code></td><td>Bitwise OR</td><td>Logical OR</td><td></td><td><code>std::ops::BitOr</code></td></tr>
<tr><td><code>^</code></td><td>Bitwise XOR</td><td>Logical XOR</td><td></td><td><code>std::ops::BitXor</code></td></tr>
<tr><td><code>&lt;&lt;</code></td><td>Left Shift</td><td></td><td></td><td><code>std::ops::Shl</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td>Right Shift**</td><td></td><td></td><td><code>std::ops::Shr</code></td></tr>
</tbody></table>
<p>* Integer division rounds towards zero.</p>
<p>** Arithmetic right shift on signed integer types, logical right shift on
unsigned integer types.</p>
<p>Here are examples of these operators being used.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>assert_eq!(3 + 6, 9);
assert_eq!(5.5 - 1.25, 4.25);
assert_eq!(-5 * 14, -70);
assert_eq!(14 / 3, 4);
assert_eq!(100 % 7, 2);
assert_eq!(0b1010 &amp; 0b1100, 0b1000);
assert_eq!(0b1010 | 0b1100, 0b1110);
assert_eq!(0b1010 ^ 0b1100, 0b110);
assert_eq!(13 &lt;&lt; 3, 104);
assert_eq!(-10 &gt;&gt; 2, -3);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#comparison-operators" id="comparison-operators">Comparison Operators</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ComparisonExpression</em> :<br />
      <a href="expressions/../expressions.html"><em>Expression</em></a> <code>==</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>!=</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>&gt;</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>&lt;</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>&gt;=</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>&lt;=</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
</blockquote>
<p>Comparison operators are also defined both for primitive types and many type in
the standard library. Parentheses are required when chaining comparison
operators. For example, the expression <code>a == b == c</code> is invalid and may be
written as <code>(a == b) == c</code>.</p>
<p>Unlike arithmetic and logical operators, the traits for
overloading the operators the traits for these operators are used more
generally to show how a type may be compared and will likely be assumed to
define actual comparisons by functions that use these traits as bounds. Many
functions and macros in the standard library can then use that assumption
(although not to ensure safety). Unlike the arithmetic and logical operators
above, these operators implicitly take shared borrows of their operands,
evaluating them in <a href="expressions/../expressions.html#place-expressions-and-value-expressions">place expression context</a>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let a = 1;
</span><span class="boring">let b = 1;
</span>a == b;
// is equivalent to
::std::cmp::PartialEq::eq(&amp;a, &amp;b);
<span class="boring">}
</span></code></pre></pre>
<p>This means that the operands don’t have to be moved out of.</p>
<table><thead><tr><th>Symbol</th><th>Meaning</th><th>Overloading method</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>Equal</td><td><code>std::cmp::PartialEq::eq</code></td></tr>
<tr><td><code>!=</code></td><td>Not equal</td><td><code>std::cmp::PartialEq::ne</code></td></tr>
<tr><td><code>&gt;</code></td><td>Greater than</td><td><code>std::cmp::PartialOrd::gt</code></td></tr>
<tr><td><code>&lt;</code></td><td>Less than</td><td><code>std::cmp::PartialOrd::lt</code></td></tr>
<tr><td><code>&gt;=</code></td><td>Greater than or equal to</td><td><code>std::cmp::PartialOrd::ge</code></td></tr>
<tr><td><code>&lt;=</code></td><td>Less than or equal to</td><td><code>std::cmp::PartialOrd::le</code></td></tr>
</tbody></table>
<p>Here are examples of the comparison operators being used.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>assert!(123 == 123);
assert!(23 != -12);
assert!(12.5 &gt; 12.2);
assert!([1, 2, 3] &lt; [1, 3, 4]);
assert!('A' &lt;= 'B');
assert!(&quot;World&quot; &gt;= &quot;Hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#lazy-boolean-operators" id="lazy-boolean-operators">Lazy boolean operators</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>LazyBooleanExpression</em> :<br />
      <a href="expressions/../expressions.html"><em>Expression</em></a> <code>||</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>&amp;&amp;</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
</blockquote>
<p>The operators <code>||</code> and <code>&amp;&amp;</code> may be applied to operands of boolean type. The
<code>||</code> operator denotes logical ‘or’, and the <code>&amp;&amp;</code> operator denotes logical
‘and’. They differ from <code>|</code> and <code>&amp;</code> in that the right-hand operand is only
evaluated when the left-hand operand does not already determine the result of
the expression. That is, <code>||</code> only evaluates its right-hand operand when the
left-hand operand evaluates to <code>false</code>, and <code>&amp;&amp;</code> only when it evaluates to
<code>true</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = false || true; // true
let y = false &amp;&amp; panic!(); // false, doesn't evaluate `panic!()`
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#type-cast-expressions" id="type-cast-expressions">Type cast expressions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>TypeCastExpression</em> :<br />
   <a href="expressions/../expressions.html"><em>Expression</em></a> <code>as</code> <a href="expressions/../types.html#type-expressions"><em>TypeNoBounds</em></a></p>
</blockquote>
<p>A type cast expression is denoted with the binary operator <code>as</code>.</p>
<p>Executing an <code>as</code> expression casts the value on the left-hand side to the type
on the right-hand side.</p>
<p>An example of an <code>as</code> expression:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">fn sum(values: &amp;[f64]) -&gt; f64 { 0.0 }
</span><span class="boring">fn len(values: &amp;[f64]) -&gt; i32 { 0 }
</span>fn average(values: &amp;[f64]) -&gt; f64 {
    let sum: f64 = sum(values);
    let size: f64 = len(values) as f64;
    sum / size
}
<span class="boring">}
</span></code></pre></pre>
<p><code>as</code> can be used to explicitly perform <a href="expressions/../type-coercions.html">coercions</a>, as
well as the following additional casts. Here <code>*T</code> means either <code>*const T</code> or
<code>*mut T</code>.</p>
<table><thead><tr><th>Type of <code>e</code></th><th><code>U</code></th><th>Cast performed by <code>e as U</code></th></tr></thead><tbody>
<tr><td>Integer or Float type</td><td>Integer or Float type</td><td>Numeric cast</td></tr>
<tr><td>C-like enum</td><td>Integer type</td><td>Enum cast</td></tr>
<tr><td><code>bool</code> or <code>char</code></td><td>Integer type</td><td>Primitive to integer cast</td></tr>
<tr><td><code>u8</code></td><td><code>char</code></td><td><code>u8</code> to <code>char</code> cast</td></tr>
<tr><td><code>*T</code></td><td><code>*V</code> where <code>V: Sized</code> *</td><td>Pointer to pointer cast</td></tr>
<tr><td><code>*T</code> where <code>T: Sized</code></td><td>Numeric type</td><td>Pointer to address cast</td></tr>
<tr><td>Integer type</td><td><code>*V</code> where <code>V: Sized</code></td><td>Address to pointer cast</td></tr>
<tr><td><code>&amp;[T; n]</code></td><td><code>*const T</code></td><td>Array to pointer cast</td></tr>
<tr><td><a href="expressions/../types/function-pointer.html">Function pointer</a></td><td><code>*V</code> where <code>V: Sized</code></td><td>Function pointer to pointer cast</td></tr>
<tr><td>Function pointer</td><td>Integer</td><td>Function pointer to address cast</td></tr>
<tr><td>Closure **</td><td>Function pointer</td><td>Closure to function pointer cast</td></tr>
</tbody></table>
<p>* or <code>T</code> and <code>V</code> are compatible unsized types, e.g., both slices, both the
same trait object.</p>
<p>** only for closures that do not capture (close over) any local variables</p>
<h3><a class="header" href="#semantics" id="semantics">Semantics</a></h3>
<ul>
<li>Numeric cast
<ul>
<li>Casting between two integers of the same size (e.g. i32 -&gt; u32) is a no-op</li>
<li>Casting from a larger integer to a smaller integer (e.g. u32 -&gt; u8) will
truncate</li>
<li>Casting from a smaller integer to a larger integer (e.g. u8 -&gt; u32) will
<ul>
<li>zero-extend if the source is unsigned</li>
<li>sign-extend if the source is signed</li>
</ul>
</li>
<li>Casting from a float to an integer will round the float towards zero
<ul>
<li><strong><a href="https://github.com/rust-lang/rust/issues/10184">NOTE: currently this will cause Undefined Behavior if the rounded
value cannot be represented by the target integer type</a></strong>.
This includes Inf and NaN. This is a bug and will be fixed.</li>
</ul>
</li>
<li>Casting from an integer to float will produce the closest possible float *
<ul>
<li>if necessary, rounding is according to <code>roundTiesToEven</code> mode ***</li>
<li>on overflow, infinity (of the same sign as the input) is produced</li>
<li>note: with the current set of numeric types, overflow can only happen
on <code>u128 as f32</code> for values greater or equal to <code>f32::MAX + (0.5 ULP)</code></li>
</ul>
</li>
<li>Casting from an f32 to an f64 is perfect and lossless</li>
<li>Casting from an f64 to an f32 will produce the closest possible f32 **
<ul>
<li>if necessary, rounding is according to <code>roundTiesToEven</code> mode ***</li>
<li>on overflow, infinity (of the same sign as the input) is produced</li>
</ul>
</li>
</ul>
</li>
<li>Enum cast
<ul>
<li>Casts an enum to its discriminant, then uses a numeric cast if needed.</li>
</ul>
</li>
<li>Primitive to integer cast
<ul>
<li><code>false</code> casts to <code>0</code>, <code>true</code> casts to <code>1</code></li>
<li><code>char</code> casts to the value of the code point, then uses a numeric cast if needed.</li>
</ul>
</li>
<li><code>u8</code> to <code>char</code> cast
<ul>
<li>Casts to the <code>char</code> with the corresponding code point.</li>
</ul>
</li>
</ul>
<p>* if integer-to-float casts with this rounding mode and overflow behavior are
not supported natively by the hardware, these casts will likely be slower than
expected.</p>
<p>** if f64-to-f32 casts with this rounding mode and overflow behavior are not
supported natively by the hardware, these casts will likely be slower than
expected.</p>
<p>*** as defined in IEEE 754-2008 §4.3.1: pick the nearest floating point
number, preferring the one with an even least significant digit if exactly
halfway between two floating point numbers.</p>
<h2><a class="header" href="#assignment-expressions" id="assignment-expressions">Assignment expressions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>AssignmentExpression</em> :<br />
   <a href="expressions/../expressions.html"><em>Expression</em></a> <code>=</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
</blockquote>
<p>An <em>assignment expression</em> consists of a <a href="expressions/../expressions.html#place-expressions-and-value-expressions">place expression</a> followed by an
equals sign (<code>=</code>) and a <a href="expressions/../expressions.html#place-expressions-and-value-expressions">value expression</a>. Such an expression always has
the <a href="expressions/../types/tuple.html"><code>unit</code> type</a>.</p>
<p>Evaluating an assignment expression <a href="expressions/../destructors.html">drops</a> the left-hand
operand, unless it’s an uninitialized local variable or field of a local variable,
and <a href="expressions/../expressions.html#moved-and-copied-types">either copies or moves</a> its
right-hand operand to its left-hand operand. The left-hand operand must be a
place expression: using a value expression results in a compiler error, rather
than promoting it to a temporary.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut x = 0;
</span><span class="boring">let y = 0;
</span>x = y;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#compound-assignment-expressions" id="compound-assignment-expressions">Compound assignment expressions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>CompoundAssignmentExpression</em> :<br />
      <a href="expressions/../expressions.html"><em>Expression</em></a> <code>+=</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>-=</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>*=</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>/=</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>%=</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>&amp;=</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>|=</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>^=</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>&lt;&lt;=</code> <a href="expressions/../expressions.html"><em>Expression</em></a><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>&gt;&gt;=</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
</blockquote>
<p>The <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, and <code>&gt;&gt;</code> operators may be
composed with the <code>=</code> operator. The expression <code>place_exp OP= value</code> is
equivalent to <code>place_expr = place_expr OP val</code>. For example, <code>x = x + 1</code> may be
written as <code>x += 1</code>. Any such expression always has the <a href="expressions/../types/tuple.html"><code>unit</code> type</a>.
These operators can all be overloaded using the trait with the same name as for
the normal operation followed by ‘Assign’, for example, <code>std::ops::AddAssign</code>
is used to overload <code>+=</code>. As with <code>=</code>, <code>place_expr</code> must be a <a href="expressions/../expressions.html#place-expressions-and-value-expressions">place
expression</a>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut x = 10;
x += 4;
assert_eq!(x, 14);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#grouped-expressions" id="grouped-expressions">Grouped expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>GroupedExpression</em> :<br />
   <code>(</code> <a href="expressions/../attributes.html"><em>InnerAttribute</em></a><sup>*</sup> <a href="expressions/../expressions.html"><em>Expression</em></a> <code>)</code></p>
</blockquote>
<p>An expression enclosed in parentheses evaluates to the result of the enclosed
expression. Parentheses can be used to explicitly specify evaluation order
within an expression.</p>
<p>An example of a parenthesized expression:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x: i32 = 2 + 3 * 4;
let y: i32 = (2 + 3) * 4;
assert_eq!(x, 14);
assert_eq!(y, 20);
<span class="boring">}
</span></code></pre></pre>
<p>An example of a necessary use of parentheses is when calling a function pointer
that is a member of a struct:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct A {
</span><span class="boring">   f: fn() -&gt; &amp;'static str
</span><span class="boring">}
</span><span class="boring">impl A {
</span><span class="boring">   fn f(&amp;self) -&gt; &amp;'static str {
</span><span class="boring">       &quot;The method f&quot;
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let a = A{f: || &quot;The field f&quot;};
</span><span class="boring">
</span>assert_eq!( a.f (), &quot;The method f&quot;);
assert_eq!((a.f)(), &quot;The field f&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#group-expression-attributes" id="group-expression-attributes">Group expression attributes</a></h2>
<p><a href="expressions/../attributes.html">Inner attributes</a> are allowed directly after the opening parenthesis of a
group expression in the same expression contexts as <a href="expressions/block-expr.html#attributes-on-block-expressions">attributes on block
expressions</a>.</p>
<h1><a class="header" href="#array-and-array-index-expressions" id="array-and-array-index-expressions">Array and array index expressions</a></h1>
<h2><a class="header" href="#array-expressions" id="array-expressions">Array expressions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ArrayExpression</em> :<br />
   <code>[</code> <a href="expressions/../attributes.html"><em>InnerAttribute</em></a><sup>*</sup> <em>ArrayElements</em><sup>?</sup> <code>]</code></p>
<p><em>ArrayElements</em> :<br />
      <a href="expressions/../expressions.html"><em>Expression</em></a> ( <code>,</code> <a href="expressions/../expressions.html"><em>Expression</em></a> )<sup>*</sup> <code>,</code><sup>?</sup><br />
   | <a href="expressions/../expressions.html"><em>Expression</em></a> <code>;</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
</blockquote>
<p>An <em><a href="expressions/../types/array.html">array</a> expression</em> can be written by
enclosing zero or more comma-separated expressions of uniform type in square
brackets. This produces an array containing each of these values in the
order they are written.</p>
<p>Alternatively there can be exactly two expressions inside the brackets,
separated by a semi-colon. The expression after the <code>;</code> must be a have type
<code>usize</code> and be a <a href="expressions/../const_eval.html#constant-expressions">constant expression</a>,
such as a <a href="expressions/../tokens.html#literals">literal</a> or a <a href="expressions/../items/constant-items.html">constant
item</a>. <code>[a; b]</code> creates an array containing <code>b</code>
copies of the value of <code>a</code>. If the expression after the semi-colon has a value
greater than 1 then this requires that the type of <code>a</code> is
<a href="expressions/../special-types-and-traits.html#copy"><code>Copy</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>[1, 2, 3, 4];
[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];
[0; 128];              // array with 128 zeros
[0u8, 0u8, 0u8, 0u8,];
[[1, 0, 0], [0, 1, 0], [0, 0, 1]]; // 2D array
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#array-expression-attributes" id="array-expression-attributes">Array expression attributes</a></h3>
<p><a href="expressions/../attributes.html">Inner attributes</a> are allowed directly after the opening bracket of an array
expression in the same expression contexts as <a href="expressions/block-expr.html#attributes-on-block-expressions">attributes on block
expressions</a>.</p>
<h2><a class="header" href="#array-and-slice-indexing-expressions" id="array-and-slice-indexing-expressions">Array and slice indexing expressions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>IndexExpression</em> :<br />
   <a href="expressions/../expressions.html"><em>Expression</em></a> <code>[</code> <a href="expressions/../expressions.html"><em>Expression</em></a> <code>]</code></p>
</blockquote>
<p><a href="expressions/../types/array.html">Array</a> and <a href="expressions/../types/slice.html">slice</a>-typed expressions can be
indexed by writing a square-bracket-enclosed expression of type <code>usize</code> (the
index) after them. When the array is mutable, the resulting <a href="expressions/../expressions.html#place-expressions-and-value-expressions">memory location</a>
can be assigned to.</p>
<p>For other types an index expression <code>a[b]</code> is equivalent to
<code>*std::ops::Index::index(&amp;a, b)</code>, or
<code>*std::ops::IndexMut::index_mut(&amp;mut a, b)</code> in a mutable place expression
context. Just as with methods, Rust will also insert dereference operations on
<code>a</code> repeatedly to find an implementation.</p>
<p>Indices are zero-based for arrays and slices. Array access is a <a href="expressions/../const_eval.html#constant-expressions">constant
expression</a>, so bounds can be checked at compile-time with a constant index
value. Otherwise a check will be performed at run-time that will put the thread
in a <em>panicked state</em> if it fails.</p>
<pre><pre class="playpen"><code class="language-rust should_panic">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// lint is deny by default.
#![warn(unconditional_panic)]

([1, 2, 3, 4])[2];        // Evaluates to 3

let b = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
b[1][2];                  // multidimensional array indexing

let x = ([&quot;a&quot;, &quot;b&quot;])[10]; // warning: index out of bounds

let n = 10;
let y = ([&quot;a&quot;, &quot;b&quot;])[n];  // panics

let arr = [&quot;a&quot;, &quot;b&quot;];
arr[10];                  // warning: index out of bounds
<span class="boring">}
</span></code></pre></pre>
<p>The array index expression can be implemented for types other than arrays and slices
by implementing the <a href="expressions/../../std/ops/trait.Index.html">Index</a> and <a href="expressions/../../std/ops/trait.IndexMut.html">IndexMut</a> traits.</p>
<h1><a class="header" href="#tuple-and-tuple-indexing-expressions" id="tuple-and-tuple-indexing-expressions">Tuple and tuple indexing expressions</a></h1>
<h2><a class="header" href="#tuple-expressions" id="tuple-expressions">Tuple expressions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>TupleExpression</em> :<br />
   <code>(</code> <a href="expressions/../attributes.html"><em>InnerAttribute</em></a><sup>*</sup> <em>TupleElements</em><sup>?</sup> <code>)</code></p>
<p><em>TupleElements</em> :<br />
   ( <a href="expressions/../expressions.html"><em>Expression</em></a> <code>,</code> )<sup>+</sup> <a href="expressions/../expressions.html"><em>Expression</em></a><sup>?</sup></p>
</blockquote>
<p>Tuples are written by enclosing zero or more comma-separated expressions in
parentheses. They are used to create <a href="expressions/../types/tuple.html">tuple-typed</a>
values.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>(0.0, 4.5);
(&quot;a&quot;, 4usize, true);
();
<span class="boring">}
</span></code></pre></pre>
<p>You can disambiguate a single-element tuple from a value in parentheses with a
comma:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>(0,); // single-element tuple
(0); // zero in parentheses
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#tuple-expression-attributes" id="tuple-expression-attributes">Tuple expression attributes</a></h3>
<p><a href="expressions/../attributes.html">Inner attributes</a> are allowed directly after the opening parenthesis of a
tuple expression in the same expression contexts as <a href="expressions/block-expr.html#attributes-on-block-expressions">attributes on block
expressions</a>.</p>
<h2><a class="header" href="#tuple-indexing-expressions" id="tuple-indexing-expressions">Tuple indexing expressions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>TupleIndexingExpression</em> :<br />
   <a href="expressions/../expressions.html"><em>Expression</em></a> <code>.</code> <a href="expressions/../tokens.html#integer-literals">TUPLE_INDEX</a></p>
</blockquote>
<p><a href="expressions/../types/tuple.html">Tuples</a> and <a href="expressions/../items/structs.html">struct tuples</a> can be
indexed using the number corresponding to the position of the field. The index
must be written as a <a href="expressions/../tokens.html#integer-literals">decimal literal</a> with no
underscores or suffix. Tuple indexing expressions also differ from field
expressions in that they can unambiguously be called as a function. In all
other aspects they have the same behavior.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point(f32, f32);
</span>let pair = (1, 2);
assert_eq!(pair.1, 2);
let unit_x = Point(1.0, 0.0);
assert_eq!(unit_x.0, 1.0);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#struct-expressions" id="struct-expressions">Struct expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>StructExpression</em> :<br />
      <em>StructExprStruct</em><br />
   | <em>StructExprTuple</em><br />
   | <em>StructExprUnit</em></p>
<p><em>StructExprStruct</em> :<br />
   <a href="expressions/../paths.html#paths-in-expressions"><em>PathInExpression</em></a> <code>{</code> <a href="expressions/../attributes.html"><em>InnerAttribute</em></a><sup>*</sup> (<em>StructExprFields</em> | <em>StructBase</em>)<sup>?</sup> <code>}</code></p>
<p><em>StructExprFields</em> :<br />
   <em>StructExprField</em> (<code>,</code> <em>StructExprField</em>)<sup>*</sup> (<code>,</code> <em>StructBase</em> | <code>,</code><sup>?</sup>)</p>
<p><em>StructExprField</em> :<br />
      <a href="expressions/../identifiers.html">IDENTIFIER</a><br />
   | (<a href="expressions/../identifiers.html">IDENTIFIER</a> | <a href="expressions/../tokens.html#integer-literals">TUPLE_INDEX</a>) <code>:</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
<p><em>StructBase</em> :<br />
   <code>..</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
<p><em>StructExprTuple</em> :<br />
   <a href="expressions/../paths.html#paths-in-expressions"><em>PathInExpression</em></a> <code>(</code><br />
      <a href="expressions/../attributes.html"><em>InnerAttribute</em></a><sup>*</sup><br />
      ( <a href="expressions/../expressions.html"><em>Expression</em></a> (<code>,</code> <a href="expressions/../expressions.html"><em>Expression</em></a>)<sup>*</sup> <code>,</code><sup>?</sup> )<sup>?</sup><br />
   <code>)</code></p>
<p><em>StructExprUnit</em> : <a href="expressions/../paths.html#paths-in-expressions"><em>PathInExpression</em></a></p>
</blockquote>
<p>A <em>struct expression</em> creates a struct or union value. It consists of a path to a <a href="expressions/../items/structs.html">struct</a>
or <a href="expressions/../items/unions.html">union</a> item followed by the values for the fields of the item. There are three forms
of struct expressions: struct, tuple, and unit.</p>
<p>The following are examples of struct expressions:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point { x: f64, y: f64 }
</span><span class="boring">struct NothingInMe { }
</span><span class="boring">struct TuplePoint(f64, f64);
</span><span class="boring">mod game { pub struct User&lt;'a&gt; { pub name: &amp;'a str, pub age: u32, pub score: usize } }
</span><span class="boring">struct Cookie; fn some_fn&lt;T&gt;(t: T) {}
</span>Point {x: 10.0, y: 20.0};
NothingInMe {};
TuplePoint(10.0, 20.0);
TuplePoint { 0: 10.0, 1: 20.0 }; // Results in the same value as the above line
let u = game::User {name: &quot;Joe&quot;, age: 35, score: 100_000};
some_fn::&lt;Cookie&gt;(Cookie);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#field-struct-expression" id="field-struct-expression">Field struct expression</a></h2>
<p>A struct expression with fields enclosed in curly braces allows you to specify the value
for each individual field in any order. The field name is separated from its value with a
colon.</p>
<p>A value of a <a href="expressions/../items/unions.html">union</a> type can also be created using this syntax, except that it must
specify exactly one field.</p>
<h2><a class="header" href="#functional-update-syntax" id="functional-update-syntax">Functional update syntax</a></h2>
<p>A struct expression can terminate with the syntax <code>..</code> followed by an
expression to denote a functional update. The expression following <code>..</code> (the
base) must have the same struct type as the new struct type being formed.</p>
<p>The entire expression uses the given values for the fields that were specified
and moves or copies the remaining fields from the base expression. As with all
struct expressions, all of the fields of the struct must be <a href="expressions/../visibility-and-privacy.html">visible</a>, even
those not explicitly named.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point3d { x: i32, y: i32, z: i32 }
</span>let mut base = Point3d {x: 1, y: 2, z: 3};
let y_ref = &amp;mut base.y;
Point3d {y: 0, z: 10, .. base}; // OK, only base.x is accessed
drop(y_ref);
<span class="boring">}
</span></code></pre></pre>
<p>Struct expressions with curly braces can’t be used directly in a <a href="expressions/loop-expr.html">loop</a> or <a href="expressions/if-expr.html#if-expressions">if</a>
expression’s head, or in the <a href="expressions/../glossary.html#scrutinee">scrutinee</a> of an <a href="expressions/if-expr.html#if-let-expressions">if let</a> or <a href="expressions/match-expr.html">match</a> expression.
However, struct expressions can be in used in these situations if they are
within another expression, for example inside <a href="expressions/grouped-expr.html">parentheses</a>.</p>
<p>The field names can be decimal integer values to specify indices for constructing tuple
structs. This can be used with base structs to fill out the remaining indices not
specified:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Color(u8, u8, u8);
let c1 = Color(0, 0, 0);  // Typical way of creating a tuple struct.
let c2 = Color{0: 255, 1: 127, 2: 0};  // Specifying fields by index.
let c3 = Color{1: 0, ..c2};  // Fill out all other fields using a base struct.
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#struct-field-init-shorthand" id="struct-field-init-shorthand">Struct field init shorthand</a></h3>
<p>When initializing a data structure (struct, enum, union) with named (but not
numbered) fields, it is allowed to write <code>fieldname</code> as a shorthand for
<code>fieldname: fieldname</code>. This allows a compact syntax with less duplication.
For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point3d { x: i32, y: i32, z: i32 }
</span><span class="boring">let x = 0;
</span><span class="boring">let y_value = 0;
</span><span class="boring">let z = 0;
</span>Point3d { x: x, y: y_value, z: z };
Point3d { x, y: y_value, z };
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#tuple-struct-expression" id="tuple-struct-expression">Tuple struct expression</a></h2>
<p>A struct expression with fields enclosed in parentheses constructs a tuple struct. Though
it is listed here as a specific expression for completeness, it is equivalent to a <a href="expressions/call-expr.html">call
expression</a> to the tuple struct’s constructor. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Position(i32, i32, i32);
Position(0, 0, 0);  // Typical way of creating a tuple struct.
let c = Position;  // `c` is a function that takes 3 arguments.
let pos = c(8, 6, 7);  // Creates a `Position` value.
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#unit-struct-expression" id="unit-struct-expression">Unit struct expression</a></h2>
<p>A unit struct expression is just the path to a unit struct item. This refers to the unit
struct’s implicit constant of its value. The unit struct value can also be constructed
with a fieldless struct expression. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Gamma;
let a = Gamma;  // Gamma unit value.
let b = Gamma{};  // Exact same value as `a`.
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#struct-expression-attributes" id="struct-expression-attributes">Struct expression attributes</a></h2>
<p><a href="expressions/../attributes.html">Inner attributes</a> are allowed directly after the opening brace or parenthesis
of a struct expression in the same expression contexts as <a href="expressions/block-expr.html#attributes-on-block-expressions">attributes on block
expressions</a>.</p>
<h1><a class="header" href="#enumeration-variant-expressions" id="enumeration-variant-expressions">Enumeration Variant expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>EnumerationVariantExpression</em> :<br />
      <em>EnumExprStruct</em><br />
   | <em>EnumExprTuple</em><br />
   | <em>EnumExprFieldless</em></p>
<p><em>EnumExprStruct</em> :<br />
   <a href="expressions/../paths.html#paths-in-expressions"><em>PathInExpression</em></a> <code>{</code> <em>EnumExprFields</em><sup>?</sup> <code>}</code></p>
<p><em>EnumExprFields</em> :<br />
      <em>EnumExprField</em> (<code>,</code> <em>EnumExprField</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>EnumExprField</em> :<br />
      <a href="expressions/../identifiers.html">IDENTIFIER</a><br />
   | (<a href="expressions/../identifiers.html">IDENTIFIER</a> | <a href="expressions/../tokens.html#integer-literals">TUPLE_INDEX</a>) <code>:</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
<p><em>EnumExprTuple</em> :<br />
   <a href="expressions/../paths.html#paths-in-expressions"><em>PathInExpression</em></a> <code>(</code><br />
      ( <a href="expressions/../expressions.html"><em>Expression</em></a> (<code>,</code> <a href="expressions/../expressions.html"><em>Expression</em></a>)<sup>*</sup> <code>,</code><sup>?</sup> )<sup>?</sup><br />
   <code>)</code></p>
<p><em>EnumExprFieldless</em> : <a href="expressions/../paths.html#paths-in-expressions"><em>PathInExpression</em></a></p>
</blockquote>
<p>Enumeration variants can be constructed similarly to <a href="expressions/struct-expr.html">structs</a>, using a path to an enum
variant instead of to a struct:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Message {
</span><span class="boring">    Quit,
</span><span class="boring">    WriteString(String),
</span><span class="boring">    Move { x: i32, y: i32 },
</span><span class="boring">}
</span>let q = Message::Quit;
let w = Message::WriteString(&quot;Some string&quot;.to_string());
let m = Message::Move { x: 50, y: 200 };
<span class="boring">}
</span></code></pre></pre>
<p>Enum variant expressions have the same syntax, behavior, and restrictions as <a href="expressions/struct-expr.html">struct
expressions</a>, except they do not support base update with the <code>..</code> syntax.</p>
<h1><a class="header" href="#call-expressions" id="call-expressions">Call expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>CallExpression</em> :<br />
   <a href="expressions/../expressions.html"><em>Expression</em></a> <code>(</code> <em>CallParams</em><sup>?</sup> <code>)</code></p>
<p><em>CallParams</em> :<br />
   <a href="expressions/../expressions.html"><em>Expression</em></a> ( <code>,</code> <a href="expressions/../expressions.html"><em>Expression</em></a> )<sup>*</sup> <code>,</code><sup>?</sup></p>
</blockquote>
<p>A <em>call expression</em> consists of an expression followed by a parenthesized
expression-list. It invokes a function, providing zero or more input variables.
If the function eventually returns, then the expression completes. For
<a href="expressions/../types/function-item.html">non-function types</a>, the expression f(...) uses
the method on one of the <a href="expressions/../../std/ops/trait.Fn.html"><code>std::ops::Fn</code></a>, <a href="expressions/../../std/ops/trait.FnMut.html"><code>std::ops::FnMut</code></a> or
<a href="expressions/../../std/ops/trait.FnOnce.html"><code>std::ops::FnOnce</code></a> traits, which differ in whether they take the type by
reference, mutable reference, or take ownership respectively. An automatic
borrow will be taken if needed. Rust will also automatically dereference <code>f</code> as
required. Some examples of call expressions:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">fn add(x: i32, y: i32) -&gt; i32 { 0 }
</span>let three: i32 = add(1i32, 2i32);
let name: &amp;'static str = (|| &quot;Rust&quot;)();
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#disambiguating-function-calls" id="disambiguating-function-calls">Disambiguating Function Calls</a></h2>
<p>Rust treats all function calls as sugar for a more explicit, fully-qualified
syntax. Upon compilation, Rust will desugar all function calls into the explicit
form. Rust may sometimes require you to qualify function calls with trait,
depending on the ambiguity of a call in light of in-scope items.</p>
<blockquote>
<p><strong>Note</strong>: In the past, the Rust community used the terms “Unambiguous
Function Call Syntax”, “Universal Function Call Syntax”, or “UFCS”, in
documentation, issues, RFCs, and other community writings. However, the term
lacks descriptive power and potentially confuses the issue at hand. We mention
it here for searchability’s sake.</p>
</blockquote>
<p>Several situations often occur which result in ambiguities about the receiver or
referent of method or associated function calls. These situations may include:</p>
<ul>
<li>Multiple in-scope traits define methods with the same name for the same types</li>
<li>Auto-<code>deref</code> is undesirable; for example, distinguishing between methods on a
smart pointer itself and the pointer’s referent</li>
<li>Methods which take no arguments, like <code>default()</code>, and return properties of a
type, like <code>size_of()</code></li>
</ul>
<p>To resolve the ambiguity, the programmer may refer to their desired method or
function using more specific paths, types, or traits.</p>
<p>For example,</p>
<pre><pre class="playpen"><code class="language-rust">trait Pretty {
    fn print(&amp;self);
}

trait Ugly {
  fn print(&amp;self);
}

struct Foo;
impl Pretty for Foo {
    fn print(&amp;self) {}
}

struct Bar;
impl Pretty for Bar {
    fn print(&amp;self) {}
}
impl Ugly for Bar{
    fn print(&amp;self) {}
}

fn main() {
    let f = Foo;
    let b = Bar;

    // we can do this because we only have one item called `print` for `Foo`s
    f.print();
    // more explicit, and, in the case of `Foo`, not necessary
    Foo::print(&amp;f);
    // if you're not into the whole brevity thing
    &lt;Foo as Pretty&gt;::print(&amp;f);

    // b.print(); // Error: multiple 'print' found
    // Bar::print(&amp;b); // Still an error: multiple `print` found

    // necessary because of in-scope items defining `print`
    &lt;Bar as Pretty&gt;::print(&amp;b);
}
</code></pre></pre>
<p>Refer to <a href="https://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md">RFC 132</a> for further details and motivations.</p>
<h1><a class="header" href="#method-call-expressions" id="method-call-expressions">Method-call expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>MethodCallExpression</em> :<br />
   <a href="expressions/../expressions.html"><em>Expression</em></a> <code>.</code> <a href="expressions/../paths.html#paths-in-expressions"><em>PathExprSegment</em></a> <code>(</code><a href="expressions/call-expr.html"><em>CallParams</em></a><sup>?</sup> <code>)</code></p>
</blockquote>
<p>A <em>method call</em> consists of an expression (the <em>receiver</em>) followed by a single
dot, an expression path segment, and a parenthesized expression-list. Method calls are
resolved to associated <a href="expressions/../items/associated-items.html#methods">methods</a> on specific traits, either statically
dispatching to a method if the exact <code>self</code>-type of the left-hand-side is known,
or dynamically dispatching if the left-hand-side expression is an indirect
<a href="expressions/../types/trait-object.html">trait object</a>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let pi: Result&lt;f32, _&gt; = &quot;3.14&quot;.parse();
let log_pi = pi.unwrap_or(1.0).log(2.72);
<span class="boring">assert!(1.14 &lt; log_pi &amp;&amp; log_pi &lt; 1.15)
</span><span class="boring">}
</span></code></pre></pre>
<p>When looking up a method call, the receiver may be automatically dereferenced or
borrowed in order to call a method. This requires a more complex lookup process
than for other functions, since there may be a number of possible methods to
call. The following procedure is used:</p>
<p>The first step is to build a list of candidate receiver types. Obtain
these by repeatedly <a href="expressions/operator-expr.html#the-dereference-operator">dereferencing</a> the receiver expression’s type,
adding each type encountered to the list, then finally attempting an <a href="expressions/../type-coercions.html#unsized-coercions">unsized
coercion</a> at the end, and adding the result type if that is successful. Then,
for each candidate <code>T</code>, add <code>&amp;T</code> and <code>&amp;mut T</code> to the list immediately after <code>T</code>.</p>
<p>For instance, if the receiver has type <code>Box&lt;[i32;2]&gt;</code>, then the candidate types
will be <code>Box&lt;[i32;2]&gt;</code>, <code>&amp;Box&lt;[i32;2]&gt;</code>, <code>&amp;mut Box&lt;[i32;2]&gt;</code>, <code>[i32; 2]</code> (by
dereferencing), <code>&amp;[i32; 2]</code>, <code>&amp;mut [i32; 2]</code>, <code>[i32]</code> (by unsized coercion),
<code>&amp;[i32]</code>, and finally <code>&amp;mut [i32]</code>.</p>
<p>Then, for each candidate type <code>T</code>, search for a <a href="expressions/../visibility-and-privacy.html">visible</a> method with
a receiver of that type in the following places:</p>
<ol>
<li><code>T</code>‘s inherent methods (methods implemented directly on <code>T</code>).</li>
<li>Any of the methods provided by a <a href="expressions/../visibility-and-privacy.html">visible</a> trait implemented by <code>T</code>. If <code>T</code>
is a type parameter, methods provided by trait bounds on <code>T</code> are looked up
first. Then all remaining methods in scope are looked up.</li>
</ol>
<blockquote>
<p>Note: the lookup is done for each type in order, which can occasionally lead
to surprising results. The below code will print “In trait impl!”, because
<code>&amp;self</code> methods are looked up first, the trait method is found before the
struct’s <code>&amp;mut self</code> method is found.</p>
<pre><pre class="playpen"><code class="language-rust">struct Foo {}

trait Bar {
  fn bar(&amp;self);
}

impl Foo {
  fn bar(&amp;mut self) {
    println!(&quot;In struct impl!&quot;)
  }
}

impl Bar for Foo {
  fn bar(&amp;self) {
    println!(&quot;In trait impl!&quot;)
  }
}

fn main() {
  let mut f = Foo{};
  f.bar();
}
</code></pre></pre>
</blockquote>
<p>If this results in multiple possible candidates, then it is an error, and the
receiver must be <a href="expressions/call-expr.html#disambiguating-function-calls">converted</a> to an appropriate receiver type
to make the method call.</p>
<p>This process does not take into account the mutability or lifetime of the
receiver, or whether a method is <code>unsafe</code>. Once a method is looked up, if it
can’t be called for one (or more) of those reasons, the result is a compiler
error.</p>
<p>If a step is reached where there is more than one possible method, such as where
generic methods or traits are considered the same, then it is a compiler
error. These cases require a <a href="expressions/call-expr.html#disambiguating-function-calls">disambiguating function call syntax</a> for method
and function invocation.</p>
<div class="warning">
<p><em><strong>Warning:</strong></em> For <a href="expressions/../types/trait-object.html">trait objects</a>, if there is an inherent method of the same
name as a trait method, it will give a compiler error when trying to call the
method in a method call expression. Instead, you can call the method using
<a href="expressions/call-expr.html#disambiguating-function-calls">disambiguating function call syntax</a>, in which case it calls the trait
method, not the inherent method. There is no way to call the inherent method.
Just don’t define inherent methods on trait objects with the same name a trait
method and you’ll be fine.</p>
</div>
<h1><a class="header" href="#field-access-expressions" id="field-access-expressions">Field access expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>FieldExpression</em> :<br />
   <a href="expressions/../expressions.html"><em>Expression</em></a> <code>.</code> <a href="expressions/../identifiers.html">IDENTIFIER</a></p>
</blockquote>
<p>A <em>field expression</em> consists of an expression followed by a single dot and an
<a href="expressions/../identifiers.html">identifier</a>, when not immediately followed by a parenthesized expression-list
(the latter is always a <a href="expressions/method-call-expr.html">method call expression</a>). A field expression denotes a
field of a <a href="expressions/../items/structs.html">struct</a> or <a href="expressions/../items/unions.html">union</a>. To call a function stored in a struct,
parentheses are needed around the field expression.</p>
<!-- ignore: needs lots of support code -->
<pre><code class="language-rust ignore">mystruct.myfield;
foo().x;
(Struct {a: 10, b: 20}).a;
mystruct.method();          // Method expression
(mystruct.function_field)() // Call expression containing a field expression
</code></pre>
<p>A field access is a <a href="expressions/../expressions.html#place-expressions-and-value-expressions">place expression</a> referring to the location of that field.
When the subexpression is <a href="expressions/../expressions.html#mutability">mutable</a>, the field expression is also mutable.</p>
<p>Also, if the type of the expression to the left of the dot is a pointer, it is
automatically dereferenced as many times as necessary to make the field access
possible. In cases of ambiguity, we prefer fewer autoderefs to more.</p>
<p>Finally, the fields of a struct or a reference to a struct are treated as
separate entities when borrowing. If the struct does not implement
<a href="expressions/../special-types-and-traits.html#drop"><code>Drop</code></a> and is stored in a local variable,
this also applies to moving out of each of its fields. This also does not apply
if automatic dereferencing is done though user defined types.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct A { f1: String, f2: String, f3: String }
let mut x: A;
<span class="boring">x = A {
</span><span class="boring">    f1: &quot;f1&quot;.to_string(),
</span><span class="boring">    f2: &quot;f2&quot;.to_string(),
</span><span class="boring">    f3: &quot;f3&quot;.to_string()
</span><span class="boring">};
</span>let a: &amp;mut String = &amp;mut x.f1; // x.f1 borrowed mutably
let b: &amp;String = &amp;x.f2;         // x.f2 borrowed immutably
let c: &amp;String = &amp;x.f2;         // Can borrow again
let d: String = x.f3;           // Move out of x.f3
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#closure-expressions" id="closure-expressions">Closure expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ClosureExpression</em> :<br />
   <code>move</code><sup>?</sup><br />
   ( <code>||</code> | <code>|</code> <em>ClosureParameters</em><sup>?</sup> <code>|</code> )<br />
   (<a href="expressions/../expressions.html"><em>Expression</em></a> | <code>-&gt;</code> <a href="expressions/../types.html#type-expressions"><em>TypeNoBounds</em></a> <a href="expressions/block-expr.html"><em>BlockExpression</em></a>)</p>
<p><em>ClosureParameters</em> :<br />
   <em>ClosureParam</em> (<code>,</code> <em>ClosureParam</em>)<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>ClosureParam</em> :<br />
   <a href="expressions/../attributes.html"><em>OuterAttribute</em></a><sup>*</sup> <a href="expressions/../patterns.html"><em>Pattern</em></a> ( <code>:</code> <a href="expressions/../types.html#type-expressions"><em>Type</em></a> )<sup>?</sup></p>
</blockquote>
<p>A <em>closure expression</em>, also know as a lambda expression or a lambda, defines a 
closure and denotes it as a value, in a single expression. A closure expression 
is a pipe-symbol-delimited (<code>|</code>) list of irrefutable <a href="expressions/../patterns.html">patterns</a> followed by an 
expression. Type annotations may optionally be added for the type of the 
parameters or for the return type. If there is a return type, the expression
used for the body of the closure must be a normal <a href="expressions/block-expr.html">block</a>. A closure expression
also may begin with the <code>move</code> keyword before the initial <code>|</code>.</p>
<p>A closure expression denotes a function that maps a list of parameters onto
the expression that follows the parameters. Just like a <a href="expressions/../statements.html#let-statements"><code>let</code> binding</a>, the
parameters are irrefutable <a href="expressions/../patterns.html">patterns</a>, whose type annotation is optional and
will be inferred from context if not given. Each closure expression has a
unique, anonymous type.</p>
<p>Closure expressions are most useful when passing functions as arguments to other
functions, as an abbreviation for defining and capturing a separate function.</p>
<p>Significantly, closure expressions <em>capture their environment</em>, which regular
<a href="expressions/../items/functions.html">function definitions</a> do not. Without the <code>move</code> keyword, the closure expression
<a href="expressions/../types/closure.html#capture-modes">infers how it captures each variable from its environment</a>,
preferring to capture by shared reference, effectively borrowing
all outer variables mentioned inside the closure’s body. If needed the compiler
will infer that instead mutable references should be taken, or that the values
should be moved or copied (depending on their type) from the environment. A
closure can be forced to capture its environment by copying or moving values by
prefixing it with the <code>move</code> keyword. This is often used to ensure that the
closure’s type is <code>'static</code>.</p>
<p>The compiler will determine which of the <a href="expressions/../types/closure.html#call-traits-and-coercions">closure
traits</a> the closure’s type will implement by how it
acts on its captured variables. The closure will also implement
<a href="expressions/../special-types-and-traits.html#send"><code>Send</code></a> and/or
<a href="expressions/../special-types-and-traits.html#sync"><code>Sync</code></a> if all of its captured types do.
These traits allow functions to accept closures using generics, even though the
exact types can’t be named.</p>
<p>In this example, we define a function <code>ten_times</code> that takes a higher-order
function argument, and we then call it with a closure expression as an argument,
followed by a closure expression that moves values from its environment.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn ten_times&lt;F&gt;(f: F) where F: Fn(i32) {
    for index in 0..10 {
        f(index);
    }
}

ten_times(|j| println!(&quot;hello, {}&quot;, j));
// With type annotations
ten_times(|j: i32| -&gt; () { println!(&quot;hello, {}&quot;, j) });

let word = &quot;konnichiwa&quot;.to_owned();
ten_times(move |j| println!(&quot;{}, {}&quot;, word, j));
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#attributes-on-closure-parameters" id="attributes-on-closure-parameters">Attributes on closure parameters</a></h2>
<p>Attributes on closure parameters follow the same rules and restrictions as
<a href="expressions/../items/functions.html#attributes-on-function-parameters">regular function parameters</a>.</p>
<h1><a class="header" href="#loops" id="loops">Loops</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>LoopExpression</em> :<br />
   <a href="expressions/loop-expr.html#loop-labels"><em>LoopLabel</em></a><sup>?</sup> (<br />
         <a href="expressions/loop-expr.html#infinite-loops"><em>InfiniteLoopExpression</em></a><br />
      | <a href="expressions/loop-expr.html#predicate-loops"><em>PredicateLoopExpression</em></a><br />
      | <a href="expressions/loop-expr.html#predicate-pattern-loops"><em>PredicatePatternLoopExpression</em></a><br />
      | <a href="expressions/loop-expr.html#iterator-loops"><em>IteratorLoopExpression</em></a><br />
   )</p>
</blockquote>
<p>Rust supports four loop expressions:</p>
<ul>
<li>A <a href="expressions/loop-expr.html#infinite-loops"><code>loop</code> expression</a> denotes an infinite loop.</li>
<li>A <a href="expressions/loop-expr.html#predicate-loops"><code>while</code> expression</a> loops until a predicate is false.</li>
<li>A <a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code> expression</a> tests a pattern.</li>
<li>A <a href="expressions/loop-expr.html#iterator-loops"><code>for</code> expression</a> extracts values from an iterator,
looping until the iterator is empty.</li>
</ul>
<p>All four types of loop support <a href="expressions/loop-expr.html#break-expressions"><code>break</code> expressions</a>,
<a href="expressions/loop-expr.html#continue-expressions"><code>continue</code> expressions</a>, and <a href="expressions/loop-expr.html#loop-labels">labels</a>.
Only <code>loop</code> supports <a href="expressions/loop-expr.html#break-and-loop-values">evaluation to non-trivial values</a>.</p>
<h2><a class="header" href="#infinite-loops" id="infinite-loops">Infinite loops</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>InfiniteLoopExpression</em> :<br />
   <code>loop</code> <a href="expressions/block-expr.html"><em>BlockExpression</em></a></p>
</blockquote>
<p>A <code>loop</code> expression repeats execution of its body continuously:
<code>loop { println!(&quot;I live.&quot;); }</code>.</p>
<p>A <code>loop</code> expression without an associated <code>break</code> expression is diverging and
has type <a href="expressions/../types/never.html"><code>!</code></a>. A <code>loop</code> expression containing
associated <a href="expressions/loop-expr.html#break-expressions"><code>break</code> expression(s)</a> may terminate, and must
have type compatible with the value of the <code>break</code> expression(s).</p>
<h2><a class="header" href="#predicate-loops" id="predicate-loops">Predicate loops</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>PredicateLoopExpression</em> :<br />
   <code>while</code> <a href="expressions/../expressions.html"><em>Expression</em></a><sub>except struct expression</sub> <a href="expressions/block-expr.html"><em>BlockExpression</em></a></p>
</blockquote>
<p>A <code>while</code> loop begins by evaluating the boolean loop conditional expression. If
the loop conditional expression evaluates to <code>true</code>, the loop body block
executes, then control returns to the loop conditional expression. If the loop
conditional expression evaluates to <code>false</code>, the <code>while</code> expression completes.</p>
<p>An example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut i = 0;

while i &lt; 10 {
    println!(&quot;hello&quot;);
    i = i + 1;
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#predicate-pattern-loops" id="predicate-pattern-loops">Predicate pattern loops</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<a href="expressions/loop-expr.html#predicate-pattern-loops"><em>PredicatePatternLoopExpression</em></a> :<br />
   <code>while</code> <code>let</code> <a href="expressions/match-expr.html"><em>MatchArmPatterns</em></a> <code>=</code> <a href="expressions/../expressions.html"><em>Expression</em></a><sub>except struct expression</sub>
<a href="expressions/block-expr.html"><em>BlockExpression</em></a></p>
</blockquote>
<p>A <code>while let</code> loop is semantically similar to a <code>while</code> loop but in place of a
condition expression it expects the keyword <code>let</code> followed by a pattern, an
<code>=</code>, a <a href="expressions/../glossary.html#scrutinee">scrutinee</a> expression and a block expression. If the value of the
scrutinee matches the pattern, the loop body block executes then control
returns to the pattern matching statement. Otherwise, the while expression
completes.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut x = vec![1, 2, 3];

while let Some(y) = x.pop() {
    println!(&quot;y = {}&quot;, y);
}

while let _ = 5 {
    println!(&quot;Irrefutable patterns are always true&quot;);
    break;
}
<span class="boring">}
</span></code></pre></pre>
<p>A <code>while let</code> loop is equivalent to a <code>loop</code> expression containing a <a href="expressions/match-expr.html"><code>match</code>
expression</a> as follows.</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">'label: while let PATS = EXPR {
    /* loop body */
}
</code></pre>
<p>is equivalent to</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">'label: loop {
    match EXPR {
        PATS =&gt; { /* loop body */ },
        _ =&gt; break,
    }
}
</code></pre>
<p>Multiple patterns may be specified with the <code>|</code> operator. This has the same semantics
as with <code>|</code> in <code>match</code> expressions:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut vals = vec![2, 3, 1, 2, 2];
while let Some(v @ 1) | Some(v @ 2) = vals.pop() {
    // Prints 2, 2, then 1
    println!(&quot;{}&quot;, v);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#iterator-loops" id="iterator-loops">Iterator loops</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>IteratorLoopExpression</em> :<br />
   <code>for</code> <a href="expressions/../patterns.html"><em>Pattern</em></a> <code>in</code> <a href="expressions/../expressions.html"><em>Expression</em></a><sub>except struct expression</sub>
<a href="expressions/block-expr.html"><em>BlockExpression</em></a></p>
</blockquote>
<p>A <code>for</code> expression is a syntactic construct for looping over elements provided
by an implementation of <code>std::iter::IntoIterator</code>. If the iterator yields a
value, that value is matched against the irrefutable pattern, the body of the
loop is executed, and then control returns to the head of the <code>for</code> loop. If the
iterator is empty, the <code>for</code> expression completes.</p>
<p>An example of a <code>for</code> loop over the contents of an array:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let v = &amp;[&quot;apples&quot;, &quot;cake&quot;, &quot;coffee&quot;];

for text in v {
    println!(&quot;I like {}.&quot;, text);
}
<span class="boring">}
</span></code></pre></pre>
<p>An example of a for loop over a series of integers:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut sum = 0;
for n in 1..11 {
    sum += n;
}
assert_eq!(sum, 55);
<span class="boring">}
</span></code></pre></pre>
<p>A for loop is equivalent to the following block expression.</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">'label: for PATTERN in iter_expr {
    /* loop body */
}
</code></pre>
<p>is equivalent to</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">{
    let result = match IntoIterator::into_iter(iter_expr) {
        mut iter =&gt; 'label: loop {
            let mut next;
            match Iterator::next(&amp;mut iter) {
                Option::Some(val) =&gt; next = val,
                Option::None =&gt; break,
            };
            let PAT = next;
            let () = { /* loop body */ };
        },
    };
    result
}
</code></pre>
<p><code>IntoIterator</code>, <code>Iterator</code>, and <code>Option</code> are always the standard library items
here, not whatever those names resolve to in the current scope. The variable
names <code>next</code>, <code>iter</code>, and <code>val</code> are for exposition only, they do not actually
have names the user can type.</p>
<blockquote>
<p><strong>Note</strong>: that the outer <code>match</code> is used to ensure that any
<a href="expressions/../expressions.html#temporary-lifetimes">temporary values</a> in <code>iter_expr</code> don’t get dropped before the loop is
finished. <code>next</code> is declared before being assigned because it results in
types being inferred correctly more often.</p>
</blockquote>
<h2><a class="header" href="#loop-labels" id="loop-labels">Loop labels</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>LoopLabel</em> :<br />
   <a href="expressions/../tokens.html#lifetimes-and-loop-labels">LIFETIME_OR_LABEL</a> <code>:</code></p>
</blockquote>
<p>A loop expression may optionally have a <em>label</em>. The label is written as
a lifetime preceding the loop expression, as in <code>'foo: loop { break 'foo; }</code>,
<code>'bar: while false {}</code>, <code>'humbug: for _ in 0..0 {}</code>.
If a label is present, then labeled <code>break</code> and <code>continue</code> expressions nested
within this loop may exit out of this loop or return control to its head.
See <a href="expressions/loop-expr.html#break-expressions">break expressions</a> and <a href="expressions/loop-expr.html#continue-expressions">continue
expressions</a>.</p>
<h2><a class="header" href="#break-expressions" id="break-expressions"><code>break</code> expressions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>BreakExpression</em> :<br />
   <code>break</code> <a href="expressions/../tokens.html#lifetimes-and-loop-labels">LIFETIME_OR_LABEL</a><sup>?</sup> <a href="expressions/../expressions.html"><em>Expression</em></a><sup>?</sup></p>
</blockquote>
<p>When <code>break</code> is encountered, execution of the associated loop body is
immediately terminated, for example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut last = 0;
for x in 1..100 {
    if x &gt; 12 {
        break;
    }
    last = x;
}
assert_eq!(last, 12);
<span class="boring">}
</span></code></pre></pre>
<p>A <code>break</code> expression is normally associated with the innermost <code>loop</code>, <code>for</code> or
<code>while</code> loop enclosing the <code>break</code> expression, but a <a href="expressions/loop-expr.html#loop-labels">label</a> can
be used to specify which enclosing loop is affected. Example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>'outer: loop {
    while true {
        break 'outer;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>A <code>break</code> expression is only permitted in the body of a loop, and has one of
the forms <code>break</code>, <code>break 'label</code> or (<a href="expressions/loop-expr.html#break-and-loop-values">see below</a>)
<code>break EXPR</code> or <code>break 'label EXPR</code>.</p>
<h2><a class="header" href="#continue-expressions" id="continue-expressions"><code>continue</code> expressions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ContinueExpression</em> :<br />
   <code>continue</code> <a href="expressions/../tokens.html#lifetimes-and-loop-labels">LIFETIME_OR_LABEL</a><sup>?</sup></p>
</blockquote>
<p>When <code>continue</code> is encountered, the current iteration of the associated loop
body is immediately terminated, returning control to the loop <em>head</em>. In
the case of a <code>while</code> loop, the head is the conditional expression controlling
the loop. In the case of a <code>for</code> loop, the head is the call-expression
controlling the loop.</p>
<p>Like <code>break</code>, <code>continue</code> is normally associated with the innermost enclosing
loop, but <code>continue 'label</code> may be used to specify the loop affected.
A <code>continue</code> expression is only permitted in the body of a loop.</p>
<h2><a class="header" href="#break-and-loop-values" id="break-and-loop-values"><code>break</code> and loop values</a></h2>
<p>When associated with a <code>loop</code>, a break expression may be used to return a value
from that loop, via one of the forms <code>break EXPR</code> or <code>break 'label EXPR</code>, where
<code>EXPR</code> is an expression whose result is returned from the <code>loop</code>. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let (mut a, mut b) = (1, 1);
let result = loop {
    if b &gt; 10 {
        break b;
    }
    let c = a + b;
    a = b;
    b = c;
};
// first number in Fibonacci sequence over 10:
assert_eq!(result, 13);
<span class="boring">}
</span></code></pre></pre>
<p>In the case a <code>loop</code> has an associated <code>break</code>, it is not considered diverging,
and the <code>loop</code> must have a type compatible with each <code>break</code> expression.
<code>break</code> without an expression is considered identical to <code>break</code> with
expression <code>()</code>.</p>
<h1><a class="header" href="#range-expressions" id="range-expressions">Range expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>RangeExpression</em> :<br />
      <em>RangeExpr</em><br />
   | <em>RangeFromExpr</em><br />
   | <em>RangeToExpr</em><br />
   | <em>RangeFullExpr</em><br />
   | <em>RangeInclusiveExpr</em><br />
   | <em>RangeToInclusiveExpr</em></p>
<p><em>RangeExpr</em> :<br />
   <a href="expressions/../expressions.html"><em>Expression</em></a> <code>..</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
<p><em>RangeFromExpr</em> :<br />
   <a href="expressions/../expressions.html"><em>Expression</em></a> <code>..</code></p>
<p><em>RangeToExpr</em> :<br />
   <code>..</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
<p><em>RangeFullExpr</em> :<br />
   <code>..</code></p>
<p><em>RangeInclusiveExpr</em> :<br />
   <a href="expressions/../expressions.html"><em>Expression</em></a> <code>..=</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
<p><em>RangeToInclusiveExpr</em> :<br />
   <code>..=</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
</blockquote>
<p>The <code>..</code> and <code>..=</code> operators will construct an object of one of the
<code>std::ops::Range</code> (or <code>core::ops::Range</code>) variants, according to the following
table:</p>
<table><thead><tr><th>Production</th><th>Syntax</th><th>Type</th><th>Range</th></tr></thead><tbody>
<tr><td><em>RangeExpr</em></td><td>start<code>..</code>end</td><td><a href="https://doc.rust-lang.org/std/ops/struct.Range.html">std::ops::Range</a></td><td>start ≤ x &lt; end</td></tr>
<tr><td><em>RangeFromExpr</em></td><td>start<code>..</code></td><td><a href="https://doc.rust-lang.org/std/ops/struct.RangeFrom.html">std::ops::RangeFrom</a></td><td>start ≤ x</td></tr>
<tr><td><em>RangeToExpr</em></td><td><code>..</code>end</td><td><a href="https://doc.rust-lang.org/std/ops/struct.RangeTo.html">std::ops::RangeTo</a></td><td>x &lt; end</td></tr>
<tr><td><em>RangeFullExpr</em></td><td><code>..</code></td><td><a href="https://doc.rust-lang.org/std/ops/struct.RangeFull.html">std::ops::RangeFull</a></td><td>-</td></tr>
<tr><td><em>RangeInclusiveExpr</em></td><td>start<code>..=</code>end</td><td><a href="https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html">std::ops::RangeInclusive</a></td><td>start ≤ x ≤ end</td></tr>
<tr><td><em>RangeToInclusiveExpr</em></td><td><code>..=</code>end</td><td><a href="https://doc.rust-lang.org/std/ops/struct.RangeToInclusive.html">std::ops::RangeToInclusive</a></td><td>x ≤ end</td></tr>
</tbody></table>
<p>Examples:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>1..2;   // std::ops::Range
3..;    // std::ops::RangeFrom
..4;    // std::ops::RangeTo
..;     // std::ops::RangeFull
5..=6;  // std::ops::RangeInclusive
..=7;   // std::ops::RangeToInclusive
<span class="boring">}
</span></code></pre></pre>
<p>The following expressions are equivalent.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = std::ops::Range {start: 0, end: 10};
let y = 0..10;

assert_eq!(x, y);
<span class="boring">}
</span></code></pre></pre>
<p>Ranges can be used in <code>for</code> loops:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>for i in 1..11 {
    println!(&quot;{}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#if-and-if-let-expressions" id="if-and-if-let-expressions"><code>if</code> and <code>if let</code> expressions</a></h1>
<h2><a class="header" href="#if-expressions" id="if-expressions"><code>if</code> expressions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>IfExpression</em> :<br />
   <code>if</code> <a href="expressions/../expressions.html"><em>Expression</em></a><sub><em>except struct expression</em></sub> <a href="expressions/block-expr.html"><em>BlockExpression</em></a><br />
   (<code>else</code> (
<a href="expressions/block-expr.html"><em>BlockExpression</em></a>
| <em>IfExpression</em>
| <em>IfLetExpression</em> ) )<sup>?</sup></p>
</blockquote>
<p>An <code>if</code> expression is a conditional branch in program control. The form of an
<code>if</code> expression is a condition expression, followed by a consequent block, any
number of <code>else if</code> conditions and blocks, and an optional trailing <code>else</code>
block. The condition expressions must have type <code>bool</code>. If a condition
expression evaluates to <code>true</code>, the consequent block is executed and any
subsequent <code>else if</code> or <code>else</code> block is skipped. If a condition expression
evaluates to <code>false</code>, the consequent block is skipped and any subsequent <code>else if</code> condition is evaluated. If all <code>if</code> and <code>else if</code> conditions evaluate to
<code>false</code> then any <code>else</code> block is executed. An if expression evaluates to the
same value as the executed block, or <code>()</code> if no block is evaluated. An <code>if</code>
expression must have the same type in all situations.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let x = 3;
</span>if x == 4 {
    println!(&quot;x is four&quot;);
} else if x == 3 {
    println!(&quot;x is three&quot;);
} else {
    println!(&quot;x is something else&quot;);
}

let y = if 12 * 15 &gt; 150 {
    &quot;Bigger&quot;
} else {
    &quot;Smaller&quot;
};
assert_eq!(y, &quot;Bigger&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#if-let-expressions" id="if-let-expressions"><code>if let</code> expressions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>IfLetExpression</em> :<br />
   <code>if</code> <code>let</code> <a href="expressions/match-expr.html"><em>MatchArmPatterns</em></a> <code>=</code> <a href="expressions/../expressions.html"><em>Expression</em></a><sub><em>except struct or lazy boolean operator expression</em></sub>
<a href="expressions/block-expr.html"><em>BlockExpression</em></a><br />
   (<code>else</code> (
<a href="expressions/block-expr.html"><em>BlockExpression</em></a>
| <em>IfExpression</em>
| <em>IfLetExpression</em> ) )<sup>?</sup></p>
</blockquote>
<p>An <code>if let</code> expression is semantically similar to an <code>if</code> expression but in
place of a condition expression it expects the keyword <code>let</code> followed by a
pattern, an <code>=</code> and a <a href="expressions/../glossary.html#scrutinee">scrutinee</a> expression. If the value of the scrutinee
matches the pattern, the corresponding block will execute. Otherwise, flow
proceeds to the following <code>else</code> block if it exists. Like <code>if</code> expressions,
<code>if let</code> expressions have a value determined by the block that is evaluated.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let dish = (&quot;Ham&quot;, &quot;Eggs&quot;);

// this body will be skipped because the pattern is refuted
if let (&quot;Bacon&quot;, b) = dish {
    println!(&quot;Bacon is served with {}&quot;, b);
} else {
    // This block is evaluated instead.
    println!(&quot;No bacon will be served&quot;);
}

// this body will execute
if let (&quot;Ham&quot;, b) = dish {
    println!(&quot;Ham is served with {}&quot;, b);
}

if let _ = 5 {
    println!(&quot;Irrefutable patterns are always true&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>if</code> and <code>if let</code> expressions can be intermixed:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = Some(3);
let a = if let Some(1) = x {
    1
} else if x == Some(2) {
    2
} else if let Some(y) = x {
    y
} else {
    -1
};
assert_eq!(a, 3);
<span class="boring">}
</span></code></pre></pre>
<p>An <code>if let</code> expression is equivalent to a <a href="expressions/match-expr.html"><code>match</code> expression</a> as follows:</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">if let PATS = EXPR {
    /* body */
} else {
    /*else */
}
</code></pre>
<p>is equivalent to</p>
<!-- ignore: expansion example -->
<pre><code class="language-rust ignore">match EXPR {
    PATS =&gt; { /* body */ },
    _ =&gt; { /* else */ },    // () if there is no else
}
</code></pre>
<p>Multiple patterns may be specified with the <code>|</code> operator. This has the same semantics
as with <code>|</code> in <code>match</code> expressions:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum E {
    X(u8),
    Y(u8),
    Z(u8),
}
let v = E::Y(12);
if let E::X(n) | E::Y(n) = v {
    assert_eq!(n, 12);
}
<span class="boring">}
</span></code></pre></pre>
<p>The expression cannot be a <a href="expressions/operator-expr.html#lazy-boolean-operators">lazy boolean operator expression</a>.
Use of a lazy boolean operator is ambiguous with a planned feature change
of the language (the implementation of if-let chains - see <a href="https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018">eRFC 2947</a>).
When lazy boolean operator expression is desired, this can be achieved
by using parenthesis as below:</p>
<!-- ignore: psuedo code -->
<pre><code class="language-rust ignore">// Before...
if let PAT = EXPR &amp;&amp; EXPR { .. }

// After...
if let PAT = ( EXPR &amp;&amp; EXPR ) { .. }

// Before...
if let PAT = EXPR || EXPR { .. }

// After...
if let PAT = ( EXPR || EXPR ) { .. }
</code></pre>
<h1><a class="header" href="#match-expressions" id="match-expressions"><code>match</code> expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>MatchExpression</em> :<br />
   <code>match</code> <a href="expressions/../expressions.html"><em>Expression</em></a><sub><em>except struct expression</em></sub> <code>{</code><br />
      <a href="expressions/../attributes.html"><em>InnerAttribute</em></a><sup>*</sup><br />
      <em>MatchArms</em><sup>?</sup><br />
   <code>}</code></p>
<p><em>MatchArms</em> :<br />
   ( <em>MatchArm</em> <code>=&gt;</code>
( <a href="expressions/../expressions.html"><em>ExpressionWithoutBlock</em></a> <code>,</code>
| <a href="expressions/../expressions.html"><em>ExpressionWithBlock</em></a> <code>,</code><sup>?</sup> )
)<sup>*</sup><br />
   <em>MatchArm</em> <code>=&gt;</code> <a href="expressions/../expressions.html"><em>Expression</em></a> <code>,</code><sup>?</sup></p>
<p><em>MatchArm</em> :<br />
   <a href="expressions/../attributes.html"><em>OuterAttribute</em></a><sup>*</sup> <em>MatchArmPatterns</em> <em>MatchArmGuard</em><sup>?</sup></p>
<p><em>MatchArmPatterns</em> :<br />
   <code>|</code><sup>?</sup> <a href="expressions/../patterns.html"><em>Pattern</em></a> ( <code>|</code> <a href="expressions/../patterns.html"><em>Pattern</em></a> )<sup>*</sup></p>
<p><em>MatchArmGuard</em> :<br />
   <code>if</code> <a href="expressions/../expressions.html"><em>Expression</em></a></p>
</blockquote>
<p>A <em><code>match</code> expression</em> branches on a pattern. The exact form of matching that
occurs depends on the <a href="expressions/../patterns.html">pattern</a>. A <code>match</code>
expression has a <em><a href="expressions/../glossary.html#scrutinee">scrutinee</a> expression</em>, which is the value to compare to the
patterns. The scrutinee expression and the patterns must have the same type.</p>
<p>A <code>match</code> behaves differently depending on whether or not the scrutinee
expression is a <a href="expressions/../expressions.html#place-expressions-and-value-expressions">place expression or value expression</a>.
If the scrutinee expression is a <a href="expressions/../expressions.html#place-expressions-and-value-expressions">value expression</a>, it is first evaluated into
a temporary location, and the resulting value is sequentially compared to the
patterns in the arms until a match is found. The first arm with a matching
pattern is chosen as the branch target of the <code>match</code>, any variables bound by
the pattern are assigned to local variables in the arm’s block, and control
enters the block.</p>
<p>When the scrutinee expression is a <a href="expressions/../expressions.html#place-expressions-and-value-expressions">place expression</a>, the match does not
allocate a temporary location; however, a by-value binding may copy or move
from the memory location.
When possible, it is preferable to match on place expressions, as the lifetime
of these matches inherits the lifetime of the place expression rather than being
restricted to the inside of the match.</p>
<p>An example of a <code>match</code> expression:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 1;

match x {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    4 =&gt; println!(&quot;four&quot;),
    5 =&gt; println!(&quot;five&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>Variables bound within the pattern are scoped to the match guard and the arm’s
expression. The <a href="expressions/../patterns.html#binding-modes">binding mode</a> (move, copy, or reference) depends on the pattern.</p>
<p>Multiple match patterns may be joined with the <code>|</code> operator. Each pattern will be
tested in left-to-right sequence until a successful match is found.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let x = 9;
</span>let message = match x {
    0 | 1  =&gt; &quot;not many&quot;,
    2 ..= 9 =&gt; &quot;a few&quot;,
    _      =&gt; &quot;lots&quot;
};

assert_eq!(message, &quot;a few&quot;);

// Demonstration of pattern match order.
struct S(i32, i32);

match S(1, 2) {
    S(z @ 1, _) | S(_, z @ 2) =&gt; assert_eq!(z, 1),
    _ =&gt; panic!(),
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: The <code>2..=9</code> is a <a href="expressions/../patterns.html#range-patterns">Range Pattern</a>, not a <a href="expressions/range-expr.html">Range Expression</a>. Thus, only
those types of ranges supported by range patterns can be used in match arms.</p>
</blockquote>
<p>Every binding in each <code>|</code> separated pattern must appear in all of the patterns
in the arm. Every binding of the same name must have the same type, and have
the same binding mode.</p>
<h2><a class="header" href="#match-guards" id="match-guards">Match guards</a></h2>
<p>Match arms can accept <em>match guards</em> to further refine the
criteria for matching a case. Pattern guards appear after the pattern and
consist of a <code>bool</code>-typed expression following the <code>if</code> keyword.</p>
<p>When the pattern matches successfully, the pattern guard expression is executed.
If the expression evaluates to true, the pattern is successfully matched against.
Otherwise, the next pattern, including other matches with the <code>|</code> operator in
the same arm, is tested.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let maybe_digit = Some(0);
</span><span class="boring">fn process_digit(i: i32) { }
</span><span class="boring">fn process_other(i: i32) { }
</span>let message = match maybe_digit {
    Some(x) if x &lt; 10 =&gt; process_digit(x),
    Some(x) =&gt; process_other(x),
    None =&gt; panic!(),
};
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: Multiple matches using the <code>|</code> operator can cause the pattern guard and
the side effects it has to execute multiple times. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::cell::Cell;
</span>let i : Cell&lt;i32&gt; = Cell::new(0);
match 1 {
    1 | _ if { i.set(i.get() + 1); false } =&gt; {}
    _ =&gt; {}
}
assert_eq!(i.get(), 2);
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<p>A pattern guard may refer to the variables bound within the pattern they follow.
Before evaluating the guard, a shared reference is taken to the part of the
scrutinee the variable matches on. While evaluating the guard,
this shared reference is then used when accessing the variable.
Only when the guard evaluates to true is the value moved, or copied,
from the scrutinee into the variable. This allows shared borrows to be used
inside guards without moving out of the scrutinee in case guard fails to match.
Moreover, by holding a shared reference while evaluating the guard,
mutation inside guards is also prevented.</p>
<h2><a class="header" href="#attributes-on-match-arms" id="attributes-on-match-arms">Attributes on match arms</a></h2>
<p>Outer attributes are allowed on match arms. The only attributes that have
meaning on match arms are <a href="expressions/../conditional-compilation.html"><code>cfg</code></a>, <a href="expressions/../attributes/codegen.html#the-cold-attribute"><code>cold</code></a>, and the <a href="expressions/../attributes/diagnostics.html#lint-check-attributes">lint check attributes</a>.</p>
<p><a href="expressions/../attributes.html">Inner attributes</a> are allowed directly after the opening brace of the match
expression in the same expression contexts as <a href="expressions/block-expr.html#attributes-on-block-expressions">attributes on block
expressions</a>.</p>
<h1><a class="header" href="#return-expressions" id="return-expressions"><code>return</code> expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ReturnExpression</em> :<br />
   <code>return</code> <a href="expressions/../expressions.html"><em>Expression</em></a><sup>?</sup></p>
</blockquote>
<p>Return expressions are denoted with the keyword <code>return</code>. Evaluating a <code>return</code>
expression moves its argument into the designated output location for the
current function call, destroys the current function activation frame, and
transfers control to the caller frame.</p>
<p>An example of a <code>return</code> expression:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn max(a: i32, b: i32) -&gt; i32 {
    if a &gt; b {
        return a;
    }
    return b;
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#await-expressions" id="await-expressions">Await expressions</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>AwaitExpression</em> :<br />
   <a href="expressions/../expressions.html"><em>Expression</em></a> <code>.</code> <code>await</code></p>
</blockquote>
<p>Await expressions are legal only within an <a href="expressions/../expressions/block-expr.html#async-context">async context</a>, like an
<a href="expressions/../items/functions.html#async-functions"><code>async fn</code></a> or an <a href="expressions/block-expr.html#async-blocks"><code>async</code> block</a>. They operate on a <a href="expressions/../../std/future/trait.Future.html">future</a>. Their effect
is to suspend the current computation until the given future is ready
to produce a value.</p>
<p>More specifically, an <code>&lt;expr&gt;.await</code> expression has the following effect.</p>
<ol>
<li>Evaluate <code>&lt;expr&gt;</code> to a <a href="expressions/../../std/future/trait.Future.html">future</a> <code>tmp</code>;</li>
<li>Pin <code>tmp</code> using <a href="expressions/../../std/pin/struct.Pin.html#method.new_unchecked"><code>Pin::new_unchecked</code></a>;</li>
<li>This pinned future is then polled by calling the <a href="expressions/../../std/future/trait.Future.html#tymethod.poll"><code>Future::poll</code></a> method and
passing it the current <a href="expressions/await-expr.html#task-context">task context</a>;</li>
<li>If the call to <code>poll</code> returns <a href="expressions/../../std/task/enum.Poll.html#variant.Pending"><code>Poll::Pending</code></a>, then the future
returns <code>Poll::Pending</code>, suspending its state so that, when the
surrounding async context is re-polled, execution returns to step
2;</li>
<li>Otherwise the call to <code>poll</code> must have returned <a href="expressions/../../std/task/enum.Poll.html#variant.Ready"><code>Poll::Ready</code></a>, in which case the
value contained in the <a href="expressions/../../std/task/enum.Poll.html#variant.Ready"><code>Poll::Ready</code></a> variant is used as the result
of the <code>await</code> expression itself.</li>
</ol>
<blockquote>
<p><strong>Edition differences</strong>: Await expressions are only available beginning with
Rust 2018.</p>
</blockquote>
<h2><a class="header" href="#task-context" id="task-context">Task context</a></h2>
<p>The task context refers to the <a href="expressions/../../std/task/struct.Context.html"><code>Context</code></a> which was supplied to the
current <a href="expressions/../expressions/block-expr.html#async-context">async context</a> when the async context itself was
polled. Because <code>await</code> expressions are only legal in an async
context, there must be some task context available.</p>
<h2><a class="header" href="#approximate-desugaring" id="approximate-desugaring">Approximate desugaring</a></h2>
<p>Effectively, an <code>&lt;expr&gt;.await</code> expression is roughly
equivalent to the following (this desugaring is not normative):</p>
<!-- ignore: example expansion -->
<pre><code class="language-rust ignore">match /* &lt;expr&gt; */ {
    mut pinned =&gt; loop {
        let mut pin = unsafe { Pin::new_unchecked(&amp;mut pinned) };
        match Pin::future::poll(Pin::borrow(&amp;mut pin), &amp;mut current_context) {
            Poll::Ready(r) =&gt; break r,
            Poll::Pending =&gt; yield Poll::Pending,
        }
    }
}
</code></pre>
<p>where the <code>yield</code> pseudo-code returns <code>Poll::Pending</code> and, when
re-invoked, resumes execution from that point. The variable
<code>current_context</code> refers to the context taken from the async
environment.</p>
<h1><a class="header" href="#patterns" id="patterns">Patterns</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Pattern</em> :<br />
      <a href="patterns.html#literal-patterns"><em>LiteralPattern</em></a><br />
   | <a href="patterns.html#identifier-patterns"><em>IdentifierPattern</em></a><br />
   | <a href="patterns.html#wildcard-pattern"><em>WildcardPattern</em></a><br />
   | <a href="patterns.html#range-patterns"><em>RangePattern</em></a><br />
   | <a href="patterns.html#reference-patterns"><em>ReferencePattern</em></a><br />
   | <a href="patterns.html#struct-patterns"><em>StructPattern</em></a><br />
   | <a href="patterns.html#tuple-struct-patterns"><em>TupleStructPattern</em></a><br />
   | <a href="patterns.html#tuple-patterns"><em>TuplePattern</em></a><br />
   | <a href="patterns.html#grouped-patterns"><em>GroupedPattern</em></a><br />
   | <a href="patterns.html#slice-patterns"><em>SlicePattern</em></a><br />
   | <a href="patterns.html#path-patterns"><em>PathPattern</em></a><br />
   | <a href="macros.html#macro-invocation"><em>MacroInvocation</em></a></p>
</blockquote>
<p>Patterns are used to match values against structures and to,
optionally, bind variables to values inside these structures. They are also
used in variable declarations and parameters for functions and closures.</p>
<p>The pattern in the following example does four things:</p>
<ul>
<li>Tests if <code>person</code> has the <code>car</code> field filled with something.</li>
<li>Tests if the person’s <code>age</code> field is between 13 and 19, and binds its value to
the <code>person_age</code> variable.</li>
<li>Binds a reference to the <code>name</code> field to the variable <code>person_name</code>.</li>
<li>Ignores the rest of the fields of <code>person</code>. The remaining fields can have any value and
are not bound to any variables.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Car;
</span><span class="boring">struct Computer;
</span><span class="boring">struct Person {
</span><span class="boring">    name: String,
</span><span class="boring">    car: Option&lt;Car&gt;,
</span><span class="boring">    computer: Option&lt;Computer&gt;,
</span><span class="boring">    age: u8,
</span><span class="boring">}
</span><span class="boring">let person = Person {
</span><span class="boring">    name: String::from(&quot;John&quot;),
</span><span class="boring">    car: Some(Car),
</span><span class="boring">    computer: None,
</span><span class="boring">    age: 15,
</span><span class="boring">};
</span>if let
    Person {
        car: Some(_),
        age: person_age @ 13..=19,
        name: ref person_name,
        ..
    } = person
{
    println!(&quot;{} has a car and is {} years old.&quot;, person_name, person_age);
}
<span class="boring">}
</span></code></pre></pre>
<p>Patterns are used in:</p>
<ul>
<li><a href="statements.html#let-statements"><code>let</code> declarations</a></li>
<li><a href="items/functions.html">Function</a> and <a href="expressions/closure-expr.html">closure</a>
parameters</li>
<li><a href="expressions/match-expr.html"><code>match</code> expressions</a></li>
<li><a href="expressions/if-expr.html"><code>if let</code> expressions</a></li>
<li><a href="expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code> expressions</a></li>
<li><a href="expressions/loop-expr.html#iterator-loops"><code>for</code> expressions</a></li>
</ul>
<h2><a class="header" href="#destructuring" id="destructuring">Destructuring</a></h2>
<p>Patterns can be used to <em>destructure</em> <a href="items/structs.html">structs</a>, <a href="items/enumerations.html">enums</a>, and <a href="types/tuple.html">tuples</a>.
Destructuring breaks up a value into its component pieces. The syntax used is
almost the same as when creating such values. In a pattern whose <a href="glossary.html#scrutinee">scrutinee</a>
expression has a <code>struct</code>, <code>enum</code> or <code>tuple</code> type, a placeholder (<code>_</code>) stands
in for a <em>single</em> data field, whereas a wildcard <code>..</code> stands in for <em>all</em> the
remaining fields of a particular variant. When destructuring a data structure
with named (but not numbered) fields, it is allowed to write <code>fieldname</code> as a
shorthand for <code>fieldname: fieldname</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Message {
</span><span class="boring">    Quit,
</span><span class="boring">    WriteString(String),
</span><span class="boring">    Move { x: i32, y: i32 },
</span><span class="boring">    ChangeColor(u8, u8, u8),
</span><span class="boring">}
</span><span class="boring">let message = Message::Quit;
</span>match message {
    Message::Quit =&gt; println!(&quot;Quit&quot;),
    Message::WriteString(write) =&gt; println!(&quot;{}&quot;, &amp;write),
    Message::Move{ x, y: 0 } =&gt; println!(&quot;move {} horizontally&quot;, x),
    Message::Move{ .. } =&gt; println!(&quot;other move&quot;),
    Message::ChangeColor { 0: red, 1: green, 2: _ } =&gt; {
        println!(&quot;color change, red: {}, green: {}&quot;, red, green);
    }
};
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#refutability" id="refutability">Refutability</a></h2>
<p>A pattern is said to be <em>refutable</em> when it has the possibility of not being matched
by the value it is being matched against. <em>Irrefutable</em> patterns, on the other hand,
always match the value they are being matched against. Examples:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let (x, y) = (1, 2);               // &quot;(x, y)&quot; is an irrefutable pattern

if let (a, 3) = (1, 2) {           // &quot;(a, 3)&quot; is refutable, and will not match
    panic!(&quot;Shouldn't reach here&quot;);
} else if let (a, 4) = (3, 4) {    // &quot;(a, 4)&quot; is refutable, and will match
    println!(&quot;Matched ({}, 4)&quot;, a);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#literal-patterns" id="literal-patterns">Literal patterns</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>LiteralPattern</em> :<br />
      <a href="tokens.html#boolean-literals">BOOLEAN_LITERAL</a><br />
   | <a href="tokens.html#character-literals">CHAR_LITERAL</a><br />
   | <a href="tokens.html#byte-literals">BYTE_LITERAL</a><br />
   | <a href="tokens.html#string-literals">STRING_LITERAL</a><br />
   | <a href="tokens.html#raw-string-literals">RAW_STRING_LITERAL</a><br />
   | <a href="tokens.html#byte-string-literals">BYTE_STRING_LITERAL</a><br />
   | <a href="tokens.html#raw-byte-string-literals">RAW_BYTE_STRING_LITERAL</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#integer-literals">INTEGER_LITERAL</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#floating-point-literals">FLOAT_LITERAL</a></p>
</blockquote>
<p><em>Literal patterns</em> match exactly the same value as what is created by the
literal. Since negative numbers are not <a href="expressions/literal-expr.html">literals</a>, literal patterns also
accept an optional minus sign before the literal, which acts like the negation
operator.</p>
<div class="warning">
<p>Floating-point literals are currently accepted, but due to the complexity of comparing
them, they are going to be forbidden on literal patterns in a future version of Rust (see
<a href="https://github.com/rust-lang/rust/issues/41620">issue #41620</a>).</p>
</div>
<p>Literal patterns are always refutable.</p>
<p>Examples:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>for i in -2..5 {
    match i {
        -1 =&gt; println!(&quot;It's minus one&quot;),
        1 =&gt; println!(&quot;It's a one&quot;),
        2|4 =&gt; println!(&quot;It's either a two or a four&quot;),
        _ =&gt; println!(&quot;Matched none of the arms&quot;),
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#identifier-patterns" id="identifier-patterns">Identifier patterns</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>IdentifierPattern</em> :<br />
      <code>ref</code><sup>?</sup> <code>mut</code><sup>?</sup> <a href="identifiers.html">IDENTIFIER</a> (<code>@</code> <a href="patterns.html#patterns"><em>Pattern</em></a> ) <sup>?</sup></p>
</blockquote>
<p>Identifier patterns bind the value they match to a variable. The identifier
must be unique within the pattern. The variable will shadow any variables of
the same name in scope. The scope of the new binding depends on the context of
where the pattern is used (such as a <code>let</code> binding or a <code>match</code> arm).</p>
<p>Patterns that consist of only an identifier, possibly with a <code>mut</code>, match any value and
bind it to that identifier. This is the most commonly used pattern in variable
declarations and parameters for functions and closures.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut variable = 10;
fn sum(x: i32, y: i32) -&gt; i32 {
<span class="boring">   x + y
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>To bind the matched value of a pattern to a variable, use the syntax <code>variable @ subpattern</code>. For example, the following binds the value 2 to <code>e</code> (not the
entire range: the range here is a range subpattern).</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 2;

match x {
    e @ 1 ..= 5 =&gt; println!(&quot;got a range element {}&quot;, e),
    _ =&gt; println!(&quot;anything&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>By default, identifier patterns bind a variable to a copy of or move from the
matched value depending on whether the matched value implements <a href="special-types-and-traits.html#copy"><code>Copy</code></a>.
This can be changed to bind to a reference by using the <code>ref</code> keyword,
or to a mutable reference using <code>ref mut</code>. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let a = Some(10);
</span>match a {
    None =&gt; (),
    Some(value) =&gt; (),
}

match a {
    None =&gt; (),
    Some(ref value) =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p>In the first match expression, the value is copied (or moved). In the second match,
a reference to the same memory location is bound to the variable value. This syntax is
needed because in destructuring subpatterns the <code>&amp;</code> operator can’t be applied to
the value’s fields. For example, the following is not valid:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let value = Person{ name: String::from(&quot;John&quot;), age: 23 };
</span>if let Person{name: &amp;person_name, age: 18..=150} = value { }
<span class="boring">}
</span></code></pre></pre>
<p>To make it valid, write the following:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Person {
</span><span class="boring">   name: String,
</span><span class="boring">   age: u8,
</span><span class="boring">}
</span><span class="boring">let value = Person{ name: String::from(&quot;John&quot;), age: 23 };
</span>if let Person{name: ref person_name, age: 18..=150} = value { }
<span class="boring">}
</span></code></pre></pre>
<p>Thus, <code>ref</code> is not something that is being matched against. Its objective is
exclusively to make the matched binding a reference, instead of potentially
copying or moving what was matched.</p>
<p><a href="patterns.html#path-patterns">Path patterns</a> take precedence over identifier patterns. It is an error
if <code>ref</code> or <code>ref mut</code> is specified and the identifier shadows a constant.</p>
<h3><a class="header" href="#binding-modes" id="binding-modes">Binding modes</a></h3>
<p>To service better ergonomics, patterns operate in different <em>binding modes</em> in
order to make it easier to bind references to values. When a reference value is matched by
a non-reference pattern, it will be automatically treated as a <code>ref</code> or <code>ref mut</code> binding.
Example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x: &amp;Option&lt;i32&gt; = &amp;Some(3);
if let Some(y) = x {
    // y was converted to `ref y` and its type is &amp;i32
}
<span class="boring">}
</span></code></pre></pre>
<p><em>Non-reference patterns</em> include all patterns except bindings, <a href="patterns.html#wildcard-pattern">wildcard
patterns</a> (<code>_</code>), <a href="patterns.html#path-patterns"><code>const</code> patterns</a> of reference types,
and <a href="patterns.html#reference-patterns">reference patterns</a>.</p>
<p>If a binding pattern does not explicitly have <code>ref</code>, <code>ref mut</code>, or <code>mut</code>, then it uses the
<em>default binding mode</em> to determine how the variable is bound. The default binding
mode starts in “move” mode which uses move semantics. When matching a pattern, the
compiler starts from the outside of the pattern and works inwards. Each time a reference
is matched using a non-reference pattern, it will automatically dereference the value and
update the default binding mode. References will set the default binding mode to <code>ref</code>.
Mutable references will set the mode to <code>ref mut</code> unless the mode is already <code>ref</code> in
which case it remains <code>ref</code>. If the automatically dereferenced value is still a reference,
it is dereferenced and this process repeats.</p>
<h2><a class="header" href="#wildcard-pattern" id="wildcard-pattern">Wildcard pattern</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>WildcardPattern</em> :<br />
   <code>_</code></p>
</blockquote>
<p>The <em>wildcard pattern</em> matches any value. It is used to ignore values when they don’t
matter. Inside other patterns it matches a single data field (as opposed to the <code>..</code>
which matches the remaining fields). Unlike identifier patterns, it does not copy, move
or borrow the value it matches.</p>
<p>Examples:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let x = 20;
</span>let (a, _) = (10, x);   // the x is always matched by _
<span class="boring">assert_eq!(a, 10);
</span>
// ignore a function/closure param
let real_part = |a: f64, _: f64| { a };

// ignore a field from a struct
<span class="boring">struct RGBA {
</span><span class="boring">   r: f32,
</span><span class="boring">   g: f32,
</span><span class="boring">   b: f32,
</span><span class="boring">   a: f32,
</span><span class="boring">}
</span><span class="boring">let color = RGBA{r: 0.4, g: 0.1, b: 0.9, a: 0.5};
</span>let RGBA{r: red, g: green, b: blue, a: _} = color;
<span class="boring">assert_eq!(color.r, red);
</span><span class="boring">assert_eq!(color.g, green);
</span><span class="boring">assert_eq!(color.b, blue);
</span>
// accept any Some, with any value
<span class="boring">let x = Some(10);
</span>if let Some(_) = x {}
<span class="boring">}
</span></code></pre></pre>
<p>The wildcard pattern is always irrefutable.</p>
<h2><a class="header" href="#range-patterns" id="range-patterns">Range patterns</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>RangePattern</em> :<br />
      <em>RangePatternBound</em> <code>..=</code> <em>RangePatternBound</em><br />
   | <em>RangePatternBound</em> <code>...</code> <em>RangePatternBound</em></p>
<p><em>RangePatternBound</em> :<br />
      <a href="tokens.html#character-literals">CHAR_LITERAL</a><br />
   | <a href="tokens.html#byte-literals">BYTE_LITERAL</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#integer-literals">INTEGER_LITERAL</a><br />
   | <code>-</code><sup>?</sup> <a href="tokens.html#floating-point-literals">FLOAT_LITERAL</a><br />
   | <a href="paths.html#paths-in-expressions"><em>PathInExpression</em></a><br />
   | <a href="paths.html#qualified-paths"><em>QualifiedPathInExpression</em></a></p>
</blockquote>
<p>Range patterns match values that are within the closed range defined by its lower and
upper bounds. For example, a pattern <code>'m'..='p'</code> will match only the values <code>'m'</code>, <code>'n'</code>,
<code>'o'</code>, and <code>'p'</code>. The bounds can be literals or paths that point to constant values.</p>
<p>A pattern a <code>..=</code> b must always have a ≤ b. It is an error to have a range pattern
<code>10..=0</code>, for example.</p>
<p>The <code>...</code> syntax is kept for backwards compatibility.</p>
<p>Range patterns only work on scalar types. The accepted types are:</p>
<ul>
<li>Integer types (u8, i8, u16, i16, usize, isize, etc.).</li>
<li>Character types (char).</li>
<li>Floating point types (f32 and f64). This is being deprecated and will not be available
in a future version of Rust (see
<a href="https://github.com/rust-lang/rust/issues/41620">issue #41620</a>).</li>
</ul>
<p>Examples:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let c = 'f';
</span>let valid_variable = match c {
    'a'..='z' =&gt; true,
    'A'..='Z' =&gt; true,
    'α'..='ω' =&gt; true,
    _ =&gt; false,
};

<span class="boring">let ph = 10;
</span>println!(&quot;{}&quot;, match ph {
    0..=6 =&gt; &quot;acid&quot;,
    7 =&gt; &quot;neutral&quot;,
    8..=14 =&gt; &quot;base&quot;,
    _ =&gt; unreachable!(),
});

// using paths to constants:
<span class="boring">const TROPOSPHERE_MIN : u8 = 6;
</span><span class="boring">const TROPOSPHERE_MAX : u8 = 20;
</span><span class="boring">
</span><span class="boring">const STRATOSPHERE_MIN : u8 = TROPOSPHERE_MAX + 1;
</span><span class="boring">const STRATOSPHERE_MAX : u8 = 50;
</span><span class="boring">
</span><span class="boring">const MESOSPHERE_MIN : u8 = STRATOSPHERE_MAX + 1;
</span><span class="boring">const MESOSPHERE_MAX : u8 = 85;
</span><span class="boring">
</span><span class="boring">let altitude = 70;
</span><span class="boring">
</span>println!(&quot;{}&quot;, match altitude {
    TROPOSPHERE_MIN..=TROPOSPHERE_MAX =&gt; &quot;troposphere&quot;,
    STRATOSPHERE_MIN..=STRATOSPHERE_MAX =&gt; &quot;stratosphere&quot;,
    MESOSPHERE_MIN..=MESOSPHERE_MAX =&gt; &quot;mesosphere&quot;,
    _ =&gt; &quot;outer space, maybe&quot;,
});

<span class="boring">pub mod binary {
</span><span class="boring">    pub const MEGA : u64 = 1024*1024;
</span><span class="boring">    pub const GIGA : u64 = 1024*1024*1024;
</span><span class="boring">}
</span><span class="boring">let n_items = 20_832_425;
</span><span class="boring">let bytes_per_item = 12;
</span>if let size @ binary::MEGA..=binary::GIGA = n_items * bytes_per_item {
    println!(&quot;It fits and occupies {} bytes&quot;, size);
}

<span class="boring">trait MaxValue {
</span><span class="boring">    const MAX: u64;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u8 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 8) - 1;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u16 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 16) - 1;
</span><span class="boring">}
</span><span class="boring">impl MaxValue for u32 {
</span><span class="boring">    const MAX: u64 = (1 &lt;&lt; 32) - 1;
</span><span class="boring">}
</span>// using qualified paths:
println!(&quot;{}&quot;, match 0xfacade {
    0 ..= &lt;u8 as MaxValue&gt;::MAX =&gt; &quot;fits in a u8&quot;,
    0 ..= &lt;u16 as MaxValue&gt;::MAX =&gt; &quot;fits in a u16&quot;,
    0 ..= &lt;u32 as MaxValue&gt;::MAX =&gt; &quot;fits in a u32&quot;,
    _ =&gt; &quot;too big&quot;,
});
<span class="boring">}
</span></code></pre></pre>
<p>Range patterns for (non-<code>usize</code> and -<code>isize</code>) integer and <code>char</code> types are irrefutable
when they span the entire set of possible values of a type. For example, <code>0u8..=255u8</code>
is irrefutable. The range of values for an integer type is the closed range from its
minimum to maximum value. The range of values for a <code>char</code> type are precisely those
ranges containing all Unicode Scalar Values: <code>'\u{0000}'..='\u{D7FF}'</code> and
<code>'\u{E000}'..='\u{10FFFF}'</code>.</p>
<h2><a class="header" href="#reference-patterns" id="reference-patterns">Reference patterns</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ReferencePattern</em> :<br />
   (<code>&amp;</code>|<code>&amp;&amp;</code>) <code>mut</code><sup>?</sup> <em>Pattern</em></p>
</blockquote>
<p>Reference patterns dereference the pointers that are being matched
and, thus, borrow them.</p>
<p>For example, these two matches on <code>x: &amp;i32</code> are equivalent:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let int_reference = &amp;3;

let a = match *int_reference { 0 =&gt; &quot;zero&quot;, _ =&gt; &quot;some&quot; };
let b = match int_reference { &amp;0 =&gt; &quot;zero&quot;, _ =&gt; &quot;some&quot; };

assert_eq!(a, b);
<span class="boring">}
</span></code></pre></pre>
<p>The grammar production for reference patterns has to match the token <code>&amp;&amp;</code> to match a
reference to a reference because it is a token by itself, not two <code>&amp;</code> tokens.</p>
<p>Adding the <code>mut</code> keyword dereferences a mutable reference. The mutability must match the
mutability of the reference.</p>
<p>Reference patterns are always irrefutable.</p>
<h2><a class="header" href="#struct-patterns" id="struct-patterns">Struct patterns</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>StructPattern</em> :<br />
   <a href="paths.html#paths-in-expressions"><em>PathInExpression</em></a> <code>{</code><br />
      <em>StructPatternElements</em> <sup>?</sup><br />
   <code>}</code></p>
<p><em>StructPatternElements</em> :<br />
      <em>StructPatternFields</em> (<code>,</code> | <code>,</code> <em>StructPatternEtCetera</em>)<sup>?</sup><br />
   | <em>StructPatternEtCetera</em></p>
<p><em>StructPatternFields</em> :<br />
   <em>StructPatternField</em> (<code>,</code> <em>StructPatternField</em>) <sup>*</sup></p>
<p><em>StructPatternField</em> :<br />
   <a href="attributes.html"><em>OuterAttribute</em></a> <sup>*</sup><br />
   (<br />
         <a href="tokens.html#integer-literals">TUPLE_INDEX</a> <code>:</code> <a href="patterns.html#patterns"><em>Pattern</em></a><br />
      | <a href="identifiers.html">IDENTIFIER</a> <code>:</code> <a href="patterns.html#patterns"><em>Pattern</em></a><br />
      | <code>ref</code><sup>?</sup> <code>mut</code><sup>?</sup> <a href="identifiers.html">IDENTIFIER</a><br />
   )</p>
<p><em>StructPatternEtCetera</em> :<br />
   <a href="attributes.html"><em>OuterAttribute</em></a> <sup>*</sup><br />
   <code>..</code></p>
</blockquote>
<p>Struct patterns match struct values that match all criteria defined by its subpatterns.
They are also used to <a href="patterns.html#destructuring">destructure</a> a struct.</p>
<p>On a struct pattern, the fields are referenced by name, index (in the case of tuple
structs) or ignored by use of <code>..</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point {
</span><span class="boring">    x: u32,
</span><span class="boring">    y: u32,
</span><span class="boring">}
</span><span class="boring">let s = Point {x: 1, y: 1};
</span><span class="boring">
</span>match s {
    Point {x: 10, y: 20} =&gt; (),
    Point {y: 10, x: 20} =&gt; (),    // order doesn't matter
    Point {x: 10, ..} =&gt; (),
    Point {..} =&gt; (),
}

<span class="boring">struct PointTuple (
</span><span class="boring">    u32,
</span><span class="boring">    u32,
</span><span class="boring">);
</span><span class="boring">let t = PointTuple(1, 2);
</span><span class="boring">
</span>match t {
    PointTuple {0: 10, 1: 20} =&gt; (),
    PointTuple {1: 10, 0: 20} =&gt; (),   // order doesn't matter
    PointTuple {0: 10, ..} =&gt; (),
    PointTuple {..} =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p>If <code>..</code> is not used, it is required to match all fields:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct {
</span><span class="boring">   a: i32,
</span><span class="boring">   b: char,
</span><span class="boring">   c: bool,
</span><span class="boring">}
</span><span class="boring">let mut struct_value = Struct{a: 10, b: 'X', c: false};
</span><span class="boring">
</span>match struct_value {
    Struct{a: 10, b: 'X', c: false} =&gt; (),
    Struct{a: 10, b: 'X', ref c} =&gt; (),
    Struct{a: 10, b: 'X', ref mut c} =&gt; (),
    Struct{a: 10, b: 'X', c: _} =&gt; (),
    Struct{a: _, b: _, c: _} =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>ref</code> and/or <code>mut</code> <em>IDENTIFIER</em> syntax matches any value and binds it to
a variable with the same name as the given field.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Struct {
</span><span class="boring">   a: i32,
</span><span class="boring">   b: char,
</span><span class="boring">   c: bool,
</span><span class="boring">}
</span><span class="boring">let struct_value = Struct{a: 10, b: 'X', c: false};
</span><span class="boring">
</span>let Struct{a: x, b: y, c: z} = struct_value;          // destructure all fields
<span class="boring">}
</span></code></pre></pre>
<p>A struct pattern is refutable when one of its subpatterns is refutable.</p>
<h2><a class="header" href="#tuple-struct-patterns" id="tuple-struct-patterns">Tuple struct patterns</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>TupleStructPattern</em> :<br />
   <a href="paths.html#paths-in-expressions"><em>PathInExpression</em></a> <code>(</code> <em>TupleStructItems</em><sup>?</sup> <code>)</code></p>
<p><em>TupleStructItems</em> :<br />
      <a href="patterns.html#patterns"><em>Pattern</em></a> ( <code>,</code> <a href="patterns.html#patterns"><em>Pattern</em></a> )<sup>*</sup> <code>,</code><sup>?</sup><br />
   | (<a href="patterns.html#patterns"><em>Pattern</em></a> <code>,</code>)<sup>*</sup> <code>..</code> ( (<code>,</code> <a href="patterns.html#patterns"><em>Pattern</em></a>)<sup>+</sup> <code>,</code><sup>?</sup> )<sup>?</sup></p>
</blockquote>
<p>Tuple struct patterns match tuple struct and enum values that match all criteria defined
by its subpatterns. They are also used to <a href="patterns.html#destructuring">destructure</a> a tuple struct or
enum value.</p>
<p>A tuple struct pattern is refutable when one of its subpatterns is refutable.</p>
<h2><a class="header" href="#tuple-patterns" id="tuple-patterns">Tuple patterns</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>TuplePattern</em> :<br />
   <code>(</code> <em>TuplePatternItems</em><sup>?</sup> <code>)</code></p>
<p><em>TuplePatternItems</em> :<br />
      <a href="patterns.html#patterns"><em>Pattern</em></a> <code>,</code><br />
   | <a href="patterns.html#patterns"><em>Pattern</em></a> (<code>,</code> <a href="patterns.html#patterns"><em>Pattern</em></a>)<sup>+</sup> <code>,</code><sup>?</sup><br />
   | (<a href="patterns.html#patterns"><em>Pattern</em></a> <code>,</code>)<sup>*</sup> <code>..</code> ( (<code>,</code> <a href="patterns.html#patterns"><em>Pattern</em></a>)<sup>+</sup> <code>,</code><sup>?</sup> )<sup>?</sup></p>
</blockquote>
<p>Tuple patterns match tuple values that match all criteria defined by its subpatterns.
They are also used to <a href="patterns.html#destructuring">destructure</a> a tuple.</p>
<p>This pattern is refutable when one of its subpatterns is refutable.</p>
<h2><a class="header" href="#grouped-patterns" id="grouped-patterns">Grouped patterns</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>GroupedPattern</em> :<br />
   <code>(</code> <a href="patterns.html#patterns"><em>Pattern</em></a> <code>)</code></p>
</blockquote>
<p>Enclosing a pattern in parentheses can be used to explicitly control the
precedence of compound patterns. For example, a reference pattern next to a
range pattern such as <code>&amp;0..=5</code> is ambiguous and is not allowed, but can be
expressed with parentheses.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let int_reference = &amp;3;
match int_reference {
    &amp;(0..=5) =&gt; (),
    _ =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#slice-patterns" id="slice-patterns">Slice patterns</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>SlicePattern</em> :<br />
   <code>[</code> <a href="patterns.html#patterns"><em>Pattern</em></a> (<code>,</code> <a href="patterns.html#patterns"><em>Pattern</em></a>)<sup>*</sup> <code>,</code><sup>?</sup> <code>]</code></p>
</blockquote>
<p>Slice patterns can match both arrays of fixed size and slices of dynamic size.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Fixed size
let arr = [1, 2, 3];
match arr {
    [1, _, _] =&gt; &quot;starts with one&quot;,
    [a, b, c] =&gt; &quot;starts with something else&quot;,
};
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Dynamic size
let v = vec![1, 2, 3];
match v[..] {
    [a, b] =&gt; { /* this arm will not apply because the length doesn't match */ }
    [a, b, c] =&gt; { /* this arm will apply */ }
    _ =&gt; { /* this wildcard is required, since the length is not known statically */ }
};
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#path-patterns" id="path-patterns">Path patterns</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>PathPattern</em> :<br />
      <a href="paths.html#paths-in-expressions"><em>PathInExpression</em></a><br />
   | <a href="paths.html#qualified-paths"><em>QualifiedPathInExpression</em></a></p>
</blockquote>
<p><em>Path patterns</em> are patterns that refer either to constant values or
to structs or enum variants that have no fields.</p>
<p>Unqualified path patterns can refer to:</p>
<ul>
<li>enum variants</li>
<li>structs</li>
<li>constants</li>
<li>associated constants</li>
</ul>
<p>Qualified path patterns can only refer to associated constants.</p>
<p>Constants cannot be a union type. Struct and enum constants must have
<code>#[derive(PartialEq, Eq)]</code> (not merely implemented).</p>
<p>Path patterns are irrefutable when they refer to structs or an enum variant when the enum
has only one variant or a constant whose type is irrefutable. They are refutable when they
refer to refutable constants or enum variants for enums with multiple variants.</p>
<h1><a class="header" href="#type-system" id="type-system">Type system</a></h1>
<script>
(function() {
    var fragments = {
        "#boolean-type": "types/boolean.html",
        "#numeric-types": "types/numeric.html",
        "#machine-types": "types/numeric.html",
        "#machine-dependent-integer-types": "types/numeric.html#machine-dependent-integer-types",
        "#textual-types": "types/textual.html",
        "#never-type": "types/never.html",
        "#tuple-types": "types/tuple.html",
        "#array-and-slice-types": "types/array.html",
        "#struct-types": "types/struct.html",
        "#enumerated-types": "types/enum.html",
        "#union-types": "types/union.html",
        "#pointer-types": "types/pointer.html",
        "#shared-references-": "types/pointer.html#shared-references-",
        "#mutable-references-": "types/pointer.html#mutable-references-mut",
        "#raw-pointers-const-and-mut": "types/pointer.html#raw-pointers-const-and-mut",
        "#smart-pointers": "types/pointer.html#smart-pointers",
        "#function-item-types": "types/function-item.html",
        "#function-pointer-types": "types/function-pointer.html",
        "#closure-types": "types/closure.html",
        "#capture-modes": "types/closure.html#capture-modes",
        "#unique-immutable-borrows-in-captures": "types/closure.html#unique-immutable-borrows-in-captures",
        "#call-traits-and-coercions": "types/closure.html#call-traits-and-coercions",
        "#other-traits": "types/closure.html#other-traits",
        "#trait-objects": "types/trait-object.html",
        "#trait-object-lifetime-bounds": "types/trait-object.html#trait-object-lifetime-bounds",
        "#impl-trait": "types/impl-trait.html",
        "#anonymous-type-parameters": "types/impl-trait.html#anonymous-type-parameters",
        "#abstract-return-types": "types/impl-trait.html#abstract-return-types",
        "#self-types": "paths.html#self-1",
        "#inferred-type": "types/inferred.html",
        "#type-parameters": "types/parameters.html",
    };
    var target = fragments[window.location.hash];
    if (target) {
        var url = window.location.toString();
        var base = url.substring(0, url.lastIndexOf('/'));
        window.location.replace(base + "/" + target);
    }
})();
</script>
<h1><a class="header" href="#types" id="types">Types</a></h1>
<p>Every variable, item, and value in a Rust program has a type. The <em>type</em> of a
<em>value</em> defines the interpretation of the memory holding it and the operations
that may be performed on the value.</p>
<p>Built-in types are tightly integrated into the language, in nontrivial ways
that are not possible to emulate in user-defined types. User-defined types have
limited capabilities.</p>
<p>The list of types is:</p>
<ul>
<li>Primitive types:
<ul>
<li><a href="types/boolean.html">Boolean</a> — <code>true</code> or <code>false</code></li>
<li><a href="types/numeric.html">Numeric</a> — integer and float</li>
<li><a href="types/textual.html">Textual</a> — <code>char</code> and <code>str</code></li>
<li><a href="types/never.html">Never</a> — <code>!</code> — a type with no values</li>
</ul>
</li>
<li>Sequence types:
<ul>
<li><a href="types/tuple.html">Tuple</a></li>
<li><a href="types/array.html">Array</a></li>
<li><a href="types/slice.html">Slice</a></li>
</ul>
</li>
<li>User-defined types:
<ul>
<li><a href="types/struct.html">Struct</a></li>
<li><a href="types/enum.html">Enum</a></li>
<li><a href="types/union.html">Union</a></li>
</ul>
</li>
<li>Function types:
<ul>
<li><a href="types/function-item.html">Functions</a></li>
<li><a href="types/closure.html">Closures</a></li>
</ul>
</li>
<li>Pointer types:
<ul>
<li><a href="types/pointer.html#shared-references-">References</a></li>
<li><a href="types/pointer.html#raw-pointers-const-and-mut">Raw pointers</a></li>
<li><a href="types/function-pointer.html">Function pointers</a></li>
</ul>
</li>
<li>Trait types:
<ul>
<li><a href="types/trait-object.html">Trait objects</a></li>
<li><a href="types/impl-trait.html">Impl trait</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#type-expressions" id="type-expressions">Type expressions</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>Type</em> :<br />
      <em>TypeNoBounds</em><br />
   | <a href="types/impl-trait.html"><em>ImplTraitType</em></a><br />
   | <a href="types/trait-object.html"><em>TraitObjectType</em></a></p>
<p><em>TypeNoBounds</em> :<br />
      <a href="types.html#parenthesized-types"><em>ParenthesizedType</em></a><br />
   | <a href="types/impl-trait.html"><em>ImplTraitTypeOneBound</em></a><br />
   | <a href="types/trait-object.html"><em>TraitObjectTypeOneBound</em></a><br />
   | <a href="paths.html#paths-in-types"><em>TypePath</em></a><br />
   | <a href="types/tuple.html#tuple-types"><em>TupleType</em></a><br />
   | <a href="types/never.html"><em>NeverType</em></a><br />
   | <a href="types/pointer.html#raw-pointers-const-and-mut"><em>RawPointerType</em></a><br />
   | <a href="types/pointer.html#shared-references-"><em>ReferenceType</em></a><br />
   | <a href="types/array.html"><em>ArrayType</em></a><br />
   | <a href="types/slice.html"><em>SliceType</em></a><br />
   | <a href="types/inferred.html"><em>InferredType</em></a><br />
   | <a href="paths.html#qualified-paths"><em>QualifiedPathInType</em></a><br />
   | <a href="types/function-pointer.html"><em>BareFunctionType</em></a><br />
   | <a href="macros.html#macro-invocation"><em>MacroInvocation</em></a></p>
</blockquote>
<p>A <em>type expression</em> as defined in the <em>Type</em> grammar rule above is the syntax
for referring to a type. It may refer to:</p>
<ul>
<li>Sequence types (<a href="types/tuple.html">tuple</a>, <a href="types/array.html">array</a>, <a href="types/slice.html">slice</a>).</li>
<li><a href="paths.html#paths-in-types">Type paths</a> which can reference:
<ul>
<li>Primitive types (<a href="types/boolean.html">boolean</a>, <a href="types/numeric.html">numeric</a>, <a href="types/textual.html">textual</a>).</li>
<li>Paths to an <a href="items.html">item</a> (<a href="types/struct.html">struct</a>, <a href="types/enum.html">enum</a>, <a href="types/union.html">union</a>, <a href="items/type-aliases.html">type alias</a>, <a href="types/trait-object.html">trait</a>).</li>
<li><a href="paths.html#self-1"><code>Self</code> path</a> where <code>Self</code> is the implementing type.</li>
<li>Generic <a href="types/parameters.html">type parameters</a>.</li>
</ul>
</li>
<li>Pointer types (<a href="types/pointer.html#shared-references-">reference</a>, <a href="types/pointer.html#raw-pointers-const-and-mut">raw pointer</a>, <a href="types/function-pointer.html">function pointer</a>).</li>
<li>The <a href="types/inferred.html">inferred type</a> which asks the compiler to determine the type.</li>
<li><a href="types.html#parenthesized-types">Parentheses</a> which are used for disambiguation.</li>
<li>Trait types: <a href="types/trait-object.html">Trait objects</a> and <a href="types/impl-trait.html">impl trait</a>.</li>
<li>The <a href="types/never.html">never</a> type.</li>
<li><a href="macros.html">Macros</a> which expand to a type expression.</li>
</ul>
<h3><a class="header" href="#parenthesized-types" id="parenthesized-types">Parenthesized types</a></h3>
<blockquote>
<p><em>ParenthesizedType</em> :<br />
   <code>(</code> <a href="types.html#type-expressions"><em>Type</em></a> <code>)</code></p>
</blockquote>
<p>In some situations the combination of types may be ambiguous. Use parentheses
around a type to avoid ambiguity. For example, the <code>+</code> operator for <a href="trait-bounds.html">type
boundaries</a> within a <a href="types/pointer.html#shared-references-">reference type</a> is unclear where the
boundary applies, so the use of parentheses is required. Grammar rules that
require this disambiguation use the <a href="types.html#type-expressions"><em>TypeNoBounds</em></a> rule instead of
<a href="types.html#type-expressions"><em>Type</em></a>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::any::Any;
</span>type T&lt;'a&gt; = &amp;'a (dyn Any + Send);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#recursive-types" id="recursive-types">Recursive types</a></h2>
<p>Nominal types — <a href="types/struct.html">structs</a>, <a href="types/enum.html">enumerations</a>, and <a href="types/union.html">unions</a> — may be
recursive. That is, each <code>enum</code> variant or <code>struct</code> or <code>union</code> field may
refer, directly or indirectly, to the enclosing <code>enum</code> or <code>struct</code> type
itself. Such recursion has restrictions:</p>
<ul>
<li>Recursive types must include a nominal type in the recursion (not mere <a href="items/type-aliases.html">type
aliases</a>, or other structural types such as <a href="types/array.html">arrays</a> or <a href="types/tuple.html">tuples</a>). So <code>type Rec = &amp;'static [Rec]</code> is not allowed.</li>
<li>The size of a recursive type must be finite; in other words the recursive
fields of the type must be <a href="types/pointer.html">pointer types</a>.</li>
<li>Recursive type definitions can cross module boundaries, but not module
<em>visibility</em> boundaries, or crate boundaries (in order to simplify the module
system and type checker).</li>
</ul>
<p>An example of a <em>recursive</em> type and its use:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum List&lt;T&gt; {
    Nil,
    Cons(T, Box&lt;List&lt;T&gt;&gt;)
}

let a: List&lt;i32&gt; = List::Cons(7, Box::new(List::Cons(13, Box::new(List::Nil))));
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#boolean-type" id="boolean-type">Boolean type</a></h1>
<p>The <code>bool</code> type is a datatype which can be either <code>true</code> or <code>false</code>. The boolean
type uses one byte of memory. It is used in comparisons and bitwise operations
like <code>&amp;</code>, <code>|</code>, and <code>!</code>.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = true;
    let y: bool = false; // with the boolean type annotation

    // Use of booleans in conditional expressions
    if x {
        println!(&quot;x is true&quot;);
    }
}
</code></pre></pre>
<h1><a class="header" href="#numeric-types" id="numeric-types">Numeric types</a></h1>
<h2><a class="header" href="#integer-types" id="integer-types">Integer types</a></h2>
<p>The unsigned integer types consist of:</p>
<table><thead><tr><th>Type</th><th>Minimum</th><th>Maximum</th></tr></thead><tbody>
<tr><td><code>u8</code></td><td>0</td><td>2<sup>8</sup>-1</td></tr>
<tr><td><code>u16</code></td><td>0</td><td>2<sup>16</sup>-1</td></tr>
<tr><td><code>u32</code></td><td>0</td><td>2<sup>32</sup>-1</td></tr>
<tr><td><code>u64</code></td><td>0</td><td>2<sup>64</sup>-1</td></tr>
<tr><td><code>u128</code></td><td>0</td><td>2<sup>128</sup>-1</td></tr>
</tbody></table>
<p>The signed two’s complement integer types consist of:</p>
<table><thead><tr><th>Type</th><th>Minimum</th><th>Maximum</th></tr></thead><tbody>
<tr><td><code>i8</code></td><td>-(2<sup>7</sup>)</td><td>2<sup>7</sup>-1</td></tr>
<tr><td><code>i16</code></td><td>-(2<sup>15</sup>)</td><td>2<sup>15</sup>-1</td></tr>
<tr><td><code>i32</code></td><td>-(2<sup>31</sup>)</td><td>2<sup>31</sup>-1</td></tr>
<tr><td><code>i64</code></td><td>-(2<sup>63</sup>)</td><td>2<sup>63</sup>-1</td></tr>
<tr><td><code>i128</code></td><td>-(2<sup>127</sup>)</td><td>2<sup>127</sup>-1</td></tr>
</tbody></table>
<h2><a class="header" href="#floating-point-types" id="floating-point-types">Floating-point types</a></h2>
<p>The IEEE 754-2008 “binary32” and “binary64” floating-point types are <code>f32</code> and
<code>f64</code>, respectively.</p>
<h2><a class="header" href="#machine-dependent-integer-types" id="machine-dependent-integer-types">Machine-dependent integer types</a></h2>
<p>The <code>usize</code> type is an unsigned integer type with the same number of bits as the
platform’s pointer type. It can represent every memory address in the process.</p>
<p>The <code>isize</code> type is a signed integer type with the same number of bits as the
platform’s pointer type. The theoretical upper bound on object and array size
is the maximum <code>isize</code> value. This ensures that <code>isize</code> can be used to calculate
differences between pointers into an object or array and can address every byte
within an object along with one byte past the end.</p>
<h1><a class="header" href="#textual-types" id="textual-types">Textual types</a></h1>
<p>The types <code>char</code> and <code>str</code> hold textual data.</p>
<p>A value of type <code>char</code> is a <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar value</a> (i.e. a code point that
is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to
0xD7FF or 0xE000 to 0x10FFFF range. A <code>[char]</code> is effectively a UCS-4 / UTF-32
string.</p>
<p>A value of type <code>str</code> is a Unicode string, represented as an array of 8-bit
unsigned bytes holding a sequence of UTF-8 code points. Since <code>str</code> is a
<a href="types/../dynamically-sized-types.html">dynamically sized type</a>, it is not a <em>first-class</em> type, but can only be
instantiated through a pointer type, such as <code>&amp;str</code>.</p>
<h1><a class="header" href="#never-type" id="never-type">Never type</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>NeverType</em> : <code>!</code></p>
</blockquote>
<p>The never type <code>!</code> is a type with no values, representing the result of
computations that never complete. Expressions of type <code>!</code> can be coerced into
any other type.</p>
<pre><pre class="playpen"><code class="language-rust should_panic">
<span class="boring">#![allow(unused_variables)]
</span>#![feature(never_type)]
<span class="boring">fn main() {
</span>let x: ! = panic!();
// Can be coerced into any type.
let y: u32 = x;
<span class="boring">}
</span></code></pre></pre>
<p><strong>NB.</strong> The never type was expected to be stabilized in 1.41, but due
to some last minute regressions detected the stabilization was
temporarily reverted. The <code>!</code> type can only appear in function return
types presently. See <a href="https://github.com/rust-lang/rust/issues/35121">the tracking
issue</a> for more
details.</p>
<h1><a class="header" href="#tuple-types" id="tuple-types">Tuple types</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>TupleType</em> :<br />
      <code>(</code> <code>)</code><br />
   | <code>(</code> ( <a href="types/../types.html#type-expressions"><em>Type</em></a> <code>,</code> )<sup>+</sup> <a href="types/../types.html#type-expressions"><em>Type</em></a><sup>?</sup> <code>)</code></p>
</blockquote>
<p>A tuple <em>type</em> is a heterogeneous product of other types, called the <em>elements</em>
of the tuple. It has no nominal name and is instead structurally typed.</p>
<p>Tuple types and values are denoted by listing the types or values of their
elements, respectively, in a parenthesized, comma-separated list.</p>
<p>Because tuple elements don’t have a name, they can only be accessed by
pattern-matching or by using <code>N</code> directly as a field to access the <code>N</code>th
element.</p>
<p>An example of a tuple type and its use:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type Pair&lt;'a&gt; = (i32, &amp;'a str);
let p: Pair&lt;'static&gt; = (10, &quot;ten&quot;);
let (a, b) = p;

assert_eq!(a, 10);
assert_eq!(b, &quot;ten&quot;);
assert_eq!(p.0, 10);
assert_eq!(p.1, &quot;ten&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>For historical reasons and convenience, the tuple type with no elements (<code>()</code>)
is often called ‘unit’ or ‘the unit type’.</p>
<h1><a class="header" href="#array-types" id="array-types">Array types</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ArrayType</em> :<br />
   <code>[</code> <a href="types/../types.html#type-expressions"><em>Type</em></a> <code>;</code> <a href="types/../expressions.html"><em>Expression</em></a> <code>]</code></p>
</blockquote>
<p>An array is a fixed-size sequence of <code>N</code> elements of type <code>T</code>. The array type
is written as <code>[T; N]</code>. The size is an expression that evaluates to a
<a href="types/numeric.html#machine-dependent-integer-types"><code>usize</code></a>.</p>
<p>Examples:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// A stack-allocated array
let array: [i32; 3] = [1, 2, 3];

// A heap-allocated array, coerced to a slice
let boxed_array: Box&lt;[i32]&gt; = Box::new([1, 2, 3]);
<span class="boring">}
</span></code></pre></pre>
<p>All elements of arrays are always initialized, and access to an array is
always bounds-checked in safe methods and operators.</p>
<blockquote>
<p>Note: The <a href="types/../../std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a> standard library type provides a heap-allocated resizable
array type.</p>
</blockquote>
<h1><a class="header" href="#slice-types" id="slice-types">Slice types</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>SliceType</em> :<br />
   <code>[</code> <a href="types/../types.html#type-expressions"><em>Type</em></a> <code>]</code></p>
</blockquote>
<p>A slice is a <a href="types/../dynamically-sized-types.html">dynamically sized type</a> representing a ‘view’ into a sequence of
elements of type <code>T</code>. The slice type is written as <code>[T]</code>.</p>
<p>To use a slice type it generally has to be used behind a pointer for example
as:</p>
<ul>
<li><code>&amp;[T]</code>, a ‘shared slice’, often just called a ‘slice’, it doesn’t own the
data it points to, it borrows it.</li>
<li><code>&amp;mut [T]</code>, a ‘mutable slice’, mutably borrows the data it points to.</li>
<li><code>Box&lt;[T]&gt;</code>, a ‘boxed slice’</li>
</ul>
<p>Examples:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// A heap-allocated array, coerced to a slice
let boxed_array: Box&lt;[i32]&gt; = Box::new([1, 2, 3]);

// A (shared) slice into an array
let slice: &amp;[i32] = &amp;boxed_array[..];
<span class="boring">}
</span></code></pre></pre>
<p>All elements of slices are always initialized, and access to a slice is always
bounds-checked in safe methods and operators.</p>
<h1><a class="header" href="#struct-types" id="struct-types">Struct types</a></h1>
<p>A <code>struct</code> <em>type</em> is a heterogeneous product of other types, called the
<em>fields</em> of the type.<sup class="footnote-reference"><a href="#structtype">1</a></sup></p>
<p>New instances of a <code>struct</code> can be constructed with a <a href="types/../expressions/struct-expr.html">struct expression</a>.</p>
<p>The memory layout of a <code>struct</code> is undefined by default to allow for compiler
optimizations like field reordering, but it can be fixed with the
<a href="types/../type-layout.html#representations"><code>repr</code> attribute</a>. In either case, fields may be given in any order in a
corresponding struct <em>expression</em>; the resulting <code>struct</code> value will always
have the same memory layout.</p>
<p>The fields of a <code>struct</code> may be qualified by <a href="types/../visibility-and-privacy.html">visibility modifiers</a>, to allow
access to data in a struct outside a module.</p>
<p>A <em>tuple struct</em> type is just like a struct type, except that the fields are
anonymous.</p>
<p>A <em>unit-like struct</em> type is like a struct type, except that it has no fields.
The one value constructed by the associated <a href="types/../expressions/struct-expr.html">struct expression</a> is the only
value that inhabits such a type.</p>
<div class="footnote-definition" id="structtype"><sup class="footnote-definition-label">1</sup>
<p>../<code>struct</code> types are analogous to <code>struct</code> types in C, the
<em>record</em> types of the ML family, or the <em>struct</em> types of the Lisp family.</p>
</div>
<h1><a class="header" href="#enumerated-types" id="enumerated-types">Enumerated types</a></h1>
<p>An <em>enumerated type</em> is a nominal, heterogeneous disjoint union type, denoted
by the name of an <a href="types/../items/enumerations.html"><code>enum</code> item</a>. <sup class="footnote-reference"><a href="#enumtype">1</a></sup></p>
<p>An <a href="types/../items/enumerations.html"><code>enum</code> item</a> declares both the type and a number of <em>variants</em>, each of
which is independently named and has the syntax of a struct, tuple struct or
unit-like struct.</p>
<p>New instances of an <code>enum</code> can be constructed in an <a href="types/../expressions/enum-variant-expr.html">enumeration variant
expression</a>.</p>
<p>Any <code>enum</code> value consumes as much memory as the largest variant for its
corresponding <code>enum</code> type, as well as the size needed to store a discriminant.</p>
<p>Enum types cannot be denoted <em>structurally</em> as types, but must be denoted by
named reference to an <a href="types/../items/enumerations.html"><code>enum</code> item</a>.</p>
<div class="footnote-definition" id="enumtype"><sup class="footnote-definition-label">1</sup>
<p>../The <code>enum</code> type is analogous to a <code>data</code> constructor declaration in
ML, or a <em>pick ADT</em> in Limbo.</p>
</div>
<h1><a class="header" href="#union-types" id="union-types">Union types</a></h1>
<p>A <em>union type</em> is a nominal, heterogeneous C-like union, denoted by the name of
a <a href="types/../items/unions.html"><code>union</code> item</a>.</p>
<p>Unions have no notion of an “active field”. Instead, every union access
transmutes parts of the content of the union to the type of the accessed
field. Since transmutes can cause unexpected or undefined behaviour, <code>unsafe</code> is
required to read from a union field or to write to a field that doesn’t
implement <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a>. See the <a href="types/../items/unions.html">item</a> documentation for further details.</p>
<p>The memory layout of a <code>union</code> is undefined by default, but the <code>#[repr(...)]</code>
attribute can be used to fix a layout.</p>
<h1><a class="header" href="#function-item-types" id="function-item-types">Function item types</a></h1>
<p>When referred to, a function item, or the constructor of a tuple-like struct or
enum variant, yields a zero-sized value of its <em>function item type</em>. That type
explicitly identifies the function - its name, its type arguments, and its
early-bound lifetime arguments (but not its late-bound lifetime arguments,
which are only assigned when the function is called) - so the value does not
need to contain an actual function pointer, and no indirection is needed when
the function is called.</p>
<p>There is no syntax that directly refers to a function item type, but the
compiler will display the type as something like <code>fn(u32) -&gt; i32 {fn_name}</code> in
error messages.</p>
<p>Because the function item type explicitly identifies the function, the item
types of different functions - different items, or the same item with different
generics - are distinct, and mixing them will create a type error:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail E0308">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;() { }
let x = &amp;mut foo::&lt;i32&gt;;
*x = foo::&lt;u32&gt;; //~ ERROR mismatched types
<span class="boring">}
</span></code></pre></pre>
<p>However, there is a <a href="types/../type-coercions.html">coercion</a> from function items to <a href="types/function-pointer.html">function pointers</a> with
the same signature, which is triggered not only when a function item is used
when a function pointer is directly expected, but also when different function
item types with the same signature meet in different arms of the same <code>if</code> or
<code>match</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let want_i32 = false;
</span><span class="boring">fn foo&lt;T&gt;() { }
</span>
// `foo_ptr_1` has function pointer type `fn()` here
let foo_ptr_1: fn() = foo::&lt;i32&gt;;

// ... and so does `foo_ptr_2` - this type-checks.
let foo_ptr_2 = if want_i32 {
    foo::&lt;i32&gt;
} else {
    foo::&lt;u32&gt;
};
<span class="boring">}
</span></code></pre></pre>
<p>All function items implement <a href="types/../../std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="types/../../std/ops/trait.FnMut.html"><code>FnMut</code></a>, <a href="types/../../std/ops/trait.FnOnce.html"><code>FnOnce</code></a>, <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a>,
<a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a>, <a href="types/../special-types-and-traits.html#send"><code>Send</code></a>, and <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a>.</p>
<h1><a class="header" href="#closure-types" id="closure-types">Closure types</a></h1>
<p>A <a href="types/../expressions/closure-expr.html">closure expression</a> produces a closure value with a unique, anonymous type
that cannot be written out. A closure type is approximately equivalent to a
struct which contains the captured variables. For instance, the following
closure:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn f&lt;F : FnOnce() -&gt; String&gt; (g: F) {
    println!(&quot;{}&quot;, g());
}

let mut s = String::from(&quot;foo&quot;);
let t = String::from(&quot;bar&quot;);

f(|| {
    s += &amp;*t;
    s
});
// Prints &quot;foobar&quot;.
<span class="boring">}
</span></code></pre></pre>
<p>generates a closure type roughly like the following:</p>
<!-- ignore: simplified, requires unboxed_closures, fn_traits -->
<pre><code class="language-rust ignore">struct Closure&lt;'a&gt; {
    s : String,
    t : &amp;'a String,
}

impl&lt;'a&gt; FnOnce&lt;()&gt; for Closure&lt;'a&gt; {
    type Output = String;
    fn call_once(self) -&gt; String {
        self.s += &amp;*self.t;
        self.s
    }
}
</code></pre>
<p>so that the call to <code>f</code> works as if it were:</p>
<!-- ignore: continuation of above -->
<pre><code class="language-rust ignore">f(Closure{s: s, t: &amp;t});
</code></pre>
<h2><a class="header" href="#capture-modes-1" id="capture-modes-1">Capture modes</a></h2>
<p>The compiler prefers to capture a closed-over variable by immutable borrow,
followed by unique immutable borrow (see below), by mutable borrow, and finally
by move. It will pick the first choice of these that allows the closure to
compile. The choice is made only with regards to the contents of the closure
expression; the compiler does not take into account surrounding code, such as
the lifetimes of involved variables.</p>
<p>If the <code>move</code> keyword is used, then all captures are by move or, for <code>Copy</code>
types, by copy, regardless of whether a borrow would work. The <code>move</code> keyword is
usually used to allow the closure to outlive the captured values, such as if the
closure is being returned or used to spawn a new thread.</p>
<p>Composite types such as structs, tuples, and enums are always captured entirely,
not by individual fields. It may be necessary to borrow into a local variable in
order to capture a single field:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">
</span>struct SetVec {
    set: HashSet&lt;u32&gt;,
    vec: Vec&lt;u32&gt;
}

impl SetVec {
    fn populate(&amp;mut self) {
        let vec = &amp;mut self.vec;
        self.set.iter().for_each(|&amp;n| {
            vec.push(n);
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>If, instead, the closure were to use <code>self.vec</code> directly, then it would attempt
to capture <code>self</code> by mutable reference. But since <code>self.set</code> is already
borrowed to iterate over, the code would not compile.</p>
<h2><a class="header" href="#unique-immutable-borrows-in-captures" id="unique-immutable-borrows-in-captures">Unique immutable borrows in captures</a></h2>
<p>Captures can occur by a special kind of borrow called a <em>unique immutable
borrow</em>, which cannot be used anywhere else in the language and cannot be
written out explicitly. It occurs when modifying the referent of a mutable
reference, as in the following example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut b = false;
let x = &amp;mut b;
{
    let mut c = || { *x = true; };
    // The following line is an error:
    // let y = &amp;x;
    c();
}
let z = &amp;x;
<span class="boring">}
</span></code></pre></pre>
<p>In this case, borrowing <code>x</code> mutably is not possible, because <code>x</code> is not <code>mut</code>.
But at the same time, borrowing <code>x</code> immutably would make the assignment illegal,
because a <code>&amp; &amp;mut</code> reference may not be unique, so it cannot safely be used to
modify a value. So a unique immutable borrow is used: it borrows <code>x</code> immutably,
but like a mutable borrow, it must be unique. In the above example, uncommenting
the declaration of <code>y</code> will produce an error because it would violate the
uniqueness of the closure’s borrow of <code>x</code>; the declaration of z is valid because
the closure’s lifetime has expired at the end of the block, releasing the borrow.</p>
<h2><a class="header" href="#call-traits-and-coercions" id="call-traits-and-coercions">Call traits and coercions</a></h2>
<p>Closure types all implement <a href="types/../../std/ops/trait.FnOnce.html"><code>FnOnce</code></a>, indicating that they can be called once
by consuming ownership of the closure. Additionally, some closures implement
more specific call traits:</p>
<ul>
<li>
<p>A closure which does not move out of any captured variables implements
<a href="types/../../std/ops/trait.FnMut.html"><code>FnMut</code></a>, indicating that it can be called by mutable reference.</p>
</li>
<li>
<p>A closure which does not mutate or move out of any captured variables
implements <a href="types/../../std/ops/trait.Fn.html"><code>Fn</code></a>, indicating that it can be called by shared reference.</p>
</li>
</ul>
<blockquote>
<p>Note: <code>move</code> closures may still implement <a href="types/../../std/ops/trait.Fn.html"><code>Fn</code></a> or <a href="types/../../std/ops/trait.FnMut.html"><code>FnMut</code></a>, even though
they capture variables by move. This is because the traits implemented by a
closure type are determined by what the closure does with captured values,
not how it captures them.</p>
</blockquote>
<p><em>Non-capturing closures</em> are closures that don’t capture anything from their
environment. They can be coerced to function pointers (<code>fn</code>) with the matching
signature.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let add = |x, y| x + y;

let mut x = add(5,7);

type Binop = fn(i32, i32) -&gt; i32;
let bo: Binop = add;
x = bo(5,7);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#other-traits" id="other-traits">Other traits</a></h2>
<p>All closure types implement <a href="types/../special-types-and-traits.html#sized"><code>Sized</code></a>. Additionally, closure types implement the
following traits if allowed to do so by the types of the captures it stores:</p>
<ul>
<li><a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a></li>
<li><a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a></li>
<li><a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a></li>
<li><a href="types/../special-types-and-traits.html#send"><code>Send</code></a></li>
</ul>
<p>The rules for <a href="types/../special-types-and-traits.html#send"><code>Send</code></a> and <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a> match those for normal struct types, while
<a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a> and <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a> behave as if <a href="types/../attributes/derive.html">derived</a>. For <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a>, the order of
cloning of the captured variables is left unspecified.</p>
<p>Because captures are often by reference, the following general rules arise:</p>
<ul>
<li>A closure is <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a> if all captured variables are <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a>.</li>
<li>A closure is <a href="types/../special-types-and-traits.html#send"><code>Send</code></a> if all variables captured by non-unique immutable
reference are <a href="types/../special-types-and-traits.html#sync"><code>Sync</code></a>, and all values captured by unique immutable or mutable
reference, copy, or move are <a href="types/../special-types-and-traits.html#send"><code>Send</code></a>.</li>
<li>A closure is <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a> or <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a> if it does not capture any values by
unique immutable or mutable reference, and if all values it captures by copy
or move are <a href="types/../special-types-and-traits.html#clone"><code>Clone</code></a> or <a href="types/../special-types-and-traits.html#copy"><code>Copy</code></a>, respectively.</li>
</ul>
<h1><a class="header" href="#pointer-types" id="pointer-types">Pointer types</a></h1>
<p>All pointers in Rust are explicit first-class values. They can be moved or
copied, stored into data structs, and returned from functions.</p>
<h2><a class="header" href="#references--and-mut" id="references--and-mut">References (<code>&amp;</code> and <code>&amp;mut</code>)</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ReferenceType</em> :<br />
   <code>&amp;</code> <a href="types/../trait-bounds.html"><em>Lifetime</em></a><sup>?</sup> <code>mut</code><sup>?</sup> <a href="types/../types.html#type-expressions"><em>TypeNoBounds</em></a></p>
</blockquote>
<h3><a class="header" href="#shared-references-" id="shared-references-">Shared references (<code>&amp;</code>)</a></h3>
<p>These point to memory <em>owned by some other value</em>. When a shared reference to
a value is created it prevents direct mutation of the value. <a href="types/../interior-mutability.html">Interior
mutability</a> provides an exception for this in certain circumstances. As the
name suggests, any number of shared references to a value may exist. A shared
reference type is written <code>&amp;type</code>, or <code>&amp;'a type</code> when you need to specify an
explicit lifetime. Copying a reference is a “shallow” operation: it involves
only copying the pointer itself, that is, pointers are <code>Copy</code>. Releasing a
reference has no effect on the value it points to, but referencing of a
<a href="types/../expressions.html#temporary-lifetimes">temporary value</a> will keep it alive during the scope of the reference itself.</p>
<h3><a class="header" href="#mutable-references-mut" id="mutable-references-mut">Mutable references (<code>&amp;mut</code>)</a></h3>
<p>These also point to memory owned by some other value. A mutable reference type
is written <code>&amp;mut type</code> or <code>&amp;'a mut type</code>. A mutable reference (that hasn’t been
borrowed) is the only way to access the value it points to, so is not <code>Copy</code>.</p>
<h2><a class="header" href="#raw-pointers-const-and-mut" id="raw-pointers-const-and-mut">Raw pointers (<code>*const</code> and <code>*mut</code>)</a></h2>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>RawPointerType</em> :<br />
   <code>*</code> ( <code>mut</code> | <code>const</code> ) <a href="types/../types.html#type-expressions"><em>TypeNoBounds</em></a></p>
</blockquote>
<p>Raw pointers are pointers without safety or liveness guarantees. Raw pointers
are written as <code>*const T</code> or <code>*mut T</code>, for example <code>*const i32</code> means a raw
pointer to a 32-bit integer. Copying or dropping a raw pointer has no effect
on the lifecycle of any other value. Dereferencing a raw pointer is an
<a href="types/../unsafety.html"><code>unsafe</code> operation</a>, this can also be used to convert a raw pointer to a
reference by reborrowing it (<code>&amp;*</code> or <code>&amp;mut *</code>). Raw pointers are generally
discouraged in Rust code; they exist to support interoperability with foreign
code, and writing performance-critical or low-level functions.</p>
<p>When comparing raw pointers they are compared by their address, rather than by
what they point to. When comparing raw pointers to <a href="types/../dynamically-sized-types.html">dynamically sized types</a> they
also have their additional data compared.</p>
<h2><a class="header" href="#smart-pointers" id="smart-pointers">Smart Pointers</a></h2>
<p>The standard library contains additional ‘smart pointer’ types beyond references
and raw pointers.</p>
<h1><a class="header" href="#function-pointer-types" id="function-pointer-types">Function pointer types</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>BareFunctionType</em> :<br />
   <a href="types/../items/generics.html#where-clauses"><em>ForLifetimes</em></a><sup>?</sup> <a href="types/../items/functions.html"><em>FunctionQualifiers</em></a> <code>fn</code><br />
       <code>(</code> <em>FunctionParametersMaybeNamedVariadic</em><sup>?</sup> <code>)</code> <em>BareFunctionReturnType</em><sup>?</sup></p>
<p><em>BareFunctionReturnType</em>:<br />
   <code>-&gt;</code> <a href="types/../types.html#type-expressions"><em>TypeNoBounds</em></a></p>
<p><em>FunctionParametersMaybeNamedVariadic</em> :<br />
   <em>MaybeNamedFunctionParameters</em> | <em>MaybeNamedFunctionParametersVariadic</em></p>
<p><em>MaybeNamedFunctionParameters</em> :<br />
   <em>MaybeNamedParam</em> ( <code>,</code> <em>MaybeNamedParam</em> )<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>MaybeNamedParam</em> :<br />
   <a href="types/../attributes.html"><em>OuterAttribute</em></a><sup>*</sup> ( ( <a href="types/../identifiers.html">IDENTIFIER</a> | <code>_</code> ) <code>:</code> )<sup>?</sup> <a href="types/../types.html#type-expressions"><em>Type</em></a></p>
<p><em>MaybeNamedFunctionParametersVariadic</em> :<br />
   ( <em>MaybeNamedParam</em> <code>,</code> )<sup>*</sup> <em>MaybeNamedParam</em> <code>,</code> <a href="types/../attributes.html"><em>OuterAttribute</em></a><sup>*</sup> <code>...</code></p>
</blockquote>
<p>Function pointer types, written using the <code>fn</code> keyword, refer to a function
whose identity is not necessarily known at compile-time. They can be created
via a coercion from both <a href="types/function-item.html">function items</a> and non-capturing <a href="types/closure.html">closures</a>.</p>
<p>The <code>unsafe</code> qualifier indicates that the type’s value is an <a href="types/../unsafe-functions.html">unsafe
function</a>, and the <code>extern</code> qualifier indicates it is an <a href="types/../items/functions.html#extern-function-qualifier">extern function</a>.</p>
<p>Variadic parameters can only be specified with <a href="types/../items/external-blocks.html"><code>extern</code></a> function types with
the <code>&quot;C&quot;</code> or <code>&quot;cdecl&quot;</code> calling convention.</p>
<p>An example where <code>Binop</code> is defined as a function pointer type:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn add(x: i32, y: i32) -&gt; i32 {
    x + y
}

let mut x = add(5,7);

type Binop = fn(i32, i32) -&gt; i32;
let bo: Binop = add;
x = bo(5,7);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#attributes-on-function-pointer-parameters" id="attributes-on-function-pointer-parameters">Attributes on function pointer parameters</a></h2>
<p>Attributes on function pointer parameters follow the same rules and
restrictions as <a href="types/../items/functions.html#attributes-on-function-parameters">regular function parameters</a>.</p>
<h1><a class="header" href="#trait-objects" id="trait-objects">Trait objects</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>TraitObjectType</em> :<br />
   <code>dyn</code><sup>?</sup> <a href="types/../trait-bounds.html"><em>TypeParamBounds</em></a></p>
<p><em>TraitObjectTypeOneBound</em> :<br />
   <code>dyn</code><sup>?</sup> <a href="types/../trait-bounds.html"><em>TraitBound</em></a></p>
</blockquote>
<p>A <em>trait object</em> is an opaque value of another type that implements a set of
traits. The set of traits is made up of an <a href="types/../items/traits.html#object-safety">object safe</a> <em>base trait</em> plus any
number of <a href="types/../special-types-and-traits.html#auto-traits">auto traits</a>.</p>
<p>Trait objects implement the base trait, its auto traits, and any <a href="types/../items/traits.html#supertraits">supertraits</a>
of the base trait.</p>
<p>Trait objects are written as the optional keyword <code>dyn</code> followed by a set of
trait bounds, but with the following restrictions on the trait bounds. All
traits except the first trait must be auto traits, there may not be more than
one lifetime, and opt-out bounds (e.g. <code>?Sized</code>) are not allowed. Furthermore,
paths to traits may be parenthesized.</p>
<p>For example, given a trait <code>Trait</code>, the following are all trait objects:</p>
<ul>
<li><code>Trait</code></li>
<li><code>dyn Trait</code></li>
<li><code>dyn Trait + Send</code></li>
<li><code>dyn Trait + Send + Sync</code></li>
<li><code>dyn Trait + 'static</code></li>
<li><code>dyn Trait + Send + 'static</code></li>
<li><code>dyn Trait +</code></li>
<li><code>dyn 'static + Trait</code>.</li>
<li><code>dyn (Trait)</code></li>
</ul>
<blockquote>
<p><strong>Edition Differences</strong>: In the 2015 edition, if the first bound of the
trait object is a path that starts with <code>::</code>, then the <code>dyn</code> will be treated
as a part of the path. The first path can be put in parenthesis to get
around this. As such, if you want a trait object with the trait
<code>::your_module::Trait</code>, you should write it as <code>dyn (::your_module::Trait)</code>.</p>
<p>Beginning in the 2018 edition, <code>dyn</code> is a true keyword and is not allowed in
paths, so the parentheses are not necessary.</p>
</blockquote>
<blockquote>
<p>Note: For clarity, it is recommended to always use the <code>dyn</code> keyword on your
trait objects unless your codebase supports compiling with Rust 1.26 or lower.</p>
</blockquote>
<p>Two trait object types alias each other if the base traits alias each other and
if the sets of auto traits are the same and the lifetime bounds are the same.
For example, <code>dyn Trait + Send + UnwindSafe</code> is the same as
<code>dyn Trait + Unwindsafe + Send</code>.</p>
<p>Due to the opaqueness of which concrete type the value is of, trait objects are
<a href="types/../dynamically-sized-types.html">dynamically sized types</a>. Like all
<abbr title="dynamically sized types">DSTs</abbr>, trait objects are used
behind some type of pointer; for example <code>&amp;dyn SomeTrait</code> or
<code>Box&lt;dyn SomeTrait&gt;</code>. Each instance of a pointer to a trait object includes:</p>
<ul>
<li>a pointer to an instance of a type <code>T</code> that implements <code>SomeTrait</code></li>
<li>a <em>virtual method table</em>, often just called a <em>vtable</em>, which contains, for
each method of <code>SomeTrait</code> and its <a href="types/../items/traits.html#supertraits">supertraits</a> that <code>T</code> implements, a
pointer to <code>T</code>‘s implementation (i.e. a function pointer).</li>
</ul>
<p>The purpose of trait objects is to permit “late binding” of methods. Calling a
method on a trait object results in virtual dispatch at runtime: that is, a
function pointer is loaded from the trait object vtable and invoked indirectly.
The actual implementation for each vtable entry can vary on an object-by-object
basis.</p>
<p>An example of a trait object:</p>
<pre><pre class="playpen"><code class="language-rust">trait Printable {
    fn stringify(&amp;self) -&gt; String;
}

impl Printable for i32 {
    fn stringify(&amp;self) -&gt; String { self.to_string() }
}

fn print(a: Box&lt;dyn Printable&gt;) {
    println!(&quot;{}&quot;, a.stringify());
}

fn main() {
    print(Box::new(10) as Box&lt;dyn Printable&gt;);
}
</code></pre></pre>
<p>In this example, the trait <code>Printable</code> occurs as a trait object in both the
type signature of <code>print</code>, and the cast expression in <code>main</code>.</p>
<h2><a class="header" href="#trait-object-lifetime-bounds" id="trait-object-lifetime-bounds">Trait Object Lifetime Bounds</a></h2>
<p>Since a trait object can contain references, the lifetimes of those references
need to be expressed as part of the trait object. This lifetime is written as
<code>Trait + 'a</code>. There are <a href="types/../lifetime-elision.html#default-trait-object-lifetimes">defaults</a> that allow this lifetime to usually be
inferred with a sensible choice.</p>
<h1><a class="header" href="#impl-trait" id="impl-trait">Impl trait</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>ImplTraitType</em> : <code>impl</code> <a href="types/../trait-bounds.html"><em>TypeParamBounds</em></a></p>
<p><em>ImplTraitTypeOneBound</em> : <code>impl</code> <a href="types/../trait-bounds.html"><em>TraitBound</em></a></p>
</blockquote>
<h2><a class="header" href="#anonymous-type-parameters" id="anonymous-type-parameters">Anonymous type parameters</a></h2>
<blockquote>
<p>Note: This section is a placeholder for more comprehensive reference
material.</p>
</blockquote>
<blockquote>
<p>Note: This is often called “impl Trait in argument position”.</p>
</blockquote>
<p>Functions can declare an argument to be an anonymous type parameter where the
callee must provide a type that has the bounds declared by the anonymous type
parameter and the function can only use the methods available by the trait
bounds of the anonymous type parameter.</p>
<p>They are written as <code>impl</code> followed by a set of trait bounds.</p>
<h2><a class="header" href="#abstract-return-types" id="abstract-return-types">Abstract return types</a></h2>
<blockquote>
<p>Note: This section is a placeholder for more comprehensive reference
material.</p>
</blockquote>
<blockquote>
<p>Note: This is often called “impl Trait in return position”.</p>
</blockquote>
<p>Functions, except for associated trait functions, can return an abstract
return type. These  types stand in for another concrete type where the
use-site may only use the trait methods declared by the trait bounds of the
type.</p>
<p>They are written as <code>impl</code> followed by a set of trait bounds.</p>
<h1><a class="header" href="#type-parameters" id="type-parameters">Type parameters</a></h1>
<p>Within the body of an item that has type parameter declarations, the names of
its type parameters are types:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn to_vec&lt;A: Clone&gt;(xs: &amp;[A]) -&gt; Vec&lt;A&gt; {
    if xs.is_empty() {
        return vec![];
    }
    let first: A = xs[0].clone();
    let mut rest: Vec&lt;A&gt; = to_vec(&amp;xs[1..]);
    rest.insert(0, first);
    rest
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, <code>first</code> has type <code>A</code>, referring to <code>to_vec</code>‘s <code>A</code> type parameter; and
<code>rest</code> has type <code>Vec&lt;A&gt;</code>, a vector with element type <code>A</code>.</p>
<h1><a class="header" href="#inferred-type" id="inferred-type">Inferred type</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>InferredType</em> : <code>_</code></p>
</blockquote>
<p>The inferred type asks the compiler to infer the type if possible based on the
surrounding information available. It cannot be used in item signatures. It is
often used in generic arguments:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x: Vec&lt;_&gt; = (0..10).collect();
<span class="boring">}
</span></code></pre></pre>
<!--
  What else should be said here?
  The only documentation I am aware of is https://rustc-dev-guide.rust-lang.org/type-inference.html
  There should be a broader discussion of type inference somewhere.
-->
<h1><a class="header" href="#dynamically-sized-types" id="dynamically-sized-types">Dynamically Sized Types</a></h1>
<p>Most types have a fixed size that is known at compile time and implement the
trait <a href="special-types-and-traits.html#sized"><code>Sized</code></a>. A type with a size that is known only at run-time is
called a <em>dynamically sized type</em> (<em>DST</em>) or, informally, an unsized type.
<a href="types/slice.html">Slices</a> and <a href="types/trait-object.html">trait objects</a> are two examples of <abbr title="dynamically sized
types">DSTs</abbr>. Such types can only be used in certain cases:</p>
<ul>
<li><a href="types/pointer.html">Pointer types</a> to <abbr title="dynamically sized types">DSTs</abbr> are
sized but have twice the size of pointers to sized types
<ul>
<li>Pointers to slices also store the number of elements of the slice.</li>
<li>Pointers to trait objects also store a pointer to a vtable.</li>
</ul>
</li>
<li><abbr title="dynamically sized types">DSTs</abbr> can be provided as
type arguments when a bound of <code>?Sized</code>. By default any type parameter
has a <code>Sized</code> bound.</li>
<li>Traits may be implemented for <abbr title="dynamically sized
  types">DSTs</abbr>. Unlike type parameters <code>Self: ?Sized</code> by default in trait
definitions.</li>
<li>Structs may contain a <abbr title="dynamically sized type">DST</abbr> as the
last field, this makes the struct itself a
<abbr title="dynamically sized type">DST</abbr>.</li>
</ul>
<blockquote>
<p><strong>Note</strong>: <a href="variables.html">variables</a>, function parameters, <a href="items/constant-items.html">const</a> items, and <a href="items/static-items.html">static</a> items must be
<code>Sized</code>.</p>
</blockquote>
<h1><a class="header" href="#type-layout" id="type-layout">Type Layout</a></h1>
<p>The layout of a type is its size, alignment, and the relative offsets of its
fields. For enums, how the discriminant is laid out and interpreted is also part
of type layout.</p>
<p>Type layout can be changed with each compilation. Instead of trying to document
exactly what is done, we only document what is guaranteed today.</p>
<h2><a class="header" href="#size-and-alignment" id="size-and-alignment">Size and Alignment</a></h2>
<p>All values have an alignment and size.</p>
<p>The <em>alignment</em> of a value specifies what addresses are valid to store the value
at. A value of alignment <code>n</code> must only be stored at an address that is a
multiple of n. For example, a value with an alignment of 2 must be stored at an
even address, while a value with an alignment of 1 can be stored at any address.
Alignment is measured in bytes, and must be at least 1, and always a power of 2.
The alignment of a value can be checked with the <a href="../std/mem/fn.align_of_val.html"><code>align_of_val</code></a> function.</p>
<p>The <em>size</em> of a value is the offset in bytes between successive elements in an
array with that item type including alignment padding. The size of a value is
always a multiple of its alignment. The size of a value can be checked with the
<a href="../std/mem/fn.size_of_val.html"><code>size_of_val</code></a> function.</p>
<p>Types where all values have the same size and alignment known at compile time
implement the <a href="../std/marker/trait.Sized.html"><code>Sized</code></a> trait and can be checked with the <a href="../std/mem/fn.size_of.html"><code>size_of</code></a> and
<a href="../std/mem/fn.align_of.html"><code>align_of</code></a> functions. Types that are not <a href="../std/marker/trait.Sized.html"><code>Sized</code></a> are known as <a href="dynamically-sized-types.html">dynamically
sized types</a>. Since all values of a <code>Sized</code> type share the same size and
alignment, we refer to those shared values as the size of the type and the
alignment of the type respectively.</p>
<h2><a class="header" href="#primitive-data-layout" id="primitive-data-layout">Primitive Data Layout</a></h2>
<p>The size of most primitives is given in this table.</p>
<table><thead><tr><th>Type</th><th><code>size_of::&lt;Type&gt;()</code></th></tr></thead><tbody>
<tr><td><code>bool</code></td><td>1</td></tr>
<tr><td><code>u8</code> / <code>i8</code></td><td>1</td></tr>
<tr><td><code>u16</code> / <code>i16</code></td><td>2</td></tr>
<tr><td><code>u32</code> / <code>i32</code></td><td>4</td></tr>
<tr><td><code>u64</code> / <code>i64</code></td><td>8</td></tr>
<tr><td><code>u128</code> / <code>i128</code></td><td>16</td></tr>
<tr><td><code>f32</code></td><td>4</td></tr>
<tr><td><code>f64</code></td><td>8</td></tr>
<tr><td><code>char</code></td><td>4</td></tr>
</tbody></table>
<p><code>usize</code> and <code>isize</code> have a size big enough to contain every address on the
target platform. For example, on a 32 bit target, this is 4 bytes and on a 64
bit target, this is 8 bytes.</p>
<p>Most primitives are generally aligned to their size, although this is
platform-specific behavior. In particular, on x86 u64 and f64 are only
aligned to 32 bits.</p>
<h2><a class="header" href="#pointers-and-references-layout" id="pointers-and-references-layout">Pointers and References Layout</a></h2>
<p>Pointers and references have the same layout. Mutability of the pointer or
reference does not change the layout.</p>
<p>Pointers to sized types have the same size and alignment as <code>usize</code>.</p>
<p>Pointers to unsized types are sized. The size and alignment is guaranteed to be
at least equal to the size and alignment of a pointer.</p>
<blockquote>
<p>Note: Though you should not rely on this, all pointers to
<abbr title="Dynamically Sized Types">DSTs</abbr> are currently twice the
size of the size of <code>usize</code> and have the same alignment.</p>
</blockquote>
<h2><a class="header" href="#array-layout" id="array-layout">Array Layout</a></h2>
<p>Arrays are laid out so that the <code>nth</code> element of the array is offset from the
start of the array by <code>n * the size of the type</code> bytes. An array of <code>[T; n]</code>
has a size of <code>size_of::&lt;T&gt;() * n</code> and the same alignment of <code>T</code>.</p>
<h2><a class="header" href="#slice-layout" id="slice-layout">Slice Layout</a></h2>
<p>Slices have the same layout as the section of the array they slice.</p>
<blockquote>
<p>Note: This is about the raw <code>[T]</code> type, not pointers (<code>&amp;[T]</code>, <code>Box&lt;[T]&gt;</code>,
etc.) to slices.</p>
</blockquote>
<h2><a class="header" href="#str-layout" id="str-layout"><code>str</code> Layout</a></h2>
<p>String slices are a UTF-8 representation of characters that have the same layout as slices of type <code>[u8]</code>.</p>
<h2><a class="header" href="#tuple-layout" id="tuple-layout">Tuple Layout</a></h2>
<p>Tuples do not have any guarantees about their layout.</p>
<p>The exception to this is the unit tuple (<code>()</code>) which is guaranteed as a
zero-sized type to have a size of 0 and an alignment of 1.</p>
<h2><a class="header" href="#trait-object-layout" id="trait-object-layout">Trait Object Layout</a></h2>
<p>Trait objects have the same layout as the value the trait object is of.</p>
<blockquote>
<p>Note: This is about the raw trait object types, not pointers (<code>&amp;Trait</code>,
<code>Box&lt;Trait&gt;</code>, etc.) to trait objects.</p>
</blockquote>
<h2><a class="header" href="#closure-layout" id="closure-layout">Closure Layout</a></h2>
<p>Closures have no layout guarantees.</p>
<h2><a class="header" href="#representations" id="representations">Representations</a></h2>
<p>All user-defined composite types (<code>struct</code>s, <code>enum</code>s, and <code>union</code>s) have a
<em>representation</em> that specifies what the layout is for the type. The possible
representations for a type are:</p>
<ul>
<li><a href="type-layout.html#the-default-representation">Default</a></li>
<li><a href="type-layout.html#the-c-representation"><code>C</code></a></li>
<li>The <a href="type-layout.html#primitive-representations">primitive representations</a></li>
<li><a href="type-layout.html#the-transparent-representation"><code>transparent</code></a></li>
</ul>
<p>The representation of a type can be changed by applying the <code>repr</code> attribute
to it. The following example shows a struct with a <code>C</code> representation.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct ThreeInts {
    first: i16,
    second: i8,
    third: i32
}
<span class="boring">}
</span></code></pre></pre>
<p>The alignment may be raised or lowered with the <code>align</code> and <code>packed</code> modifiers
respectively. They alter the representation specified in the attribute.
If no representation is specified, the default one is altered.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Default representation, alignment lowered to 2.
#[repr(packed(2))]
struct PackedStruct {
    first: i16,
    second: i8,
    third: i32
}

// C representation, alignment raised to 8
#[repr(C, align(8))]
struct AlignedStruct {
    first: i16,
    second: i8,
    third: i32
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: As a consequence of the representation being an attribute on the item,
the representation does not depend on generic parameters. Any two types with
the same name have the same representation. For example, <code>Foo&lt;Bar&gt;</code> and
<code>Foo&lt;Baz&gt;</code> both have the same representation.</p>
</blockquote>
<p>The representation of a type can change the padding between fields, but does
not change the layout of the fields themselves. For example, a struct with a
<code>C</code> representation that contains a struct <code>Inner</code> with the default
representation will not change the layout of <code>Inner</code>.</p>
<h3><a class="header" href="#the-default-representation" id="the-default-representation">The Default Representation</a></h3>
<p>Nominal types without a <code>repr</code> attribute have the default representation.
Informally, this representation is also called the <code>rust</code> representation.</p>
<p>There are no guarantees of data layout made by this representation.</p>
<h3><a class="header" href="#the-c-representation" id="the-c-representation">The <code>C</code> Representation</a></h3>
<p>The <code>C</code> representation is designed for dual purposes. One purpose is for
creating types that are interoperable with the C Language. The second purpose is
to create types that you can soundly perform operations on that rely on data
layout such as reinterpreting values as a different type.</p>
<p>Because of this dual purpose, it is possible to create types that are not useful
for interfacing with the C programming language.</p>
<p>This representation can be applied to structs, unions, and enums.</p>
<h4><a class="header" href="#reprc-structs" id="reprc-structs">#[repr(C)] Structs</a></h4>
<p>The alignment of the struct is the alignment of the most-aligned field in it.</p>
<p>The size and offset of fields is determined by the following algorithm.</p>
<p>Start with a current offset of 0 bytes.</p>
<p>For each field in declaration order in the struct, first determine the size and
alignment of the field. If the current offset is not a multiple of the field’s
alignment, then add padding bytes to the current offset until it is a multiple
of the field’s alignment. The offset for the field is what the current offset
is now. Then increase the current offset by the size of the field.</p>
<p>Finally, the size of the struct is the current offset rounded up to the nearest
multiple of the struct’s alignment.</p>
<p>Here is this algorithm described in pseudocode.</p>
<!-- ignore: pseudocode -->
<pre><code class="language-rust ignore">/// Returns the amount of padding needed after `offset` to ensure that the
/// following address will be aligned to `alignment`.
fn padding_needed_for(offset: usize, alignment: usize) -&gt; usize {
    let misalignment = offset % alignment;
    if misalignment &gt; 0 {
        // round up to next multiple of `alignment`
        alignment - misalignment
    } else {
        // already a multiple of `alignment`
        0
    }
}

struct.alignment = struct.fields().map(|field| field.alignment).max();

let current_offset = 0;

for field in struct.fields_in_declaration_order() {
    // Increase the current offset so that it's a multiple of the alignment
    // of this field. For the first field, this will always be zero.
    // The skipped bytes are called padding bytes.
    current_offset += padding_needed_for(current_offset, field.alignment);

    struct[field].offset = current_offset;

    current_offset += field.size;
}

struct.size = current_offset + padding_needed_for(current_offset, struct.alignment);
</code></pre>
<div class="warning">
<p>Warning: This pseudocode uses a naive algorithm that ignores overflow issues for
the sake of clarity. To perform memory layout computations in actual code, use
<a href="../std/alloc/struct.Layout.html"><code>Layout</code></a>.</p>
</div>
<blockquote>
<p>Note: This algorithm can produce zero-sized structs. This differs from
C where structs without data still have a size of one byte.</p>
</blockquote>
<h4><a class="header" href="#reprc-unions" id="reprc-unions">#[repr(C)] Unions</a></h4>
<p>A union declared with <code>#[repr(C)]</code> will have the same size and alignment as an
equivalent C union declaration in the C language for the target platform.
The union will have a size of the maximum size of all of its fields rounded to
its alignment, and an alignment of the maximum alignment of all of its fields.
These maximums may come from different fields.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
union Union {
    f1: u16,
    f2: [u8; 4],
}

assert_eq!(std::mem::size_of::&lt;Union&gt;(), 4);  // From f2
assert_eq!(std::mem::align_of::&lt;Union&gt;(), 2); // From f1

#[repr(C)]
union SizeRoundedUp {
   a: u32,
   b: [u16; 3],
}

assert_eq!(std::mem::size_of::&lt;SizeRoundedUp&gt;(), 8);  // Size of 6 from b,
                                                      // rounded up to 8 from
                                                      // alignment of a.
assert_eq!(std::mem::align_of::&lt;SizeRoundedUp&gt;(), 4); // From a
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#reprc-enums" id="reprc-enums">#[repr(C)] Enums</a></h4>
<p>For <a href="items/enumerations.html#custom-discriminant-values-for-fieldless-enumerations">C-like enumerations</a>, the <code>C</code> representation has the size and alignment of
the default <code>enum</code> size and alignment for the target platform’s C ABI.</p>
<blockquote>
<p>Note: The enum representation in C is implementation defined, so this is
really a “best guess”. In particular, this may be incorrect when the C code
of interest is compiled with certain flags.</p>
</blockquote>
<div class="warning">
<p>Warning: There are crucial differences between an <code>enum</code> in the C language and
Rust’s C-like enumerations with this representation. An <code>enum</code> in  C is
mostly a <code>typedef</code> plus some named constants; in other words, an object of an
<code>enum</code> type can hold any integer value. For example, this is often used for
bitflags in <code>C</code>. In contrast, Rust’s C-like enumerations can only legally hold
the discriminant values, everything else is undefined behaviour. Therefore,
using a C-like enumeration in FFI to model a C <code>enum</code> is often wrong.</p>
</div>
<p>It is an error for <a href="items/enumerations.html#zero-variant-enums">zero-variant enumerations</a> to have the <code>C</code> representation.</p>
<p>For all other enumerations, the layout is unspecified.</p>
<p>Likewise, combining the <code>C</code> representation with a primitive representation, the
layout is unspecified.</p>
<h3><a class="header" href="#primitive-representations" id="primitive-representations">Primitive representations</a></h3>
<p>The <em>primitive representations</em> are the representations with the same names as
the primitive integer types. That is: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>,
<code>usize</code>, <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, and <code>isize</code>.</p>
<p>Primitive representations can only be applied to enumerations.</p>
<p>For <a href="items/enumerations.html#custom-discriminant-values-for-fieldless-enumerations">C-like enumerations</a>, they set the size and alignment to be the same as the
primitive type of the same name. For example, a C-like enumeration with a <code>u8</code>
representation can only have discriminants between 0 and 255 inclusive.</p>
<p>It is an error for <a href="items/enumerations.html#zero-variant-enums">zero-variant enumerations</a> to have a primitive
representation.</p>
<p>For all other enumerations, the layout is unspecified.</p>
<p>Likewise, combining two primitive representations together is unspecified.</p>
<h3><a class="header" href="#the-alignment-modifiers" id="the-alignment-modifiers">The alignment modifiers</a></h3>
<p>The <code>align</code> and <code>packed</code> modifiers can be used to respectively raise or lower
the alignment of <code>struct</code>s and <code>union</code>s. <code>packed</code> may also alter the padding
between fields.</p>
<p>The alignment is specified as an integer parameter in the form of
<code>#[repr(align(x))]</code> or <code>#[repr(packed(x))]</code>. The alignment value must be a
power of two from 1 up to 2<sup>29</sup>. For <code>packed</code>, if no value is given,
as in <code>#[repr(packed)]</code>, then the value is 1.</p>
<p>For <code>align</code>, if the specified alignment is less than the alignment of the type
without the <code>align</code> modifier, then the alignment is unaffected.</p>
<p>For <code>packed</code>, if the specified alignment is greater than the type’s alignment
without the <code>packed</code> modifier, then the alignment and layout is unaffected.
The alignments of each field, for the purpose of positioning fields, is the
smaller of the specified alignment and the alignment of the field’s type.</p>
<p>The <code>align</code> and <code>packed</code> modifiers cannot be applied on the same type and a
<code>packed</code> type cannot transitively contain another <code>align</code>ed type. <code>align</code> and
<code>packed</code> may only be applied to the <a href="type-layout.html#the-default-representation">default</a> and <a href="type-layout.html#the-c-representation"><code>C</code></a> representations.</p>
<p>The <code>align</code> modifier can also be applied on an <code>enum</code>.
When it is, the effect on the <code>enum</code>‘s alignment is the same as if the <code>enum</code>
was wrapped in a newtype <code>struct</code> with the same <code>align</code> modifier.</p>
<div class="warning">
<p><em><strong>Warning:</strong></em> Dereferencing an unaligned pointer is <a href="behavior-considered-undefined.html">undefined behavior</a> and
it is possible to <a href="https://github.com/rust-lang/rust/issues/27060">safely create unaligned pointers to <code>packed</code> fields</a>.
Like all ways to create undefined behavior in safe Rust, this is a bug.</p>
</div>
<h3><a class="header" href="#the-transparent-representation" id="the-transparent-representation">The <code>transparent</code> Representation</a></h3>
<p>The <code>transparent</code> representation can only be used on <code>struct</code>s that have:</p>
<ul>
<li>a single field with non-zero size, and</li>
<li>any number of fields with size 0 and alignment 1 (e.g. <a href="special-types-and-traits.html#phantomdatat"><code>PhantomData&lt;T&gt;</code></a>).</li>
</ul>
<p>Structs with this representation have the same layout and ABI as the single
non-zero sized field.</p>
<p>This is different than the <code>C</code> representation because
a struct with the <code>C</code> representation will always have the ABI of a <code>C</code> <code>struct</code>
while, for example, a struct with the <code>transparent</code> representation with a
primitive field will have the ABI of the primitive field.</p>
<p>Because this representation delegates type layout to another type, it cannot be
used with any other representation.</p>
<h1><a class="header" href="#interior-mutability" id="interior-mutability">Interior Mutability</a></h1>
<p>Sometimes a type needs to be mutated while having multiple aliases. In Rust this
is achieved using a pattern called <em>interior mutability</em>. A type has interior
mutability if its internal state can be changed through a <a href="types/pointer.html#shared-references-">shared reference</a> to
it. This goes against the usual <a href="behavior-considered-undefined.html">requirement</a> that the value pointed to by a
shared reference is not mutated.</p>
<p><a href="../std/cell/struct.UnsafeCell.html"><code>std::cell::UnsafeCell&lt;T&gt;</code></a> type is the only allowed way in Rust to disable
this requirement. When <code>UnsafeCell&lt;T&gt;</code> is immutably aliased, it is still safe to
mutate, or obtain a mutable reference to, the <code>T</code> it contains. As with all
other types, it is undefined behavior to have multiple <code>&amp;mut UnsafeCell&lt;T&gt;</code>
aliases.</p>
<p>Other types with interior mutability can be created by using <code>UnsafeCell&lt;T&gt;</code> as
a field. The standard library provides a variety of types that provide safe
interior mutability APIs. For example, <a href="../std/cell/struct.RefCell.html"><code>std::cell::RefCell&lt;T&gt;</code></a> uses run-time
borrow checks to ensure the usual rules around multiple references. The
<a href="../std/sync/atomic/index.html"><code>std::sync::atomic</code></a> module contains types that wrap a value that is only
accessed with atomic operations, allowing the value to be shared and mutated
across threads.</p>
<h1><a class="header" href="#subtyping-and-variance" id="subtyping-and-variance">Subtyping and Variance</a></h1>
<p>Subtyping is implicit and can occur at any stage in type checking or
inference. Subtyping in Rust is very restricted and occurs only due to
variance with respect to lifetimes and between types with higher ranked
lifetimes. If we were to erase lifetimes from types, then the only subtyping
would be due to type equality.</p>
<p>Consider the following example: string literals always have <code>'static</code>
lifetime. Nevertheless, we can assign <code>s</code> to <code>t</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn bar&lt;'a&gt;() {
    let s: &amp;'static str = &quot;hi&quot;;
    let t: &amp;'a str = s;
}
<span class="boring">}
</span></code></pre></pre>
<p>Since <code>'static</code> outlives the lifetime parameter <code>'a</code>, <code>&amp;'static str</code> is a
subtype of <code>&amp;'a str</code>.</p>
<p><a href="../nomicon/hrtb.html">Higher-ranked</a> <a href="types/function-pointer.html">function pointers</a> and <a href="types/trait-object.html">trait objects</a> have another
subtype relation. They are subtypes of types that are given by substitutions of
the higher-ranked lifetimes. Some examples:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Here 'a is substituted for 'static
let subtype: &amp;(for&lt;'a&gt; fn(&amp;'a i32) -&gt; &amp;'a i32) = &amp;((|x| x) as fn(&amp;_) -&gt; &amp;_);
let supertype: &amp;(fn(&amp;'static i32) -&gt; &amp;'static i32) = subtype;

// This works similarly for trait objects
let subtype: &amp;(for&lt;'a&gt; Fn(&amp;'a i32) -&gt; &amp;'a i32) = &amp;|x| x;
let supertype: &amp;(Fn(&amp;'static i32) -&gt; &amp;'static i32) = subtype;

// We can also substitute one higher-ranked lifetime for another
let subtype: &amp;(for&lt;'a, 'b&gt; fn(&amp;'a i32, &amp;'b i32))= &amp;((|x, y| {}) as fn(&amp;_, &amp;_));
let supertype: &amp;for&lt;'c&gt; fn(&amp;'c i32, &amp;'c i32) = subtype;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#variance" id="variance">Variance</a></h2>
<p>Variance is a property that generic types have with respect to their arguments.
A generic type’s <em>variance</em> in a parameter is how the subtyping of the
parameter affects the subtyping of the type.</p>
<ul>
<li><code>F&lt;T&gt;</code> is <em>covariant</em> over <code>T</code> if <code>T</code> being a subtype of <code>U</code> implies that
<code>F&lt;T&gt;</code> is a subtype of <code>F&lt;U&gt;</code> (subtyping “passes through”)</li>
<li><code>F&lt;T&gt;</code> is <em>contravariant</em> over <code>T</code> if <code>T</code> being a subtype of <code>U</code> implies that
<code>F&lt;U&gt;</code> is a subtype of <code>F&lt;T&gt;</code></li>
<li><code>F&lt;T&gt;</code> is <em>invariant</em> over <code>T</code> otherwise (no subtyping relation can be
derived)</li>
</ul>
<p>Variance of types is automatically determined as follows</p>
<table><thead><tr><th>Type</th><th>Variance in <code>'a</code></th><th>Variance in <code>T</code></th></tr></thead><tbody>
<tr><td><code>&amp;'a T</code></td><td>covariant</td><td>covariant</td></tr>
<tr><td><code>&amp;'a mut T</code></td><td>covariant</td><td>invariant</td></tr>
<tr><td><code>*const T</code></td><td></td><td>covariant</td></tr>
<tr><td><code>*mut T</code></td><td></td><td>invariant</td></tr>
<tr><td><code>[T]</code> and <code>[T; n]</code></td><td></td><td>covariant</td></tr>
<tr><td><code>fn() -&gt; T</code></td><td></td><td>covariant</td></tr>
<tr><td><code>fn(T) -&gt; ()</code></td><td></td><td>contravariant</td></tr>
<tr><td><code>std::cell::UnsafeCell&lt;T&gt;</code></td><td></td><td>invariant</td></tr>
<tr><td><code>std::marker::PhantomData&lt;T&gt;</code></td><td></td><td>covariant</td></tr>
<tr><td><code>Trait&lt;T&gt; + 'a</code></td><td>covariant</td><td>invariant</td></tr>
</tbody></table>
<p>The variance of other <code>struct</code>, <code>enum</code>, <code>union</code>, and tuple types is decided by
looking at the variance of the types of their fields. If the parameter is used
in positions with different variances then the parameter is invariant. For
example the following struct is covariant in <code>'a</code> and <code>T</code> and invariant in <code>'b</code>
and <code>U</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::cell::UnsafeCell;
struct Variance&lt;'a, 'b, T, U: 'a&gt; {
    x: &amp;'a U,               // This makes `Variance` covariant in 'a, and would
                            // make it covariant in U, but U is used later
    y: *const T,            // Covariant in T
    z: UnsafeCell&lt;&amp;'b f64&gt;, // Invariant in 'b
    w: *mut U,              // Invariant in U, makes the whole struct invariant
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#trait-and-lifetime-bounds" id="trait-and-lifetime-bounds">Trait and lifetime bounds</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>TypeParamBounds</em> :<br />
   <em>TypeParamBound</em> ( <code>+</code> <em>TypeParamBound</em> )<sup>*</sup> <code>+</code><sup>?</sup></p>
<p><em>TypeParamBound</em> :<br />
      <em>Lifetime</em> | <em>TraitBound</em></p>
<p><em>TraitBound</em> :<br />
      <code>?</code><sup>?</sup>
<a href="trait-bounds.html#higher-ranked-trait-bounds"><em>ForLifetimes</em></a><sup>?</sup> <a href="paths.html#paths-in-types"><em>TypePath</em></a><br />
   | <code>(</code> <code>?</code><sup>?</sup>
<a href="trait-bounds.html#higher-ranked-trait-bounds"><em>ForLifetimes</em></a><sup>?</sup> <a href="paths.html#paths-in-types"><em>TypePath</em></a> <code>)</code></p>
<p><em>LifetimeBounds</em> :<br />
   ( <em>Lifetime</em> <code>+</code> )<sup>*</sup> <em>Lifetime</em><sup>?</sup></p>
<p><em>Lifetime</em> :<br />
      <a href="tokens.html#lifetimes-and-loop-labels">LIFETIME_OR_LABEL</a><br />
   | <code>'static</code><br />
   | <code>'_</code></p>
</blockquote>
<p><a href="items/traits.html#trait-bounds">Trait</a> and lifetime bounds provide a way for <a href="items/generics.html">generic items</a> to
restrict which types and lifetimes are used as their parameters. Bounds can be
provided on any type in a <a href="items/generics.html#where-clauses">where clause</a>. There are also shorter forms for
certain common cases:</p>
<ul>
<li>Bounds written after declaring a <a href="items/generics.html">generic parameter</a>:
<code>fn f&lt;A: Copy&gt;() {}</code> is the same as <code>fn f&lt;A&gt; where A: Copy () {}</code>.</li>
<li>In trait declarations as <a href="items/traits.html#supertraits">supertraits</a>: <code>trait Circle : Shape {}</code> is
equivalent to <code>trait Circle where Self : Shape {}</code>.</li>
<li>In trait declarations as bounds on <a href="items/associated-items.html#associated-types">associated types</a>:
<code>trait A { type B: Copy; }</code> is equivalent to
<code>trait A where Self::B: Copy { type B; }</code>.</li>
</ul>
<p>Bounds on an item must be satisfied when using the item. When type checking and
borrow checking a generic item, the bounds can be used to determine that a
trait is implemented for a type. For example, given <code>Ty: Trait</code></p>
<ul>
<li>In the body of a generic function, methods from <code>Trait</code> can be called on <code>Ty</code>
values. Likewise associated constants on the <code>Trait</code> can be used.</li>
<li>Associated types from <code>Trait</code> can be used.</li>
<li>Generic functions and types with a <code>T: Trait</code> bounds can be used with <code>Ty</code>
being used for <code>T</code>.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">type Surface = i32;
</span>trait Shape {
    fn draw(&amp;self, Surface);
    fn name() -&gt; &amp;'static str;
}

fn draw_twice&lt;T: Shape&gt;(surface: Surface, sh: T) {
    sh.draw(surface);           // Can call method because T: Shape
    sh.draw(surface);
}

fn copy_and_draw_twice&lt;T: Copy&gt;(surface: Surface, sh: T) where T: Shape {
    let shape_copy = sh;        // doesn't move sh because T: Copy
    draw_twice(surface, sh);    // Can use generic function because T: Shape
}

struct Figure&lt;S: Shape&gt;(S, S);

fn name_figure&lt;U: Shape&gt;(
    figure: Figure&lt;U&gt;,          // Type Figure&lt;U&gt; is well-formed because U: Shape
) {
    println!(
        &quot;Figure of two {}&quot;,
        U::name(),              // Can use associated function
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Trait and lifetime bounds are also used to name <a href="types/trait-object.html">trait objects</a>.</p>
<h2><a class="header" href="#sized" id="sized"><code>?Sized</code></a></h2>
<p><code>?</code> is only used to declare that the <a href="special-types-and-traits.html#sized"><code>Sized</code></a> trait may not be
implemented for a type parameter or associated type. <code>?Sized</code> may
not be used as a bound for other types.</p>
<h2><a class="header" href="#lifetime-bounds" id="lifetime-bounds">Lifetime bounds</a></h2>
<p>Lifetime bounds can be applied to types or other lifetimes. The bound <code>'a: 'b</code>
is usually read as <code>'a</code> <em>outlives</em> <code>'b</code>. <code>'a: 'b</code> means that <code>'a</code> lasts longer
than <code>'b</code>, so a reference <code>&amp;'a ()</code> is valid whenever <code>&amp;'b ()</code> is valid.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn f&lt;'a, 'b&gt;(x: &amp;'a i32, mut y: &amp;'b i32) where 'a: 'b {
    y = x;                      // &amp;'a i32 is a subtype of &amp;'b i32 because 'a: 'b
    let r: &amp;'b &amp;'a i32 = &amp;&amp;0;   // &amp;'b &amp;'a i32 is well formed because 'a: 'b
}
<span class="boring">}
</span></code></pre></pre>
<p><code>T: 'a</code> means that all lifetime parameters of <code>T</code> outlive <code>'a</code>. For example if
<code>'a</code> is an unconstrained lifetime parameter then <code>i32: 'static</code> and
<code>&amp;'static str: 'a</code> are satisfied but <code>Vec&lt;&amp;'a ()&gt;: 'static</code> is not.</p>
<h2><a class="header" href="#higher-ranked-trait-bounds" id="higher-ranked-trait-bounds">Higher-ranked trait bounds</a></h2>
<p>Type bounds may be <em>higher ranked</em> over lifetimes. These bounds specify a bound
is true <em>for all</em> lifetimes. For example, a bound such as <code>for&lt;'a&gt; &amp;'a T: PartialEq&lt;i32&gt;</code> would require an implementation like</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct T;
</span>impl&lt;'a&gt; PartialEq&lt;i32&gt; for &amp;'a T {
    // ...
<span class="boring">   fn eq(&amp;self, other: &amp;i32) -&gt; bool {true}
</span>}
<span class="boring">}
</span></code></pre></pre>
<p>and could then be used to compare a <code>&amp;'a T</code> with any lifetime to an <code>i32</code>.</p>
<p>Only a higher-ranked bound can be used here as the lifetime of the reference is
shorter than a lifetime parameter on the function:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn call_on_ref_zero&lt;F&gt;(f: F) where for&lt;'a&gt; F: Fn(&amp;'a i32) {
    let zero = 0;
    f(&amp;zero);
}
<span class="boring">}
</span></code></pre></pre>
<p>Higher-ranked lifetimes may also be specified just before the trait, the only
difference is the scope of the lifetime parameter, which extends only to the
end of the following trait instead of the whole bound. This function is
equivalent to the last one.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn call_on_ref_zero&lt;F&gt;(f: F) where F: for&lt;'a&gt; Fn(&amp;'a i32) {
    let zero = 0;
    f(&amp;zero);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#type-coercions" id="type-coercions">Type coercions</a></h1>
<p>Coercions are defined in <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md">RFC 401</a>. <a href="https://github.com/rust-lang/rfcs/blob/master/text/1558-closure-to-fn-coercion.md">RFC 1558</a> then expanded on that.
A coercion is implicit and has no syntax.</p>
<h2><a class="header" href="#coercion-sites" id="coercion-sites">Coercion sites</a></h2>
<p>A coercion can only occur at certain coercion sites in a program; these are
typically places where the desired type is explicit or can be derived by
propagation from explicit types (without type inference). Possible coercion
sites are:</p>
<ul>
<li>
<p><code>let</code> statements where an explicit type is given.</p>
<p>For example, <code>42</code> is coerced to have type <code>i8</code> in the following:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let _: i8 = 42;
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><code>static</code> and <code>const</code> statements (similar to <code>let</code> statements).</p>
</li>
<li>
<p>Arguments for function calls</p>
<p>The value being coerced is the actual parameter, and it is coerced to
the type of the formal parameter.</p>
<p>For example, <code>42</code> is coerced to have type <code>i8</code> in the following:</p>
<pre><pre class="playpen"><code class="language-rust">fn bar(_: i8) { }

fn main() {
    bar(42);
}
</code></pre></pre>
<p>For method calls, the receiver (<code>self</code> parameter) can only take advantage
of <a href="type-coercions.html#unsized-coercions">unsized coercions</a>.</p>
</li>
<li>
<p>Instantiations of struct or variant fields</p>
<p>For example, <code>42</code> is coerced to have type <code>i8</code> in the following:</p>
<pre><pre class="playpen"><code class="language-rust">struct Foo { x: i8 }

fn main() {
    Foo { x: 42 };
}
</code></pre></pre>
</li>
<li>
<p>Function results, either the final line of a block if it is not
semicolon-terminated or any expression in a <code>return</code> statement</p>
<p>For example, <code>42</code> is coerced to have type <code>i8</code> in the following:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; i8 {
    42
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<p>If the expression in one of these coercion sites is a coercion-propagating
expression, then the relevant sub-expressions in that expression are also
coercion sites. Propagation recurses from these new coercion sites.
Propagating expressions and their relevant sub-expressions are:</p>
<ul>
<li>
<p>Array literals, where the array has type <code>[U; n]</code>. Each sub-expression in
the array literal is a coercion site for coercion to type <code>U</code>.</p>
</li>
<li>
<p>Array literals with repeating syntax, where the array has type <code>[U; n]</code>. The
repeated sub-expression is a coercion site for coercion to type <code>U</code>.</p>
</li>
<li>
<p>Tuples, where a tuple is a coercion site to type <code>(U_0, U_1, ..., U_n)</code>.
Each sub-expression is a coercion site to the respective type, e.g. the
zeroth sub-expression is a coercion site to type <code>U_0</code>.</p>
</li>
<li>
<p>Parenthesized sub-expressions (<code>(e)</code>): if the expression has type <code>U</code>, then
the sub-expression is a coercion site to <code>U</code>.</p>
</li>
<li>
<p>Blocks: if a block has type <code>U</code>, then the last expression in the block (if
it is not semicolon-terminated) is a coercion site to <code>U</code>. This includes
blocks which are part of control flow statements, such as <code>if</code>/<code>else</code>, if
the block has a known type.</p>
</li>
</ul>
<h2><a class="header" href="#coercion-types" id="coercion-types">Coercion types</a></h2>
<p>Coercion is allowed between the following types:</p>
<ul>
<li>
<p><code>T</code> to <code>U</code> if <code>T</code> is a subtype of <code>U</code> (<em>reflexive case</em>)</p>
</li>
<li>
<p><code>T_1</code> to <code>T_3</code> where <code>T_1</code> coerces to <code>T_2</code> and <code>T_2</code> coerces to <code>T_3</code>
(<em>transitive case</em>)</p>
<p>Note that this is not fully supported yet.</p>
</li>
<li>
<p><code>&amp;mut T</code> to <code>&amp;T</code></p>
</li>
<li>
<p><code>*mut T</code> to <code>*const T</code></p>
</li>
<li>
<p><code>&amp;T</code> to <code>*const T</code></p>
</li>
<li>
<p><code>&amp;mut T</code> to <code>*mut T</code></p>
</li>
<li>
<p><code>&amp;T</code> or <code>&amp;mut T</code> to <code>&amp;U</code> if <code>T</code> implements <code>Deref&lt;Target = U&gt;</code>. For example:</p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::Deref;

struct CharContainer {
    value: char,
}

impl Deref for CharContainer {
    type Target = char;

    fn deref&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a char {
        &amp;self.value
    }
}

fn foo(arg: &amp;char) {}

fn main() {
    let x = &amp;mut CharContainer { value: 'y' };
    foo(x); //&amp;mut CharContainer is coerced to &amp;char.
}
</code></pre></pre>
</li>
<li>
<p><code>&amp;mut T</code> to <code>&amp;mut U</code> if <code>T</code> implements <code>DerefMut&lt;Target = U&gt;</code>.</p>
</li>
<li>
<p>TyCtor(<code>T</code>) to TyCtor(<code>U</code>), where TyCtor(<code>T</code>) is one of</p>
<ul>
<li><code>&amp;T</code></li>
<li><code>&amp;mut T</code></li>
<li><code>*const T</code></li>
<li><code>*mut T</code></li>
<li><code>Box&lt;T&gt;</code></li>
</ul>
<p>and where <code>U</code> can be obtained from <code>T</code> by <a href="type-coercions.html#unsized-coercions">unsized coercion</a>.</p>
<!--In the future, coerce_inner will be recursively extended to tuples and
  structs. In addition, coercions from sub-traits to super-traits will be
  added. See [RFC 401] for more details.-->
</li>
<li>
<p>Non capturing closures to <code>fn</code> pointers</p>
</li>
<li>
<p><code>!</code> to any <code>T</code></p>
</li>
</ul>
<h3><a class="header" href="#unsized-coercions" id="unsized-coercions">Unsized Coercions</a></h3>
<p>The following coercions are called <code>unsized coercions</code>, since they
relate to converting sized types to unsized types, and are permitted in a few
cases where other coercions are not, as described above. They can still happen
anywhere else a coercion can occur.</p>
<p>Two traits, <a href="../std/marker/trait.Unsize.html"><code>Unsize</code></a> and <a href="../std/ops/trait.CoerceUnsized.html"><code>CoerceUnsized</code></a>, are used
to assist in this process and expose it for library use. The following
coercions are built-ins and, if <code>T</code> can be coerced to <code>U</code> with one of them, then
an implementation of <code>Unsize&lt;U&gt;</code> for <code>T</code> will be provided:</p>
<ul>
<li>
<p><code>[T; n]</code> to <code>[T]</code>.</p>
</li>
<li>
<p><code>T</code> to <code>U</code>, when <code>U</code> is a trait object type and either <code>T</code> implements <code>U</code> or
<code>T</code> is a trait object for a subtrait of <code>U</code>.</p>
</li>
<li>
<p><code>Foo&lt;..., T, ...&gt;</code> to <code>Foo&lt;..., U, ...&gt;</code>, when:</p>
<ul>
<li><code>Foo</code> is a struct.</li>
<li><code>T</code> implements <code>Unsize&lt;U&gt;</code>.</li>
<li>The last field of <code>Foo</code> has a type involving <code>T</code>.</li>
<li>If that field has type <code>Bar&lt;T&gt;</code>, then <code>Bar&lt;T&gt;</code> implements <code>Unsized&lt;Bar&lt;U&gt;&gt;</code>.</li>
<li>T is not part of the type of any other fields.</li>
</ul>
</li>
</ul>
<p>Additionally, a type <code>Foo&lt;T&gt;</code> can implement <code>CoerceUnsized&lt;Foo&lt;U&gt;&gt;</code> when <code>T</code>
implements <code>Unsize&lt;U&gt;</code> or <code>CoerceUnsized&lt;Foo&lt;U&gt;&gt;</code>. This allows it to provide a
unsized coercion to <code>Foo&lt;U&gt;</code>.</p>
<blockquote>
<p>Note: While the definition of the unsized coercions and their implementation
has been stabilized, the traits themselves are not yet stable and therefore
can’t be used directly in stable Rust.</p>
</blockquote>
<h1><a class="header" href="#destructors" id="destructors">Destructors</a></h1>
<p>When an <a href="glossary.html#initialized">initialized</a> <a href="variables.html">variable</a> in Rust goes out of scope or a <a href="expressions.html#temporary-lifetimes">temporary</a>
is no longer needed its <em>destructor</em> is run. <a href="expressions/operator-expr.html#assignment-expressions">Assignment</a> also runs the
destructor of its left-hand operand, unless it’s an uninitialized variable. If a
<a href="types/struct.html">struct</a> variable has been partially initialized, only its initialized fields
are dropped.</p>
<p>The destructor of a type consists of</p>
<ol>
<li>Calling its <a href="../std/ops/trait.Drop.html"><code>std::ops::Drop::drop</code></a> method, if it has one.</li>
<li>Recursively running the destructor of all of its fields.
<ul>
<li>The fields of a <a href="types/struct.html">struct</a>, <a href="types/tuple.html">tuple</a> or <a href="types/enum.html">enum variant</a> are dropped in
declaration order. *</li>
<li>The elements of an <a href="types/array.html">array</a> or owned <a href="types/array.html">slice</a> are dropped from the
first element to the last. *</li>
<li>The captured values of a <a href="types/closure.html">closure</a> are dropped in an unspecified order.</li>
<li><a href="types/trait-object.html">Trait objects</a> run the destructor of the underlying type.</li>
<li>Other types don’t result in any further drops.</li>
</ul>
</li>
</ol>
<p>* This order was stabilized in <a href="https://github.com/rust-lang/rfcs/blob/master/text/1857-stabilize-drop-order.md">RFC 1857</a>.</p>
<p>Variables are dropped in reverse order of declaration. Variables declared in
the same pattern drop in an unspecified ordered.</p>
<p>If a destructor must be run manually, such as when implementing your own smart
pointer, <a href="../std/ptr/fn.drop_in_place.html"><code>std::ptr::drop_in_place</code></a> can be used.</p>
<p>Some examples:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct ShowOnDrop(&amp;'static str);

impl Drop for ShowOnDrop {
    fn drop(&amp;mut self) {
        println!(&quot;{}&quot;, self.0);
    }
}

{
    let mut overwritten = ShowOnDrop(&quot;Drops when overwritten&quot;);
    overwritten = ShowOnDrop(&quot;drops when scope ends&quot;);
}
<span class="boring">println!(&quot;&quot;);
</span>{
    let declared_first = ShowOnDrop(&quot;Dropped last&quot;);
    let declared_last = ShowOnDrop(&quot;Dropped first&quot;);
}
<span class="boring">println!(&quot;&quot;);
</span>{
    // Tuple elements drop in forwards order
    let tuple = (ShowOnDrop(&quot;Tuple first&quot;), ShowOnDrop(&quot;Tuple second&quot;));
}
<span class="boring">println!(&quot;&quot;);
</span>loop {
    // Tuple expression doesn't finish evaluating so temporaries drop in reverse order:
    let partial_tuple = (ShowOnDrop(&quot;Temp first&quot;), ShowOnDrop(&quot;Temp second&quot;), break);
}
<span class="boring">println!(&quot;&quot;);
</span>{
    let moved;
    // No destructor run on assignment.
    moved = ShowOnDrop(&quot;Drops when moved&quot;);
    // drops now, but is then uninitialized
    moved;

    // Uninitialized does not drop.
    let uninitialized: ShowOnDrop;

    // After a partial move, only the remaining fields are dropped.
    let mut partial_move = (ShowOnDrop(&quot;first&quot;), ShowOnDrop(&quot;forgotten&quot;));
    // Perform a partial move, leaving only `partial_move.0` initialized.
    core::mem::forget(partial_move.1);
    // When partial_move's scope ends, only the first field is dropped.
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#not-running-destructors" id="not-running-destructors">Not running destructors</a></h2>
<p>Not running destructors in Rust is safe even if it has a type that isn’t
<code>'static</code>. <a href="../std/mem/struct.ManuallyDrop.html"><code>std::mem::ManuallyDrop</code></a> provides a wrapper to prevent a
variable or field from being dropped automatically.</p>
<h1><a class="header" href="#lifetime-elision" id="lifetime-elision">Lifetime elision</a></h1>
<p>Rust has rules that allow lifetimes to be elided in various places where the
compiler can infer a sensible default choice.</p>
<h2><a class="header" href="#lifetime-elision-in-functions" id="lifetime-elision-in-functions">Lifetime elision in functions</a></h2>
<p>In order to make common patterns more ergonomic, lifetime arguments can be
<em>elided</em> in <a href="types/function-item.html">function item</a>, <a href="types/function-pointer.html">function pointer</a>, and <a href="types/closure.html">closure trait</a> signatures.
The following rules are used to infer lifetime parameters for elided lifetimes.
It is an error to elide lifetime parameters that cannot be inferred. The
placeholder lifetime, <code>'_</code>, can also be used to have a lifetime inferred in the
same way. For lifetimes in paths, using <code>'_</code> is preferred. Trait object
lifetimes follow different rules discussed
<a href="lifetime-elision.html#default-trait-object-lifetimes">below</a>.</p>
<ul>
<li>Each elided lifetime in the parameters becomes a distinct lifetime parameter.</li>
<li>If there is exactly one lifetime used in the parameters (elided or not), that
lifetime is assigned to <em>all</em> elided output lifetimes.</li>
</ul>
<p>In method signatures there is another rule</p>
<ul>
<li>If the receiver has type <code>&amp;Self</code>  or <code>&amp;mut Self</code>, then the lifetime of that
reference to <code>Self</code> is assigned to all elided output lifetime parameters.</li>
</ul>
<p>Examples:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">trait T {}
</span><span class="boring">trait ToCStr {}
</span><span class="boring">struct Thing&lt;'a&gt; {f: &amp;'a i32}
</span><span class="boring">struct Command;
</span><span class="boring">
</span><span class="boring">trait Example {
</span>fn print1(s: &amp;str);                                   // elided
fn print2(s: &amp;'_ str);                                // also elided
fn print3&lt;'a&gt;(s: &amp;'a str);                            // expanded

fn debug1(lvl: usize, s: &amp;str);                       // elided
fn debug2&lt;'a&gt;(lvl: usize, s: &amp;'a str);                // expanded

fn substr1(s: &amp;str, until: usize) -&gt; &amp;str;            // elided
fn substr2&lt;'a&gt;(s: &amp;'a str, until: usize) -&gt; &amp;'a str;  // expanded

fn get_mut1(&amp;mut self) -&gt; &amp;mut dyn T;                 // elided
fn get_mut2&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut dyn T;       // expanded

fn args1&lt;T: ToCStr&gt;(&amp;mut self, args: &amp;[T]) -&gt; &amp;mut Command;                  // elided
fn args2&lt;'a, 'b, T: ToCStr&gt;(&amp;'a mut self, args: &amp;'b [T]) -&gt; &amp;'a mut Command; // expanded

fn new1(buf: &amp;mut [u8]) -&gt; Thing&lt;'_&gt;;                 // elided - preferred
fn new2(buf: &amp;mut [u8]) -&gt; Thing;                     // elided
fn new3&lt;'a&gt;(buf: &amp;'a mut [u8]) -&gt; Thing&lt;'a&gt;;          // expanded
<span class="boring">}
</span>
type FunPtr1 = fn(&amp;str) -&gt; &amp;str;                      // elided
type FunPtr2 = for&lt;'a&gt; fn(&amp;'a str) -&gt; &amp;'a str;        // expanded

type FunTrait1 = dyn Fn(&amp;str) -&gt; &amp;str;                // elided
type FunTrait2 = dyn for&lt;'a&gt; Fn(&amp;'a str) -&gt; &amp;'a str;  // expanded
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// The following examples show situations where it is not allowed to elide the
// lifetime parameter.

<span class="boring">trait Example {
</span>// Cannot infer, because there are no parameters to infer from.
fn get_str() -&gt; &amp;str;                                 // ILLEGAL

// Cannot infer, ambiguous if it is borrowed from the first or second parameter.
fn frob(s: &amp;str, t: &amp;str) -&gt; &amp;str;                    // ILLEGAL
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#default-trait-object-lifetimes" id="default-trait-object-lifetimes">Default trait object lifetimes</a></h2>
<p>The assumed lifetime of references held by a <a href="types/trait-object.html">trait object</a> is called its
<em>default object lifetime bound</em>. These were defined in <a href="https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md">RFC 599</a> and amended in
<a href="https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md">RFC 1156</a>.</p>
<p>These default object lifetime bounds are used instead of the lifetime parameter
elision rules defined above when the lifetime bound is omitted entirely. If
<code>'_</code> is used as the lifetime bound then the bound follows the usual elision
rules.</p>
<p>If the trait object is used as a type argument of a generic type then the
containing type is first used to try to infer a bound.</p>
<ul>
<li>If there is a unique bound from the containing type then that is the default</li>
<li>If there is more than one bound from the containing type then an explicit
bound must be specified</li>
</ul>
<p>If neither of those rules apply, then the bounds on the trait are used:</p>
<ul>
<li>If the trait is defined with a single lifetime <em>bound</em> then that bound is
used.</li>
<li>If <code>'static</code> is used for any lifetime bound then <code>'static</code> is used.</li>
<li>If the trait has no lifetime bounds, then the lifetime is inferred in
expressions and is <code>'static</code> outside of expressions.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// For the following trait...
trait Foo { }

// These two are the same as Box&lt;T&gt; has no lifetime bound on T
type T1 = Box&lt;dyn Foo&gt;;
type T2 = Box&lt;dyn Foo + 'static&gt;;

// ...and so are these:
impl dyn Foo {}
impl dyn Foo + 'static {}

// ...so are these, because &amp;'a T requires T: 'a
type T3&lt;'a&gt; = &amp;'a dyn Foo;
type T4&lt;'a&gt; = &amp;'a (dyn Foo + 'a);

// std::cell::Ref&lt;'a, T&gt; also requires T: 'a, so these are the same
type T5&lt;'a&gt; = std::cell::Ref&lt;'a, dyn Foo&gt;;
type T6&lt;'a&gt; = std::cell::Ref&lt;'a, dyn Foo + 'a&gt;;
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// This is an example of an error.
<span class="boring">trait Foo { }
</span>struct TwoBounds&lt;'a, 'b, T: ?Sized + 'a + 'b&gt; {
    f1: &amp;'a i32,
    f2: &amp;'b i32,
    f3: T,
}
type T7&lt;'a, 'b&gt; = TwoBounds&lt;'a, 'b, dyn Foo&gt;;
//                                  ^^^^^^^
// Error: the lifetime bound for this object type cannot be deduced from context
<span class="boring">}
</span></code></pre></pre>
<p>Note that the innermost object sets the bound, so <code>&amp;'a Box&lt;dyn Foo&gt;</code> is still
<code>&amp;'a Box&lt;dyn Foo + 'static&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// For the following trait...
trait Bar&lt;'a&gt;: 'a { }

// ...these two are the same:
type T1&lt;'a&gt; = Box&lt;dyn Bar&lt;'a&gt;&gt;;
type T2&lt;'a&gt; = Box&lt;dyn Bar&lt;'a&gt; + 'a&gt;;

// ...and so are these:
impl&lt;'a&gt; dyn Bar&lt;'a&gt; {}
impl&lt;'a&gt; dyn Bar&lt;'a&gt; + 'a {}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#static-lifetime-elision" id="static-lifetime-elision"><code>'static</code> lifetime elision</a></h2>
<p>Both <a href="items/constant-items.html">constant</a> and <a href="items/static-items.html">static</a> declarations of reference types have <em>implicit</em>
<code>'static</code> lifetimes unless an explicit lifetime is specified. As such, the
constant declarations involving <code>'static</code> above may be written without the
lifetimes.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// STRING: &amp;'static str
const STRING: &amp;str = &quot;bitstring&quot;;

struct BitsNStrings&lt;'a&gt; {
    mybits: [u32; 2],
    mystring: &amp;'a str,
}

// BITS_N_STRINGS: BitsNStrings&lt;'static&gt;
const BITS_N_STRINGS: BitsNStrings&lt;'_&gt; = BitsNStrings {
    mybits: [1, 2],
    mystring: STRING,
};
<span class="boring">}
</span></code></pre></pre>
<p>Note that if the <code>static</code> or <code>const</code> items include function or closure
references, which themselves include references, the compiler will first try
the standard elision rules. If it is unable to resolve the lifetimes by its
usual rules, then it will error. By way of example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo;
</span><span class="boring">struct Bar;
</span><span class="boring">struct Baz;
</span><span class="boring">fn somefunc(a: &amp;Foo, b: &amp;Bar, c: &amp;Baz) -&gt; usize {42}
</span>// Resolved as `fn&lt;'a&gt;(&amp;'a str) -&gt; &amp;'a str`.
const RESOLVED_SINGLE: fn(&amp;str) -&gt; &amp;str = |x| x;

// Resolved as `Fn&lt;'a, 'b, 'c&gt;(&amp;'a Foo, &amp;'b Bar, &amp;'c Baz) -&gt; usize`.
const RESOLVED_MULTIPLE: &amp;dyn Fn(&amp;Foo, &amp;Bar, &amp;Baz) -&gt; usize = &amp;somefunc;
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo;
</span><span class="boring">struct Bar;
</span><span class="boring">struct Baz;
</span><span class="boring">fn somefunc&lt;'a,'b&gt;(a: &amp;'a Foo, b: &amp;'b Bar) -&gt; &amp;'a Baz {unimplemented!()}
</span>// There is insufficient information to bound the return reference lifetime
// relative to the argument lifetimes, so this is an error.
const RESOLVED_STATIC: &amp;dyn Fn(&amp;Foo, &amp;Bar) -&gt; &amp;Baz = &amp;somefunc;
//                                            ^
// this function's return type contains a borrowed value, but the signature
// does not say whether it is borrowed from argument 1 or argument 2
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#special-types-and-traits" id="special-types-and-traits">Special types and traits</a></h1>
<p>Certain types and traits that exist in <a href="../std/index.html">the standard library</a> are known to the
Rust compiler. This chapter documents the special features of these types and
traits.</p>
<h2><a class="header" href="#boxt" id="boxt"><code>Box&lt;T&gt;</code></a></h2>
<p><a href="../std/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> has a few special features that Rust doesn’t currently allow for user
defined types.</p>
<ul>
<li>The <a href="expressions/operator-expr.html#the-dereference-operator">dereference operator</a> for <code>Box&lt;T&gt;</code> produces a place which can be moved
from. This means that the <code>*</code> operator and the destructor of <code>Box&lt;T&gt;</code> are
built-in to the language.</li>
<li><a href="items/associated-items.html#associated-functions-and-methods">Methods</a> can take <code>Box&lt;Self&gt;</code> as a receiver.</li>
<li>A trait may be implemented for <code>Box&lt;T&gt;</code> in the same crate as <code>T</code>, which the
<a href="items/implementations.html#trait-implementation-coherence">orphan rules</a> prevent for other generic types.</li>
</ul>
<h2><a class="header" href="#rct" id="rct"><code>Rc&lt;T&gt;</code></a></h2>
<p><a href="items/associated-items.html#associated-functions-and-methods">Methods</a> can take <a href="../std/rc/struct.Rc.html"><code>Rc&lt;Self&gt;</code></a> as a receiver.</p>
<h2><a class="header" href="#arct" id="arct"><code>Arc&lt;T&gt;</code></a></h2>
<p><a href="items/associated-items.html#associated-functions-and-methods">Methods</a> can take <a href="../std/sync/struct.Arc.html"><code>Arc&lt;Self&gt;</code></a> as a receiver.</p>
<h2><a class="header" href="#pinp" id="pinp"><code>Pin&lt;P&gt;</code></a></h2>
<p><a href="items/associated-items.html#associated-functions-and-methods">Methods</a> can take <a href="../std/pin/struct.Pin.html"><code>Pin&lt;P&gt;</code></a> as a receiver.</p>
<h2><a class="header" href="#unsafecellt" id="unsafecellt"><code>UnsafeCell&lt;T&gt;</code></a></h2>
<p><a href="../std/cell/struct.UnsafeCell.html"><code>std::cell::UnsafeCell&lt;T&gt;</code></a> is used for <a href="interior-mutability.html">interior mutability</a>. It ensures that
the compiler doesn’t perform optimisations that are incorrect for such types.
It also ensures that <a href="items/static-items.html"><code>static</code> items</a> which have a type with interior
mutability aren’t placed in memory marked as read only.</p>
<h2><a class="header" href="#phantomdatat" id="phantomdatat"><code>PhantomData&lt;T&gt;</code></a></h2>
<p><a href="../std/marker/struct.PhantomData.html"><code>std::marker::PhantomData&lt;T&gt;</code></a> is a zero-sized, minimum alignment, type that
is considered to own a <code>T</code> for the purposes of <a href="subtyping.html#variance">variance</a>, <a href="../nomicon/dropck.html">drop check</a>, and
<a href="special-types-and-traits.html#auto-traits">auto traits</a>.</p>
<h2><a class="header" href="#operator-traits" id="operator-traits">Operator Traits</a></h2>
<p>The traits in <a href="../std/ops/index.html"><code>std::ops</code></a> and <a href="../std/cmp/index.html"><code>std::cmp</code></a> are used to overload <a href="expressions/operator-expr.html">operators</a>,
<a href="expressions/array-expr.html#array-and-slice-indexing-expressions">indexing expressions</a>, and <a href="expressions/call-expr.html">call expressions</a>.</p>
<h2><a class="header" href="#deref-and-derefmut" id="deref-and-derefmut"><code>Deref</code> and <code>DerefMut</code></a></h2>
<p>As well as overloading the unary <code>*</code> operator, <a href="../std/ops/trait.Deref.html"><code>Deref</code></a> and <a href="../std/ops/trait.DerefMut.html"><code>DerefMut</code></a> are
also used in <a href="expressions/method-call-expr.html">method resolution</a> and <a href="type-coercions.html#coercion-types">deref coercions</a>.</p>
<h2><a class="header" href="#drop" id="drop"><code>Drop</code></a></h2>
<p>The <a href="../std/ops/trait.Drop.html"><code>Drop</code></a> trait provides a <a href="destructors.html">destructor</a>, to be run whenever a value of this
type is to be destroyed.</p>
<h2><a class="header" href="#copy" id="copy"><code>Copy</code></a></h2>
<p>The <a href="../std/marker/trait.Copy.html"><code>Copy</code></a> trait changes the semantics of a type implementing it. Values
whose type implements <code>Copy</code> are copied rather than moved upon assignment.</p>
<p><code>Copy</code> can only be implemented for types which do not implement <code>Drop</code>, and whose fields are all <code>Copy</code>.
For enums, this means all fields of all variants have to be <code>Copy</code>.
For unions, this means all variants have to be <code>Copy</code>.</p>
<p><code>Copy</code> is implemented by the compiler for</p>
<ul>
<li><a href="types/numeric.html">Numeric types</a></li>
<li><code>char</code>, <code>bool</code>, and <a href="types/never.html"><code>!</code></a></li>
<li><a href="types/tuple.html">Tuples</a> of <code>Copy</code> types</li>
<li><a href="types/array.html">Arrays</a> of <code>Copy</code> types</li>
<li><a href="types/pointer.html#shared-references-">Shared references</a></li>
<li><a href="types/pointer.html#raw-pointers-const-and-mut">Raw pointers</a></li>
<li><a href="types/function-pointer.html">Function pointers</a> and <a href="types/function-item.html">function item types</a></li>
</ul>
<h2><a class="header" href="#clone" id="clone"><code>Clone</code></a></h2>
<p>The <a href="../std/clone/trait.Clone.html"><code>Clone</code></a> trait is a supertrait of <code>Copy</code>, so it also needs compiler
generated implementations. It is implemented by the compiler for the following
types:</p>
<ul>
<li>Types with a built-in <code>Copy</code> implementation (see above)</li>
<li><a href="types/tuple.html">Tuples</a> of <code>Clone</code> types</li>
<li><a href="types/array.html">Arrays</a> of <code>Clone</code> types</li>
</ul>
<h2><a class="header" href="#send" id="send"><code>Send</code></a></h2>
<p>The <a href="../std/marker/trait.Send.html"><code>Send</code></a> trait indicates that a value of this type is safe to send from one
thread to another.</p>
<h2><a class="header" href="#sync" id="sync"><code>Sync</code></a></h2>
<p>The <a href="../std/marker/trait.Sync.html"><code>Sync</code></a> trait indicates that a value of this type is safe to share between
multiple threads. This trait must be implemented for all types used in
immutable <a href="items/static-items.html"><code>static</code> items</a>.</p>
<h2><a class="header" href="#auto-traits" id="auto-traits">Auto traits</a></h2>
<p>The <a href="../std/marker/trait.Send.html"><code>Send</code></a>, <a href="../std/marker/trait.Sync.html"><code>Sync</code></a>, <a href="../std/panic/trait.UnwindSafe.html"><code>UnwindSafe</code></a>, and <a href="../std/panic/trait.RefUnwindSafe.html"><code>RefUnwindSafe</code></a> traits are <em>auto
traits</em>. Auto traits have special properties.</p>
<p>If no explicit implementation or negative implementation is written out for an
auto trait for a given type, then the compiler implements it automatically
according to the following rules:</p>
<ul>
<li><code>&amp;T</code>, <code>&amp;mut T</code>, <code>*const T</code>, <code>*mut T</code>, <code>[T; n]</code>, and <code>[T]</code> implement the trait
if <code>T</code> does.</li>
<li>Function item types and function pointers automatically implement the trait.</li>
<li>Structs, enums, unions, and tuples implement the trait if all of their fields
do.</li>
<li>Closures implement the trait if the types of all of their captures do. A
closure that captures a <code>T</code> by shared reference and a <code>U</code> by value implements
any auto traits that both <code>&amp;T</code> and <code>U</code> do.</li>
</ul>
<p>For generic types (counting the built-in types above as generic over <code>T</code>), if a
generic implementation is available, then the compiler does not automatically
implement it for types that could use the implementation except that they do not
meet the requisite trait bounds. For instance, the standard library implements
<code>Send</code> for all <code>&amp;T</code> where <code>T</code> is <code>Sync</code>; this means that the compiler will not
implement <code>Send</code> for <code>&amp;T</code> if <code>T</code> is <code>Send</code> but not <code>Sync</code>.</p>
<p>Auto traits can also have negative implementations, shown as <code>impl !AutoTrait for T</code> in the standard library documentation, that override the automatic
implementations. For example <code>*mut T</code> has a negative implementation of <code>Send</code>,
and so <code>*mut T</code> is not <code>Send</code>, even if <code>T</code> is. There is currently no stable way
to specify additional negative implementations; they exist only in the standard
library.</p>
<p>Auto traits may be added as an additional bound to any <a href="types/trait-object.html">trait object</a>, even
though normally only one trait is allowed. For instance, <code>Box&lt;dyn Debug + Send + UnwindSafe&gt;</code> is a valid type.</p>
<h2><a class="header" href="#sized-1" id="sized-1"><code>Sized</code></a></h2>
<p>The <a href="../std/marker/trait.Sized.html"><code>Sized</code></a> trait indicates that the size of this type is known at
compile-time; that is, it’s not a <a href="dynamically-sized-types.html">dynamically sized type</a>. <a href="types/parameters.html">Type parameters</a>
are <code>Sized</code> by default. <code>Sized</code> is always implemented automatically by the
compiler, not by <a href="items/implementations.html">implementation items</a>.</p>
<h1><a class="header" href="#memory-model" id="memory-model">Memory model</a></h1>
<p>Rust does not yet have a defined memory model. Various academics and industry
are working on various proposals, but for now, this is an under-defined place
in the language.</p>
<h1><a class="header" href="#memory-allocation-and-lifetime" id="memory-allocation-and-lifetime">Memory allocation and lifetime</a></h1>
<p>The <em>items</em> of a program are those functions, modules, and types that have their
value calculated at compile-time and stored uniquely in the memory image of the
rust process. Items are neither dynamically allocated nor freed.</p>
<p>The <em>heap</em> is a general term that describes boxes.  The lifetime of an
allocation in the heap depends on the lifetime of the box values pointing to
it. Since box values may themselves be passed in and out of frames, or stored
in the heap, heap allocations may outlive the frame they are allocated within.
An allocation in the heap is guaranteed to reside at a single location in the
heap for the whole lifetime of the allocation - it will never be relocated as
a result of moving a box value.</p>
<h2><a class="header" href="#memory-ownership" id="memory-ownership">Memory ownership</a></h2>
<p>When a stack frame is exited, its local allocations are all released, and its
references to boxes are dropped.</p>
<h1><a class="header" href="#variables" id="variables">Variables</a></h1>
<p>A <em>variable</em> is a component of a stack frame, either a named function parameter,
an anonymous <a href="expressions.html#temporary-lifetimes">temporary</a>, or a named local
variable.</p>
<p>A <em>local variable</em> (or <em>stack-local</em> allocation) holds a value directly,
allocated within the stack’s memory. The value is a part of the stack frame.</p>
<p>Local variables are immutable unless declared otherwise. For example:
<code>let mut x = ...</code>.</p>
<p>Function parameters are immutable unless declared with <code>mut</code>. The <code>mut</code> keyword
applies only to the following parameter. For example: <code>|mut x, y|</code> and
<code>fn f(mut x: Box&lt;i32&gt;, y: Box&lt;i32&gt;)</code> declare one mutable variable <code>x</code> and one
immutable variable <code>y</code>.</p>
<p>Local variables are not initialized when allocated. Instead, the entire frame
worth of local variables are allocated, on frame-entry, in an uninitialized
state. Subsequent statements within a function may or may not initialize the
local variables. Local variables can be used only after they have been
initialized through all reachable control flow paths.</p>
<p>In this next example, <code>init_after_if</code> is initialized after the <a href="expressions/if-expr.html#if-expressions"><code>if</code> expression</a>
while <code>uninit_after_if</code> is not because it is not initialized in the <code>else</code> case.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">fn random_bool() -&gt; bool { true }
</span>fn initialization_example() {
    let init_after_if: ();
    let uninit_after_if: ();

    if random_bool() {
        init_after_if = ();
        uninit_after_if = ();
    } else {
        init_after_if = ();
    }

    init_after_if; // ok
    // uninit_after_if; // err: use of possibly uninitialized `uninit_after_if`
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#linkage" id="linkage">Linkage</a></h1>
<blockquote>
<p>Note: This section is described more in terms of the compiler than of
the language.</p>
</blockquote>
<p>The compiler supports various methods to link crates together both
statically and dynamically. This section will explore the various methods to
link crates together, and more information about native libraries can be
found in the <a href="../book/ffi.html">FFI section of the book</a>.</p>
<p>In one session of compilation, the compiler can generate multiple artifacts
through the usage of either command line flags or the <code>crate_type</code> attribute.
If one or more command line flags are specified, all <code>crate_type</code> attributes will
be ignored in favor of only building the artifacts specified by command line.</p>
<ul>
<li>
<p><code>--crate-type=bin</code>, <code>#[crate_type = &quot;bin&quot;]</code> - A runnable executable will be
produced. This requires that there is a <code>main</code> function in the crate which
will be run when the program begins executing. This will link in all Rust and
native dependencies, producing a distributable binary.</p>
</li>
<li>
<p><code>--crate-type=lib</code>, <code>#[crate_type = &quot;lib&quot;]</code> - A Rust library will be produced.
This is an ambiguous concept as to what exactly is produced because a library
can manifest itself in several forms. The purpose of this generic <code>lib</code> option
is to generate the “compiler recommended” style of library. The output library
will always be usable by rustc, but the actual type of library may change from
time-to-time. The remaining output types are all different flavors of
libraries, and the <code>lib</code> type can be seen as an alias for one of them (but the
actual one is compiler-defined).</p>
</li>
<li>
<p><code>--crate-type=dylib</code>, <code>#[crate_type = &quot;dylib&quot;]</code> - A dynamic Rust library will
be produced. This is different from the <code>lib</code> output type in that this forces
dynamic library generation. The resulting dynamic library can be used as a
dependency for other libraries and/or executables. This output type will
create <code>*.so</code> files on linux, <code>*.dylib</code> files on osx, and <code>*.dll</code> files on
windows.</p>
</li>
<li>
<p><code>--crate-type=staticlib</code>, <code>#[crate_type = &quot;staticlib&quot;]</code> - A static system
library will be produced. This is different from other library outputs in that
the compiler will never attempt to link to <code>staticlib</code> outputs. The
purpose of this output type is to create a static library containing all of
the local crate’s code along with all upstream dependencies. The static
library is actually a <code>*.a</code> archive on linux and osx and a <code>*.lib</code> file on
windows. This format is recommended for use in situations such as linking
Rust code into an existing non-Rust application because it will not have
dynamic dependencies on other Rust code.</p>
</li>
<li>
<p><code>--crate-type=cdylib</code>, <code>#[crate_type = &quot;cdylib&quot;]</code> - A dynamic system
library will be produced.  This is used when compiling
a dynamic library to be loaded from another language.  This output type will
create <code>*.so</code> files on Linux, <code>*.dylib</code> files on macOS, and <code>*.dll</code> files on
Windows.</p>
</li>
<li>
<p><code>--crate-type=rlib</code>, <code>#[crate_type = &quot;rlib&quot;]</code> - A “Rust library” file will be
produced. This is used as an intermediate artifact and can be thought of as a
“static Rust library”. These <code>rlib</code> files, unlike <code>staticlib</code> files, are
interpreted by the compiler in future linkage. This essentially means
that <code>rustc</code> will look for metadata in <code>rlib</code> files like it looks for metadata
in dynamic libraries. This form of output is used to produce statically linked
executables as well as <code>staticlib</code> outputs.</p>
</li>
<li>
<p><code>--crate-type=proc-macro</code>, <code>#[crate_type = &quot;proc-macro&quot;]</code> - The output
produced is not specified, but if a <code>-L</code> path is provided to it then the
compiler will recognize the output artifacts as a macro and it can be loaded
for a program. Crates compiled with this crate type  must only export
<a href="procedural-macros.html">procedural macros</a>. The compiler will automatically set the <code>proc_macro</code>
<a href="conditional-compilation.html">configuration option</a>. The crates are always compiled with the same target
that the compiler itself was built with. For example, if you are executing
the compiler from Linux with an <code>x86_64</code> CPU, the target will be
<code>x86_64-unknown-linux-gnu</code> even if the crate is a dependency of another crate
being built for a different target.</p>
</li>
</ul>
<p>Note that these outputs are stackable in the sense that if multiple are
specified, then the compiler will produce each form of output at once without
having to recompile. However, this only applies for outputs specified by the
same method. If only <code>crate_type</code> attributes are specified, then they will all
be built, but if one or more <code>--crate-type</code> command line flags are specified,
then only those outputs will be built.</p>
<p>With all these different kinds of outputs, if crate A depends on crate B, then
the compiler could find B in various different forms throughout the system. The
only forms looked for by the compiler, however, are the <code>rlib</code> format and the
dynamic library format. With these two options for a dependent library, the
compiler must at some point make a choice between these two formats. With this
in mind, the compiler follows these rules when determining what format of
dependencies will be used:</p>
<ol>
<li>
<p>If a static library is being produced, all upstream dependencies are
required to be available in <code>rlib</code> formats. This requirement stems from the
reason that a dynamic library cannot be converted into a static format.</p>
<p>Note that it is impossible to link in native dynamic dependencies to a static
library, and in this case warnings will be printed about all unlinked native
dynamic dependencies.</p>
</li>
<li>
<p>If an <code>rlib</code> file is being produced, then there are no restrictions on what
format the upstream dependencies are available in. It is simply required that
all upstream dependencies be available for reading metadata from.</p>
<p>The reason for this is that <code>rlib</code> files do not contain any of their upstream
dependencies. It wouldn’t be very efficient for all <code>rlib</code> files to contain a
copy of <code>libstd.rlib</code>!</p>
</li>
<li>
<p>If an executable is being produced and the <code>-C prefer-dynamic</code> flag is not
specified, then dependencies are first attempted to be found in the <code>rlib</code>
format. If some dependencies are not available in an rlib format, then
dynamic linking is attempted (see below).</p>
</li>
<li>
<p>If a dynamic library or an executable that is being dynamically linked is
being produced, then the compiler will attempt to reconcile the available
dependencies in either the rlib or dylib format to create a final product.</p>
<p>A major goal of the compiler is to ensure that a library never appears more
than once in any artifact. For example, if dynamic libraries B and C were
each statically linked to library A, then a crate could not link to B and C
together because there would be two copies of A. The compiler allows mixing
the rlib and dylib formats, but this restriction must be satisfied.</p>
<p>The compiler currently implements no method of hinting what format a library
should be linked with. When dynamically linking, the compiler will attempt to
maximize dynamic dependencies while still allowing some dependencies to be
linked in via an rlib.</p>
<p>For most situations, having all libraries available as a dylib is recommended
if dynamically linking. For other situations, the compiler will emit a
warning if it is unable to determine which formats to link each library with.</p>
</li>
</ol>
<p>In general, <code>--crate-type=bin</code> or <code>--crate-type=lib</code> should be sufficient for
all compilation needs, and the other options are just available if more
fine-grained control is desired over the output format of a crate.</p>
<h2><a class="header" href="#static-and-dynamic-c-runtimes" id="static-and-dynamic-c-runtimes">Static and dynamic C runtimes</a></h2>
<p>The standard library in general strives to support both statically linked and
dynamically linked C runtimes for targets as appropriate. For example the
<code>x86_64-pc-windows-msvc</code> and <code>x86_64-unknown-linux-musl</code> targets typically come
with both runtimes and the user selects which one they’d like. All targets in
the compiler have a default mode of linking to the C runtime. Typically targets
are linked dynamically by default, but there are exceptions which are static by
default such as:</p>
<ul>
<li><code>arm-unknown-linux-musleabi</code></li>
<li><code>arm-unknown-linux-musleabihf</code></li>
<li><code>armv7-unknown-linux-musleabihf</code></li>
<li><code>i686-unknown-linux-musl</code></li>
<li><code>x86_64-unknown-linux-musl</code></li>
</ul>
<p>The linkage of the C runtime is configured to respect the <code>crt-static</code> target
feature. These target features are typically configured from the command line
via flags to the compiler itself. For example to enable a static runtime you
would execute:</p>
<pre><code class="language-bash">rustc -C target-feature=+crt-static foo.rs
</code></pre>
<p>whereas to link dynamically to the C runtime you would execute:</p>
<pre><code class="language-bash">rustc -C target-feature=-crt-static foo.rs
</code></pre>
<p>Targets which do not support switching between linkage of the C runtime will
ignore this flag. It’s recommended to inspect the resulting binary to ensure
that it’s linked as you would expect after the compiler succeeds.</p>
<p>Crates may also learn about how the C runtime is being linked. Code on MSVC, for
example, needs to be compiled differently (e.g. with <code>/MT</code> or <code>/MD</code>) depending
on the runtime being linked. This is exported currently through the
<a href="conditional-compilation.html#target_feature"><code>cfg</code> attribute <code>target_feature</code> option</a>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[cfg(target_feature = &quot;crt-static&quot;)]
fn foo() {
    println!(&quot;the C runtime should be statically linked&quot;);
}

#[cfg(not(target_feature = &quot;crt-static&quot;))]
fn foo() {
    println!(&quot;the C runtime should be dynamically linked&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Also note that Cargo build scripts can learn about this feature through
<a href="../cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">environment variables</a>. In a build script you can detect the linkage
via:</p>
<pre><pre class="playpen"><code class="language-rust">use std::env;

fn main() {
    let linkage = env::var(&quot;CARGO_CFG_TARGET_FEATURE&quot;).unwrap_or(String::new());

    if linkage.contains(&quot;crt-static&quot;) {
        println!(&quot;the C runtime will be statically linked&quot;);
    } else {
        println!(&quot;the C runtime will be dynamically linked&quot;);
    }
}
</code></pre></pre>
<p>To use this feature locally, you typically will use the <code>RUSTFLAGS</code> environment
variable to specify flags to the compiler through Cargo. For example to compile
a statically linked binary on MSVC you would execute:</p>
<pre><code class="language-bash">RUSTFLAGS='-C target-feature=+crt-static' cargo build --target x86_64-pc-windows-msvc
</code></pre>
<h1><a class="header" href="#unsafety" id="unsafety">Unsafety</a></h1>
<p>Unsafe operations are those that can potentially violate the memory-safety
guarantees of Rust’s static semantics.</p>
<p>The following language level features cannot be used in the safe subset of
Rust:</p>
<ul>
<li>Dereferencing a <a href="types/pointer.html">raw pointer</a>.</li>
<li>Reading or writing a <a href="items/static-items.html#mutable-statics">mutable</a> or <a href="items/external-blocks.html">external</a> static variable.</li>
<li>Accessing a field of a <a href="items/unions.html"><code>union</code></a>, other than to assign to it.</li>
<li>Calling an unsafe function (including an intrinsic or foreign function).</li>
<li>Implementing an <a href="items/traits.html#unsafe-traits">unsafe trait</a>.</li>
</ul>
<h1><a class="header" href="#unsafe-functions" id="unsafe-functions">Unsafe functions</a></h1>
<p>Unsafe functions are functions that are not safe in all contexts and/or for all
possible inputs. Such a function must be prefixed with the keyword <code>unsafe</code> and
can only be called from an <code>unsafe</code> block or another <code>unsafe</code> function.</p>
<h1><a class="header" href="#unsafe-blocks-1" id="unsafe-blocks-1">Unsafe blocks</a></h1>
<p>A block of code can be prefixed with the <code>unsafe</code> keyword, to permit calling
<code>unsafe</code> functions or dereferencing raw pointers within a safe function.</p>
<p>When a programmer has sufficient conviction that a sequence of potentially
unsafe operations is actually safe, they can encapsulate that sequence (taken
as a whole) within an <code>unsafe</code> block. The compiler will consider uses of such
code safe, in the surrounding context.</p>
<p>Unsafe blocks are used to wrap foreign libraries, make direct use of hardware
or implement features not directly present in the language. For example, Rust
provides the language features necessary to implement memory-safe concurrency
in the language but the implementation of threads and message passing is in the
standard library.</p>
<p>Rust’s type system is a conservative approximation of the dynamic safety
requirements, so in some cases there is a performance cost to using safe code.
For example, a doubly-linked list is not a tree structure and can only be
represented with reference-counted pointers in safe code. By using <code>unsafe</code>
blocks to represent the reverse links as raw pointers, it can be implemented
with only boxes.</p>
<h2><a class="header" href="#behavior-considered-undefined" id="behavior-considered-undefined">Behavior considered undefined</a></h2>
<p>Rust code is incorrect if it exhibits any of the behaviors in the following
list. This includes code within <code>unsafe</code> blocks and <code>unsafe</code> functions.
<code>unsafe</code> only means that avoiding undefined behavior is on the programmer; it
does not change anything about the fact that Rust programs must never cause
undefined behavior.</p>
<p>It is the programmer’s responsibility when writing <code>unsafe</code> code to ensure that
any safe code interacting with the <code>unsafe</code> code cannot trigger these
behaviors. <code>unsafe</code> code that satisfies this property for any safe client is
called <em>sound</em>; if <code>unsafe</code> code can be misused by safe code to exhibit
undefined behavior, it is <em>unsound</em>.</p>
<div class="warning">
<p><em><strong>Warning:</strong></em> The following list is not exhaustive. There is no formal model of
Rust’s semantics for what is and is not allowed in unsafe code, so there may be
more behavior considered unsafe. The following list is just what we know for
sure is undefined behavior. Please read the <a href="../nomicon/index.html">Rustonomicon</a> before writing unsafe
code.</p>
</div>
<ul>
<li>Data races.</li>
<li>Dereferencing (using the <code>*</code> operator on) a dangling or unaligned raw pointer.</li>
<li>Breaking the <a href="http://llvm.org/docs/LangRef.html#pointer-aliasing-rules">pointer aliasing rules</a>. <code>&amp;mut T</code> and <code>&amp;T</code> follow LLVM’s scoped
<a href="http://llvm.org/docs/LangRef.html#noalias">noalias</a> model, except if the <code>&amp;T</code> contains an <a href="../std/cell/struct.UnsafeCell.html"><code>UnsafeCell&lt;U&gt;</code></a>.</li>
<li>Mutating immutable data. All data inside a <a href="items/constant-items.html"><code>const</code></a> item is immutable. Moreover, all
data reached through a shared reference or data owned by an immutable binding
is immutable, unless that data is contained within an <a href="../std/cell/struct.UnsafeCell.html"><code>UnsafeCell&lt;U&gt;</code></a>.</li>
<li>Invoking undefined behavior via compiler intrinsics.</li>
<li>Executing code compiled with platform features that the current platform
does not support (see <a href="attributes/codegen.html#the-target_feature-attribute"><code>target_feature</code></a>).</li>
<li>Calling a function with the wrong call ABI or unwinding from a function with the wrong unwind ABI.</li>
<li>Producing an invalid value, even in private fields and locals. “Producing” a
value happens any time a value is assigned to or read from a place, passed to
a function/primitive operation or returned from a function/primitive
operation.
The following values are invalid (at their respective type):
<ul>
<li>
<p>A value other than <code>false</code> (<code>0</code>) or <code>true</code> (<code>1</code>) in a <code>bool</code>.</p>
</li>
<li>
<p>A discriminant in an <code>enum</code> not included in the type definition.</p>
</li>
<li>
<p>A null <code>fn</code> pointer.</p>
</li>
<li>
<p>A value in a <code>char</code> which is a surrogate or above <code>char::MAX</code>.</p>
</li>
<li>
<p>A <code>!</code> (all values are invalid for this type).</p>
</li>
<li>
<p>An integer (<code>i*</code>/<code>u*</code>), floating point value (<code>f*</code>), or raw pointer obtained
from <a href="http://llvm.org/docs/LangRef.html#undefined-values">uninitialized memory</a>.</p>
</li>
<li>
<p>A reference or <code>Box&lt;T&gt;</code> that is dangling, unaligned, or points to an invalid value.</p>
</li>
<li>
<p>Invalid metadata in a wide reference, <code>Box&lt;T&gt;</code>, or raw pointer:</p>
<ul>
<li><code>dyn Trait</code> metadata is invalid if it is not a pointer to a vtable for
<code>Trait</code> that matches the actual dynamic trait the pointer or reference points to.</li>
<li>Slice metadata is invalid if the length is not a valid <code>usize</code>
(i.e., it must not be read from uninitialized memory).</li>
</ul>
</li>
<li>
<p>Non-UTF-8 byte sequences in a <code>str</code>.</p>
</li>
<li>
<p>Invalid values for a type with a custom definition of invalid values.
In the standard library, this affects <a href="../core/ptr/struct.NonNull.html"><code>NonNull&lt;T&gt;</code></a> and <a href="../core/num/index.html"><code>NonZero*</code></a>.</p>
<blockquote>
<p><strong>Note</strong>: <code>rustc</code> achieves this with the unstable
<code>rustc_layout_scalar_valid_range_*</code> attributes.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>A reference/pointer is “dangling” if it is null or not all of the bytes it
points to are part of the same allocation (so in particular they all have to be
part of <em>some</em> allocation). The span of bytes it points to is determined by the
pointer value and the size of the pointee type. As a consequence, if the span is
empty, “dangling” is the same as “non-null”. Note that slices point to their
entire range, so it is important that the length metadata is never too
large. In particular, allocations and therefore slices cannot be bigger than
<code>isize::MAX</code> bytes.</p>
<blockquote>
<p><strong>Note</strong>: Undefined behavior affects the entire program. For example, calling
a function in C that exhibits undefined behavior of C means your entire
program contains undefined behaviour that can also affect the Rust code. And
vice versa, undefined behavior in Rust can cause adverse affects on code
executed by any FFI calls to other languages.</p>
</blockquote>
<h2><a class="header" href="#behavior-not-considered-unsafe" id="behavior-not-considered-unsafe">Behavior not considered <code>unsafe</code></a></h2>
<p>The Rust compiler does not consider the following behaviors <em>unsafe</em>,
though a programmer may (should) find them undesirable, unexpected,
or erroneous.</p>
<h5><a class="header" href="#deadlocks" id="deadlocks">Deadlocks</a></h5>
<h5><a class="header" href="#leaks-of-memory-and-other-resources" id="leaks-of-memory-and-other-resources">Leaks of memory and other resources</a></h5>
<h5><a class="header" href="#exiting-without-calling-destructors" id="exiting-without-calling-destructors">Exiting without calling destructors</a></h5>
<h5><a class="header" href="#exposing-randomized-base-addresses-through-pointer-leaks" id="exposing-randomized-base-addresses-through-pointer-leaks">Exposing randomized base addresses through pointer leaks</a></h5>
<h5><a class="header" href="#integer-overflow" id="integer-overflow">Integer overflow</a></h5>
<p>If a program contains arithmetic overflow, the programmer has made an
error. In the following discussion, we maintain a distinction between
arithmetic overflow and wrapping arithmetic. The first is erroneous,
while the second is intentional.</p>
<p>When the programmer has enabled <code>debug_assert!</code> assertions (for
example, by enabling a non-optimized build), implementations must
insert dynamic checks that <code>panic</code> on overflow. Other kinds of builds
may result in <code>panics</code> or silently wrapped values on overflow, at the
implementation’s discretion.</p>
<p>In the case of implicitly-wrapped overflow, implementations must
provide well-defined (even if still considered erroneous) results by
using two’s complement overflow conventions.</p>
<p>The integral types provide inherent methods to allow programmers
explicitly to perform wrapping arithmetic. For example,
<code>i32::wrapping_add</code> provides two’s complement, wrapping addition.</p>
<p>The standard library also provides a <code>Wrapping&lt;T&gt;</code> newtype which
ensures all standard arithmetic operations for <code>T</code> have wrapping
semantics.</p>
<p>See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md">RFC 560</a> for error conditions, rationale, and more details about
integer overflow.</p>
<h1><a class="header" href="#constant-evaluation" id="constant-evaluation">Constant evaluation</a></h1>
<p>Constant evaluation is the process of computing the result of
<a href="expressions.html">expressions</a> during compilation. Only a subset of all expressions
can be evaluated at compile-time.</p>
<h2><a class="header" href="#constant-expressions" id="constant-expressions">Constant expressions</a></h2>
<p>Certain forms of expressions, called constant expressions, can be evaluated at
compile time. In <a href="const_eval.html#const-context">const contexts</a>, these are the only allowed
expressions, and are always evaluated at compile time. In other places, such as
<a href="statements.html#let-statements">let statements</a>, constant expressions <em>may</em>
be, but are not guaranteed to be, evaluated at compile time. Behaviors such as
out of bounds <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">array indexing</a> or <a href="expressions/operator-expr.html#overflow">overflow</a> are compiler errors if the value
must be evaluated at compile time (i.e. in const contexts). Otherwise, these
behaviors are warnings, but will likely panic at run-time.</p>
<p>The following expressions are constant expressions, so long as any operands are
also constant expressions and do not cause any <a href="destructors.html"><code>Drop::drop</code></a> calls
to be run.</p>
<ul>
<li><a href="expressions/literal-expr.html">Literals</a>.</li>
<li><a href="expressions/path-expr.html">Paths</a> to <a href="items/functions.html">functions</a> and constants.
Recursively defining constants is not allowed.</li>
<li><a href="expressions/tuple-expr.html">Tuple expressions</a>.</li>
<li><a href="expressions/array-expr.html">Array expressions</a>.</li>
<li><a href="expressions/struct-expr.html">Struct</a> expressions.</li>
<li><a href="expressions/enum-variant-expr.html">Enum variant</a> expressions.</li>
<li><a href="expressions/block-expr.html">Block expressions</a>, including <code>unsafe</code> blocks.
<ul>
<li><a href="statements.html#let-statements">let statements</a> and thus irrefutable <a href="patterns.html">patterns</a>, with the caveat that until <code>if</code> and <code>match</code>
are implemented, one cannot use both short circuiting operators (<code>&amp;&amp;</code> and <code>||</code>) and let
statements within the same constant.</li>
<li><a href="expressions/operator-expr.html#assignment-expressions">assignment expressions</a></li>
<li><a href="expressions/operator-expr.html#compound-assignment-expressions">compound assignment expressions</a></li>
<li><a href="statements.html#expression-statements">expression statements</a></li>
</ul>
</li>
<li><a href="expressions/field-expr.html">Field</a> expressions.</li>
<li>Index expressions, <a href="expressions/array-expr.html#array-and-slice-indexing-expressions">array indexing</a> or <a href="types/slice.html">slice</a> with a <code>usize</code>.</li>
<li><a href="expressions/range-expr.html">Range expressions</a>.</li>
<li><a href="expressions/closure-expr.html">Closure expressions</a> which don’t capture variables from the environment.</li>
<li>Built-in <a href="expressions/operator-expr.html#negation-operators">negation</a>, <a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">arithmetic</a>, <a href="expressions/operator-expr.html#arithmetic-and-logical-binary-operators">logical</a>, <a href="expressions/operator-expr.html#comparison-operators">comparison</a> or <a href="expressions/operator-expr.html#lazy-boolean-operators">lazy boolean</a>
operators used on integer and floating point types, <code>bool</code>, and <code>char</code>.</li>
<li>Shared <a href="expressions/operator-expr.html#borrow-operators">borrow</a>s, except if applied to a type with <a href="interior-mutability.html">interior mutability</a>.</li>
<li>The <a href="expressions/operator-expr.html#the-dereference-operator">dereference operator</a>.</li>
<li><a href="expressions/grouped-expr.html">Grouped</a> expressions.</li>
<li><a href="expressions/operator-expr.html#type-cast-expressions">Cast</a> expressions, except pointer to address and
function pointer to address casts.</li>
<li>Calls of <a href="items/functions.html#const-functions">const functions</a> and const methods.</li>
</ul>
<h2><a class="header" href="#const-context" id="const-context">Const context</a></h2>
<p>A <em>const context</em> is one of the following:</p>
<ul>
<li><a href="types/array.html">Array type length expressions</a></li>
<li>Repeat expression length expressions</li>
<li>The initializer of
<ul>
<li><a href="items/constant-items.html">constants</a></li>
<li><a href="items/static-items.html">statics</a></li>
<li><a href="items/enumerations.html#custom-discriminant-values-for-fieldless-enumerations">enum discriminants</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#application-binary-interface-abi" id="application-binary-interface-abi">Application Binary Interface (ABI)</a></h1>
<p>This section documents features that affect the ABI of the compiled output of
a crate.</p>
<p>See <em><a href="items/functions.html#extern-function-qualifier">extern functions</a></em> for information on specifying the ABI for exporting
functions. See <em><a href="items/external-blocks.html">external blocks</a></em> for information on specifying the ABI for
linking external libraries.</p>
<h2><a class="header" href="#the-used-attribute" id="the-used-attribute">The <code>used</code> attribute</a></h2>
<p>The <em><code>used</code> attribute</em> can only be applied to <a href="items/static-items.html"><code>static</code> items</a>. This <a href="attributes.html">attribute</a> forces the
compiler to keep the variable in the output object file (.o, .rlib, etc. excluding final binaries)
even if the variable is not used, or referenced, by any other item in the crate.
However, the linker is still free to remove such an item.</p>
<p>Below is an example that shows under what conditions the compiler keeps a <code>static</code> item in the
output object file.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// foo.rs

// This is kept because of `#[used]`:
#[used]
static FOO: u32 = 0;

// This is removable because it is unused:
#[allow(dead_code)]
static BAR: u32 = 0;

// This is kept because it is publicly reachable:
pub static BAZ: u32 = 0;

// This is kept because it is referenced by a public, reachable function:
static QUUX: u32 = 0;

pub fn quux() -&gt; &amp;'static u32 {
    &amp;QUUX
}

// This is removable because it is referenced by a private, unused (dead) function:
static CORGE: u32 = 0;

#[allow(dead_code)]
fn corge() -&gt; &amp;'static u32 {
    &amp;CORGE
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-console">$ rustc -O --emit=obj --crate-type=rlib foo.rs

$ nm -C foo.o
0000000000000000 R foo::BAZ
0000000000000000 r foo::FOO
0000000000000000 R foo::QUUX
0000000000000000 T foo::quux
</code></pre>
<h2><a class="header" href="#the-no_mangle-attribute" id="the-no_mangle-attribute">The <code>no_mangle</code> attribute</a></h2>
<p>The <em><code>no_mangle</code> attribute</em> may be used on any <a href="items.html">item</a> to disable standard
symbol name mangling. The symbol for the item will be the identifier of the
item’s name.</p>
<h2><a class="header" href="#the-link_section-attribute" id="the-link_section-attribute">The <code>link_section</code> attribute</a></h2>
<p>The <em><code>link_section</code> attribute</em> specifies the section of the object file that a
<a href="items/functions.html">function</a> or <a href="items/static-items.html">static</a>‘s content will be placed into. It uses the
<a href="attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> syntax to specify the section name.</p>
<!-- no_run: don't link. The format of the section name is platform-specific. -->
<pre><pre class="playpen"><code class="language-rust no_run">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
#[link_section = &quot;.example_section&quot;]
pub static VAR1: u32 = 1;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#the-export_name-attribute" id="the-export_name-attribute">The <code>export_name</code> attribute</a></h2>
<p>The <em><code>export_name</code> attribute</em> specifies the name of the symbol that will be
exported on a <a href="items/functions.html">function</a> or <a href="items/static-items.html">static</a>. It uses the <a href="attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> syntax
to specify the symbol name.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[export_name = &quot;exported_symbol_name&quot;]
pub fn name_in_rust() { }
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#the-rust-runtime" id="the-rust-runtime">The Rust runtime</a></h1>
<p>This section documents features that define some aspects of the Rust runtime.</p>
<h2><a class="header" href="#the-panic_handler-attribute" id="the-panic_handler-attribute">The <code>panic_handler</code> attribute</a></h2>
<p>The <em><code>panic_handler</code> attribute</em> can only be applied to a function with signature
<code>fn(&amp;PanicInfo) -&gt; !</code>. The function marked with this <a href="attributes.html">attribute</a> defines the behavior of panics. The
<a href="../core/panic/struct.PanicInfo.html"><code>PanicInfo</code></a> struct contains information about the location of the panic. There must be a single
<code>panic_handler</code> function in the dependency graph of a binary, dylib or cdylib crate.</p>
<p>Below is shown a <code>panic_handler</code> function that logs the panic message and then halts the
thread.</p>
<!-- ignore: test infrastructure can't handle no_std -->
<pre><code class="language-rust ignore">#![no_std]

use core::fmt::{self, Write};
use core::panic::PanicInfo;

struct Sink {
    // ..
<span class="boring">   _0: (),
</span>}
<span class="boring">
</span><span class="boring">impl Sink {
</span><span class="boring">    fn new() -&gt; Sink { Sink { _0: () }}
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl fmt::Write for Sink {
</span><span class="boring">    fn write_str(&amp;mut self, _: &amp;str) -&gt; fmt::Result { Ok(()) }
</span><span class="boring">}
</span>
#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    let mut sink = Sink::new();

    // logs &quot;panicked at '$reason', src/main.rs:27:4&quot; to some `sink`
    let _ = writeln!(sink, &quot;{}&quot;, info);

    loop {}
}
</code></pre>
<h3><a class="header" href="#standard-behavior" id="standard-behavior">Standard behavior</a></h3>
<p>The standard library provides an implementation of <code>panic_handler</code> that
defaults to unwinding the stack but that can be <a href="../book/ch09-01-unrecoverable-errors-with-panic.html">changed to abort the
process</a>. The standard library’s panic behavior can be modified at
runtime with the <a href="../std/panic/fn.set_hook.html">set_hook</a> function.</p>
<h2><a class="header" href="#the-global_allocator-attribute" id="the-global_allocator-attribute">The <code>global_allocator</code> attribute</a></h2>
<p>The <em><code>global_allocator</code> attribute</em> is used on a <a href="items/static-items.html">static item</a> implementing the
<a href="../alloc/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a> trait to set the global allocator.</p>
<h2><a class="header" href="#the-windows_subsystem-attribute" id="the-windows_subsystem-attribute">The <code>windows_subsystem</code> attribute</a></h2>
<p>The <em><code>windows_subsystem</code> attribute</em> may be applied at the crate level to set
the <a href="https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx">subsystem</a> when linking on a Windows target. It uses the
<a href="attributes.html#meta-item-attribute-syntax"><em>MetaNameValueStr</em></a> syntax to specify the subsystem with a value of either
<code>console</code> or <code>windows</code>. This attribute is ignored on non-Windows targets, and
for non-<code>bin</code> <a href="linkage.html">crate types</a>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span>#![windows_subsystem = &quot;windows&quot;]
<span class="boring">fn main() {
</span><span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#appendices" id="appendices">Appendices</a></h1>
<h1><a class="header" href="#appendix-macro-follow-set-ambiguity-formal-specification" id="appendix-macro-follow-set-ambiguity-formal-specification">Appendix: Macro Follow-Set Ambiguity Formal Specification</a></h1>
<p>This page documents the formal specification of the follow rules for <a href="macros-by-example.html">Macros
By Example</a>. They were originally specified in <a href="https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md">RFC 550</a>, from which the bulk
of this text is copied, and expanded upon in subsequent RFCs.</p>
<h2><a class="header" href="#definitions--conventions" id="definitions--conventions">Definitions &amp; Conventions</a></h2>
<ul>
<li><code>macro</code>: anything invokable as <code>foo!(...)</code> in source code.</li>
<li><code>MBE</code>: macro-by-example, a macro defined by <code>macro_rules</code>.</li>
<li><code>matcher</code>: the left-hand-side of a rule in a <code>macro_rules</code> invocation, or a
subportion thereof.</li>
<li><code>macro parser</code>: the bit of code in the Rust parser that will parse the
input using a grammar derived from all of the matchers.</li>
<li><code>fragment</code>: The class of Rust syntax that a given matcher will accept (or
“match”).</li>
<li><code>repetition</code> : a fragment that follows a regular repeating pattern</li>
<li><code>NT</code>: non-terminal, the various “meta-variables” or repetition matchers
that can appear in a matcher, specified in MBE syntax with a leading <code>$</code>
character.</li>
<li><code>simple NT</code>: a “meta-variable” non-terminal (further discussion below).</li>
<li><code>complex NT</code>: a repetition matching non-terminal, specified via repetition
operators (<code>\*</code>, <code>+</code>, <code>?</code>).</li>
<li><code>token</code>: an atomic element of a matcher; i.e. identifiers, operators,
open/close delimiters, <em>and</em> simple NT’s.</li>
<li><code>token tree</code>: a tree structure formed from tokens (the leaves), complex
NT’s, and finite sequences of token trees.</li>
<li><code>delimiter token</code>: a token that is meant to divide the end of one fragment
and the start of the next fragment.</li>
<li><code>separator token</code>: an optional delimiter token in an complex NT that
separates each pair of elements in the matched repetition.</li>
<li><code>separated complex NT</code>: a complex NT that has its own separator token.</li>
<li><code>delimited sequence</code>: a sequence of token trees with appropriate open- and
close-delimiters at the start and end of the sequence.</li>
<li><code>empty fragment</code>: The class of invisible Rust syntax that separates tokens,
i.e. whitespace, or (in some lexical contexts), the empty token sequence.</li>
<li><code>fragment specifier</code>: The identifier in a simple NT that specifies which
fragment the NT accepts.</li>
<li><code>language</code>: a context-free language.</li>
</ul>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>macro_rules! i_am_an_mbe {
    (start $foo:expr $($i:ident),* end) =&gt; ($foo)
}
<span class="boring">}
</span></code></pre></pre>
<p><code>(start $foo:expr $($i:ident),\* end)</code> is a matcher. The whole matcher is a
delimited sequence (with open- and close-delimiters <code>(</code> and <code>)</code>), and <code>$foo</code>
and <code>$i</code> are simple NT’s with <code>expr</code> and <code>ident</code> as their respective fragment
specifiers.</p>
<p><code>$(i:ident),\*</code> is <em>also</em> an NT; it is a complex NT that matches a
comma-separated repetition of identifiers. The <code>,</code> is the separator token for
the complex NT; it occurs in between each pair of elements (if any) of the
matched fragment.</p>
<p>Another example of a complex NT is <code>$(hi $e:expr ;)+</code>, which matches any
fragment of the form <code>hi &lt;expr&gt;; hi &lt;expr&gt;; ...</code> where <code>hi &lt;expr&gt;;</code> occurs at
least once. Note that this complex NT does not have a dedicated separator
token.</p>
<p>(Note that Rust’s parser ensures that delimited sequences always occur with
proper nesting of token tree structure and correct matching of open- and
close-delimiters.)</p>
<p>We will tend to use the variable “M” to stand for a matcher, variables “t” and
“u” for arbitrary individual tokens, and the variables “tt” and “uu” for
arbitrary token trees. (The use of “tt” does present potential ambiguity with
its additional role as a fragment specifier; but it will be clear from context
which interpretation is meant.)</p>
<p>“SEP” will range over separator tokens, “OP” over the repetition operators
<code>\*</code>, <code>+</code>, and <code>?</code>, “OPEN”/”CLOSE” over matching token pairs surrounding a
delimited sequence (e.g. <code>[</code> and <code>]</code>).</p>
<p>Greek letters “α” “β” “γ” “δ”  stand for potentially empty token-tree sequences.
(However, the Greek letter “ε” (epsilon) has a special role in the presentation
and does not stand for a token-tree sequence.)</p>
<ul>
<li>This Greek letter convention is usually just employed when the presence of
a sequence is a technical detail; in particular, when we wish to <em>emphasize</em>
that we are operating on a sequence of token-trees, we will use the notation
“tt ...” for the sequence, not a Greek letter.</li>
</ul>
<p>Note that a matcher is merely a token tree. A “simple NT”, as mentioned above,
is an meta-variable NT; thus it is a non-repetition. For example, <code>$foo:ty</code> is
a simple NT but <code>$($foo:ty)+</code> is a complex NT.</p>
<p>Note also that in the context of this formalism, the term “token” generally
<em>includes</em> simple NTs.</p>
<p>Finally, it is useful for the reader to keep in mind that according to the
definitions of this formalism, no simple NT matches the empty fragment, and
likewise no token matches the empty fragment of Rust syntax. (Thus, the <em>only</em>
NT that can match the empty fragment is a complex NT.) This is not actually
true, because the <code>vis</code> matcher can match an empty fragment. Thus, for the
purposes of the formalism, we will treat <code>$v:vis</code> as actually being
<code>$($v:vis)?</code>, with a requirement that the matcher match an empty fragment.</p>
<h3><a class="header" href="#the-matcher-invariants" id="the-matcher-invariants">The Matcher Invariants</a></h3>
<p>To be valid, a matcher must meet the following three invariants. The definitions
of FIRST and FOLLOW are described later.</p>
<ol>
<li>For any two successive token tree sequences in a matcher <code>M</code> (i.e. <code>M = ... tt uu ...</code>) with <code>uu ...</code> nonempty, we must have FOLLOW(<code>... tt</code>) ∪ {ε} ⊇
FIRST(<code>uu ...</code>).</li>
<li>For any separated complex NT in a matcher, <code>M = ... $(tt ...) SEP OP ...</code>,
we must have <code>SEP</code> ∈ FOLLOW(<code>tt ...</code>).</li>
<li>For an unseparated complex NT in a matcher, <code>M = ... $(tt ...) OP ...</code>, if
OP = <code>\*</code> or <code>+</code>, we must have FOLLOW(<code>tt ...</code>) ⊇ FIRST(<code>tt ...</code>).</li>
</ol>
<p>The first invariant says that whatever actual token that comes after a matcher,
if any, must be somewhere in the predetermined follow set.  This ensures that a
legal macro definition will continue to assign the same determination as to
where <code>... tt</code> ends and <code>uu ...</code> begins, even as new syntactic forms are added
to the language.</p>
<p>The second invariant says that a separated complex NT must use a separator token
that is part of the predetermined follow set for the internal contents of the
NT. This ensures that a legal macro definition will continue to parse an input
fragment into the same delimited sequence of <code>tt ...</code>‘s, even as new syntactic
forms are added to the language.</p>
<p>The third invariant says that when we have a complex NT that can match two or
more copies of the same thing with no separation in between, it must be
permissible for them to be placed next to each other as per the first invariant.
This invariant also requires they be nonempty, which eliminates a possible
ambiguity.</p>
<p><strong>NOTE: The third invariant is currently unenforced due to historical oversight
and significant reliance on the behaviour. It is currently undecided what to do
about this going forward. Macros that do not respect the behaviour may become
invalid in a future edition of Rust. See the <a href="https://github.com/rust-lang/rust/issues/56575">tracking issue</a>.</strong></p>
<h3><a class="header" href="#first-and-follow-informally" id="first-and-follow-informally">FIRST and FOLLOW, informally</a></h3>
<p>A given matcher M maps to three sets: FIRST(M), LAST(M) and FOLLOW(M).</p>
<p>Each of the three sets is made up of tokens. FIRST(M) and LAST(M) may also
contain a distinguished non-token element ε (”epsilon”), which indicates that M
can match the empty fragment. (But FOLLOW(M) is always just a set of tokens.)</p>
<p>Informally:</p>
<ul>
<li>
<p>FIRST(M): collects the tokens potentially used first when matching a
fragment to M.</p>
</li>
<li>
<p>LAST(M): collects the tokens potentially used last when matching a fragment
to M.</p>
</li>
<li>
<p>FOLLOW(M): the set of tokens allowed to follow immediately after some
fragment matched by M.</p>
<p>In other words: t ∈ FOLLOW(M) if and only if there exists (potentially
empty) token sequences α, β, γ, δ where:</p>
<ul>
<li>
<p>M matches β,</p>
</li>
<li>
<p>t matches γ, and</p>
</li>
<li>
<p>The concatenation α β γ δ is a parseable Rust program.</p>
</li>
</ul>
</li>
</ul>
<p>We use the shorthand ANYTOKEN to denote the set of all tokens (including simple
NTs). For example, if any token is legal after a matcher M, then FOLLOW(M) =
ANYTOKEN.</p>
<p>(To review one’s understanding of the above informal descriptions, the reader
at this point may want to jump ahead to the <a href="macro-ambiguity.html#examples-of-first-and-last">examples of
FIRST/LAST</a> before reading their formal
definitions.)</p>
<h3><a class="header" href="#first-last" id="first-last">FIRST, LAST</a></h3>
<p>Below are formal inductive definitions for FIRST and LAST.</p>
<p>“A ∪ B” denotes set union, “A ∩ B” denotes set intersection, and “A \ B”
denotes set difference (i.e. all elements of A that are not present in B).</p>
<h4><a class="header" href="#first" id="first">FIRST</a></h4>
<p>FIRST(M) is defined by case analysis on the sequence M and the structure of its
first token-tree (if any):</p>
<ul>
<li>
<p>if M is the empty sequence, then FIRST(M) = { ε },</p>
</li>
<li>
<p>if M starts with a token t, then FIRST(M) = { t },</p>
<p>(Note: this covers the case where M starts with a delimited token-tree
sequence, <code>M = OPEN tt ... CLOSE ...</code>, in which case <code>t = OPEN</code> and thus
FIRST(M) = { <code>OPEN</code> }.)</p>
<p>(Note: this critically relies on the property that no simple NT matches the
empty fragment.)</p>
</li>
<li>
<p>Otherwise, M is a token-tree sequence starting with a complex NT: <code>M = $( tt ... ) OP α</code>, or <code>M = $( tt ... ) SEP OP α</code>, (where <code>α</code> is the (potentially
empty) sequence of token trees for the rest of the matcher).</p>
<ul>
<li>Let SEP_SET(M) = { SEP } if SEP is present and ε ∈ FIRST(<code>tt ...</code>);
otherwise SEP_SET(M) = {}.</li>
</ul>
</li>
<li>
<p>Let ALPHA_SET(M) = FIRST(<code>α</code>) if OP = <code>\*</code> or <code>?</code> and ALPHA_SET(M) = {} if
OP = <code>+</code>.</p>
</li>
<li>
<p>FIRST(M) = (FIRST(<code>tt ...</code>) \ {ε}) ∪ SEP_SET(M) ∪ ALPHA_SET(M).</p>
</li>
</ul>
<p>The definition for complex NTs deserves some justification. SEP_SET(M) defines
the possibility that the separator could be a valid first token for M, which
happens when there is a separator defined and the repeated fragment could be
empty. ALPHA_SET(M) defines the possibility that the complex NT could be empty,
meaning that M’s valid first tokens are those of the following token-tree
sequences <code>α</code>. This occurs when either <code>\*</code> or <code>?</code> is used, in which case there
could be zero repetitions. In theory, this could also occur if <code>+</code> was used with
a potentially-empty repeating fragment, but this is forbidden by the third
invariant.</p>
<p>From there, clearly FIRST(M) can include any token from SEP_SET(M) or
ALPHA_SET(M), and if the complex NT match is nonempty, then any token starting
FIRST(<code>tt ...</code>) could work too. The last piece to consider is ε. SEP_SET(M) and
FIRST(<code>tt ...</code>) \ {ε} cannot contain ε, but ALPHA_SET(M) could. Hence, this
definition allows M to accept ε if and only if ε ∈ ALPHA_SET(M) does. This is
correct because for M to accept ε in the complex NT case, both the complex NT
and α must accept it. If OP = <code>+</code>, meaning that the complex NT cannot be empty,
then by definition ε ∉ ALPHA_SET(M). Otherwise, the complex NT can accept zero
repetitions, and then ALPHA_SET(M) = FOLLOW(<code>α</code>). So this definition is correct
with respect to \varepsilon as well.</p>
<h4><a class="header" href="#last" id="last">LAST</a></h4>
<p>LAST(M), defined by case analysis on M itself (a sequence of token-trees):</p>
<ul>
<li>
<p>if M is the empty sequence, then LAST(M) = { ε }</p>
</li>
<li>
<p>if M is a singleton token t, then LAST(M) = { t }</p>
</li>
<li>
<p>if M is the singleton complex NT repeating zero or more times, <code>M = $( tt ... ) *</code>, or <code>M = $( tt ... ) SEP *</code></p>
<ul>
<li>
<p>Let sep_set = { SEP } if SEP present; otherwise sep_set = {}.</p>
</li>
<li>
<p>if ε ∈ LAST(<code>tt ...</code>) then LAST(M) = LAST(<code>tt ...</code>) ∪ sep_set</p>
</li>
<li>
<p>otherwise, the sequence <code>tt ...</code> must be non-empty; LAST(M) = LAST(<code>tt ...</code>) ∪ {ε}.</p>
</li>
</ul>
</li>
<li>
<p>if M is the singleton complex NT repeating one or more times, <code>M = $( tt ... ) +</code>, or <code>M = $( tt ... ) SEP +</code></p>
<ul>
<li>
<p>Let sep_set = { SEP } if SEP present; otherwise sep_set = {}.</p>
</li>
<li>
<p>if ε ∈ LAST(<code>tt ...</code>) then LAST(M) = LAST(<code>tt ...</code>) ∪ sep_set</p>
</li>
<li>
<p>otherwise, the sequence <code>tt ...</code> must be non-empty; LAST(M) = LAST(<code>tt ...</code>)</p>
</li>
</ul>
</li>
<li>
<p>if M is the singleton complex NT repeating zero or one time, <code>M = $( tt ...) ?</code>, then LAST(M) = LAST(<code>tt ...</code>) ∪ {ε}.</p>
</li>
<li>
<p>if M is a delimited token-tree sequence <code>OPEN tt ... CLOSE</code>, then LAST(M) =
{ <code>CLOSE</code> }.</p>
</li>
<li>
<p>if M is a non-empty sequence of token-trees <code>tt uu ...</code>,</p>
<ul>
<li>
<p>If ε ∈ LAST(<code>uu ...</code>), then LAST(M) = LAST(<code>tt</code>) ∪ (LAST(<code>uu ...</code>) \ { ε }).</p>
</li>
<li>
<p>Otherwise, the sequence <code>uu ...</code> must be non-empty; then LAST(M) =
LAST(<code>uu ...</code>).</p>
</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#examples-of-first-and-last" id="examples-of-first-and-last">Examples of FIRST and LAST</a></h3>
<p>Below are some examples of FIRST and LAST.
(Note in particular how the special ε element is introduced and
eliminated based on the interaction between the pieces of the input.)</p>
<p>Our first example is presented in a tree structure to elaborate on how
the analysis of the matcher composes. (Some of the simpler subtrees
have been elided.)</p>
<pre><code class="language-text">INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g
            ~~~~~~~~   ~~~~~~~                ~
                |         |                   |
FIRST:   { $d:ident }  { $e:expr }          { h }


INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+
            ~~~~~~~~~~~~~~~~~~             ~~~~~~~           ~~~
                        |                      |               |
FIRST:          { $d:ident }               { h, ε }         { f }

INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~    ~~~~~~~~~~~~~~    ~~~~~~~~~   ~
                        |                       |              |       |
FIRST:        { $d:ident, ε }            {  h, ε, ;  }      { f }   { g }


INPUT:  $(  $d:ident   $e:expr   );*    $( $( h )* );*    $( f ; )+   g
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                        |
FIRST:                       { $d:ident, h, ;,  f }
</code></pre>
<p>Thus:</p>
<ul>
<li>FIRST(<code>$($d:ident $e:expr );* $( $(h)* );* $( f ;)+ g</code>) = { <code>$d:ident</code>, <code>h</code>, <code>;</code>, <code>f</code> }</li>
</ul>
<p>Note however that:</p>
<ul>
<li>FIRST(<code>$($d:ident $e:expr );* $( $(h)* );* $($( f ;)+ g)*</code>) = { <code>$d:ident</code>, <code>h</code>, <code>;</code>, <code>f</code>, ε }</li>
</ul>
<p>Here are similar examples but now for LAST.</p>
<ul>
<li>LAST(<code>$d:ident $e:expr</code>) = { <code>$e:expr</code> }</li>
<li>LAST(<code>$( $d:ident $e:expr );*</code>) = { <code>$e:expr</code>, ε }</li>
<li>LAST(<code>$( $d:ident $e:expr );* $(h)*</code>) = { <code>$e:expr</code>, ε, <code>h</code> }</li>
<li>LAST(<code>$( $d:ident $e:expr );* $(h)* $( f ;)+</code>) = { <code>;</code> }</li>
<li>LAST(<code>$( $d:ident $e:expr );* $(h)* $( f ;)+ g</code>) = { <code>g</code> }</li>
</ul>
<h3><a class="header" href="#followm" id="followm">FOLLOW(M)</a></h3>
<p>Finally, the definition for FOLLOW(M) is built up as follows. pat, expr, etc.
represent simple nonterminals with the given fragment specifier.</p>
<ul>
<li>
<p>FOLLOW(pat) = {<code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>if</code>, <code>in</code>}`.</p>
</li>
<li>
<p>FOLLOW(expr) = FOLLOW(stmt) =  {<code>=&gt;</code>, <code>,</code>, <code>;</code>}`.</p>
</li>
<li>
<p>FOLLOW(ty) = FOLLOW(path) = {<code>{</code>, <code>[</code>, <code>,</code>, <code>=&gt;</code>, <code>:</code>, <code>=</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>;</code>,
<code>|</code>, <code>as</code>, <code>where</code>, block nonterminals}.</p>
</li>
<li>
<p>FOLLOW(vis) = {<code>,</code>l any keyword or identifier except a non-raw <code>priv</code>; any
token that can begin a type; ident, ty, and path nonterminals}.</p>
</li>
<li>
<p>FOLLOW(t) = ANYTOKEN for any other simple token, including block, ident,
tt, item, lifetime, literal and meta simple nonterminals, and all terminals.</p>
</li>
<li>
<p>FOLLOW(M), for any other M, is defined as the intersection, as t ranges over
(LAST(M) \ {ε}), of FOLLOW(t).</p>
</li>
</ul>
<p>The tokens that can begin a type are, as of this writing, {<code>(</code>, <code>[</code>, <code>!</code>, <code>\*</code>,
<code>&amp;</code>, <code>&amp;&amp;</code>, <code>?</code>, lifetimes, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>::</code>, any non-keyword identifier, <code>super</code>,
<code>self</code>, <code>Self</code>, <code>extern</code>, <code>crate</code>, <code>$crate</code>, <code>_</code>, <code>for</code>, <code>impl</code>, <code>fn</code>, <code>unsafe</code>,
<code>typeof</code>, <code>dyn</code>}, although this list may not be complete because people won’t
always remember to update the appendix when new ones are added.</p>
<p>Examples of FOLLOW for complex M:</p>
<ul>
<li>FOLLOW(<code>$( $d:ident $e:expr )\*</code>) = FOLLOW(<code>$e:expr</code>)</li>
<li>FOLLOW(<code>$( $d:ident $e:expr )\* $(;)\*</code>) = FOLLOW(<code>$e:expr</code>) ∩ ANYTOKEN = FOLLOW(<code>$e:expr</code>)</li>
<li>FOLLOW(<code>$( $d:ident $e:expr )\* $(;)\* $( f |)+</code>) = ANYTOKEN</li>
</ul>
<h3><a class="header" href="#examples-of-valid-and-invalid-matchers" id="examples-of-valid-and-invalid-matchers">Examples of valid and invalid matchers</a></h3>
<p>With the above specification in hand, we can present arguments for
why particular matchers are legal and others are not.</p>
<ul>
<li>
<p><code>($ty:ty &lt; foo ,)</code> : illegal, because FIRST(<code>&lt; foo ,</code>) = { <code>&lt;</code> } ⊈ FOLLOW(<code>ty</code>)</p>
</li>
<li>
<p><code>($ty:ty , foo &lt;)</code> : legal, because FIRST(<code>, foo &lt;</code>) = { <code>,</code> }  is ⊆ FOLLOW(<code>ty</code>).</p>
</li>
<li>
<p><code>($pa:pat $pb:pat $ty:ty ,)</code> : illegal, because FIRST(<code>$pb:pat $ty:ty ,</code>) = { <code>$pb:pat</code> } ⊈ FOLLOW(<code>pat</code>), and also FIRST(<code>$ty:ty ,</code>) = { <code>$ty:ty</code> } ⊈ FOLLOW(<code>pat</code>).</p>
</li>
<li>
<p><code>( $($a:tt $b:tt)* ; )</code> : legal, because FIRST(<code>$b:tt</code>) = { <code>$b:tt</code> } is ⊆ FOLLOW(<code>tt</code>) = ANYTOKEN, as is FIRST(<code>;</code>) = { <code>;</code> }.</p>
</li>
<li>
<p><code>( $($t:tt),* , $(t:tt),* )</code> : legal,  (though any attempt to actually use this macro will signal a local ambiguity error during expansion).</p>
</li>
<li>
<p><code>($ty:ty $(; not sep)* -)</code> : illegal, because FIRST(<code>$(; not sep)* -</code>) = { <code>;</code>, <code>-</code> } is not in FOLLOW(<code>ty</code>).</p>
</li>
<li>
<p><code>($($ty:ty)-+)</code> : illegal, because separator <code>-</code> is not in FOLLOW(<code>ty</code>).</p>
</li>
<li>
<p><code>($($e:expr)*)</code> : illegal, because expr NTs are not in FOLLOW(expr NT).</p>
</li>
</ul>
<h1><a class="header" href="#influences" id="influences">Influences</a></h1>
<p>Rust is not a particularly original language, with design elements coming from
a wide range of sources. Some of these are listed below (including elements
that have since been removed):</p>
<ul>
<li>SML, OCaml: algebraic data types, pattern matching, type inference,
semicolon statement separation</li>
<li>C++: references, RAII, smart pointers, move semantics, monomorphization,
memory model</li>
<li>ML Kit, Cyclone: region based memory management</li>
<li>Haskell (GHC): typeclasses, type families</li>
<li>Newsqueak, Alef, Limbo: channels, concurrency</li>
<li>Erlang: message passing, thread failure, <strike>linked thread failure</strike>,
<strike>lightweight concurrency</strike></li>
<li>Swift: optional bindings</li>
<li>Scheme: hygienic macros</li>
<li>C#: attributes</li>
<li>Ruby: closure syntax, <strike>block syntax</strike></li>
<li>NIL, Hermes: <strike>typestate</strike></li>
<li><a href="http://www.unicode.org/reports/tr31/">Unicode Annex #31</a>: identifier and
pattern syntax</li>
</ul>
<h1><a class="header" href="#glossary" id="glossary">Glossary</a></h1>
<h3><a class="header" href="#abstract-syntax-tree" id="abstract-syntax-tree">Abstract syntax tree</a></h3>
<p>An ‘abstract syntax tree’, or ‘AST’, is an intermediate representation of
the structure of the program when the compiler is compiling it.</p>
<h3><a class="header" href="#alignment" id="alignment">Alignment</a></h3>
<p>The alignment of a value specifies what addresses values are preferred to
start at. Always a power of two. References to a value must be aligned.
<a href="type-layout.html#size-and-alignment">More</a>.</p>
<h3><a class="header" href="#arity" id="arity">Arity</a></h3>
<p>Arity refers to the number of arguments a function or operator takes.
For some examples, <code>f(2, 3)</code> and <code>g(4, 6)</code> have arity 2, while <code>h(8, 2, 6)</code>
has arity 3. The <code>!</code> operator has arity 1.</p>
<h3><a class="header" href="#array" id="array">Array</a></h3>
<p>An array, sometimes also called a fixed-size array or an inline array, is a value
describing a collection of elements, each selected by an index that can be computed
at run time by the program. It occupies a contiguous region of memory.</p>
<h3><a class="header" href="#associated-item" id="associated-item">Associated item</a></h3>
<p>An associated item is an item that is associated with another item. Associated
items are defined in <a href="items/implementations.html">implementations</a> and declared in <a href="items/traits.html">traits</a>. Only
functions, constants, and type aliases can be associated. Contrast to a <a href="glossary.html#free-item">free
item</a>.</p>
<h3><a class="header" href="#blanket-implementation" id="blanket-implementation">Blanket implementation</a></h3>
<p>Any implementation where a type appears <a href="glossary.html#uncovered-type">uncovered</a>. <code>impl&lt;T&gt; Foo for T</code>, <code>impl&lt;T&gt; Bar&lt;T&gt; for T</code>, <code>impl&lt;T&gt; Bar&lt;Vec&lt;T&gt;&gt; for T</code>, and <code>impl&lt;T&gt; Bar&lt;T&gt; for Vec&lt;T&gt;</code> are considered blanket impls. However, <code>impl&lt;T&gt; Bar&lt;Vec&lt;T&gt;&gt; for Vec&lt;T&gt;</code> is not a blanket impl, as all instances of <code>T</code> which appear in this <code>impl</code>
are covered by <code>Vec</code>.</p>
<h3><a class="header" href="#bound" id="bound">Bound</a></h3>
<p>Bounds are constraints on a type or trait. For example, if a bound
is placed on the argument a function takes, types passed to that function
must abide by that constraint.</p>
<h3><a class="header" href="#combinator" id="combinator">Combinator</a></h3>
<p>Combinators are higher-order functions that apply only functions and
earlier defined combinators to provide a result from its arguments.
They can be used to manage control flow in a modular fashion.</p>
<h3><a class="header" href="#dispatch" id="dispatch">Dispatch</a></h3>
<p>Dispatch is the mechanism to determine which specific version of code is actually
run when it involves polymorphism. Two major forms of dispatch are static dispatch and
dynamic dispatch. While Rust favors static dispatch, it also supports dynamic dispatch
through a mechanism called ‘trait objects’.</p>
<h3><a class="header" href="#dynamically-sized-type" id="dynamically-sized-type">Dynamically sized type</a></h3>
<p>A dynamically sized type (DST) is a type without a statically known size or alignment.</p>
<h3><a class="header" href="#expression" id="expression">Expression</a></h3>
<p>An expression is a combination of values, constants, variables, operators
and functions that evaluate to a single value, with or without side-effects.</p>
<p>For example, <code>2 + (3 * 4)</code> is an expression that returns the value 14.</p>
<h3><a class="header" href="#free-item" id="free-item">Free item</a></h3>
<p>An <a href="items.html">item</a> that is not a member of an <a href="items/implementations.html">implementation</a>, such as a <em>free
function</em> or a <em>free const</em>. Contrast to an <a href="glossary.html#associated-item">associated item</a>.</p>
<h3><a class="header" href="#fundamental-traits" id="fundamental-traits">Fundamental traits</a></h3>
<p>A fundamental trait is one where adding an impl of it for an existing type is a breaking change. 
The <code>Fn</code> traits and <code>Sized</code> are fundamental.</p>
<h3><a class="header" href="#fundamental-type-constructors" id="fundamental-type-constructors">Fundamental type constructors</a></h3>
<p>A fundamental type constructor is a type where implementing a <a href="glossary.html#blanket-implementation">blanket implementation</a> over it 
is a breaking change. <code>&amp;</code>, <code>&amp;mut</code>, <code>Box</code>, and <code>Pin</code>  are fundamental. </p>
<p>Any time a type <code>T</code> is considered <a href="glossary.html#local-type">local</a>, <code>&amp;T</code>, <code>&amp;mut T</code>, <code>Box&lt;T&gt;</code>, and <code>Pin&lt;T&gt;</code> 
are also considered local. Fundamental type constructors cannot <a href="glossary.html#uncovered-type">cover</a> other types. 
Any time the term “covered type” is used, 
the <code>T</code> in <code>&amp;T</code>, <code>&amp;mut T</code>, <code>Box&lt;T&gt;</code>, and <code>Pin&lt;T&gt;</code> is not considered covered.</p>
<h3><a class="header" href="#inhabited" id="inhabited">Inhabited</a></h3>
<p>A type is inhabited if it has constructors and therefore can be instantiated. An inhabited type is
not “empty” in the sense that there can be values of the type. Opposite of
<a href="glossary.html#uninhabited">Uninhabited</a>.</p>
<h3><a class="header" href="#inherent-implementation" id="inherent-implementation">Inherent implementation</a></h3>
<p>An <a href="items/implementations.html">implementation</a> that applies to a nominal type, not to a trait-type pair.
<a href="items/implementations.html#inherent-implementations">More</a>.</p>
<h3><a class="header" href="#inherent-method" id="inherent-method">Inherent method</a></h3>
<p>A <a href="items/associated-items.html#methods">method</a> defined in an <a href="items/implementations.html#inherent-implementations">inherent implementation</a>, not in a trait
implementation.</p>
<h3><a class="header" href="#initialized" id="initialized">Initialized</a></h3>
<p>A variable is initialized if it has been assigned a value and hasn’t since been
moved from. All other memory locations are assumed to be uninitialized. Only
unsafe Rust can create such a memory without initializing it.</p>
<h3><a class="header" href="#local-trait" id="local-trait">Local trait</a></h3>
<p>A <code>trait</code> which was defined in the current crate. A trait definition is local
or not independent of applied type arguments. Given <code>trait Foo&lt;T, U&gt;</code>,
<code>Foo</code> is always local, regardless of the types substituted for <code>T</code> and <code>U</code>.</p>
<h3><a class="header" href="#local-type" id="local-type">Local type</a></h3>
<p>A <code>struct</code>, <code>enum</code>, or <code>union</code> which was defined in the current crate.
This is not affected by applied type arguments. <code>struct Foo</code> is considered local, but
<code>Vec&lt;Foo&gt;</code> is not. <code>LocalType&lt;ForeignType&gt;</code> is local. Type aliases do not 
affect locality.</p>
<h3><a class="header" href="#nominal-types" id="nominal-types">Nominal types</a></h3>
<p>Types that can be referred to by a path directly. Specifically <a href="items/enumerations.html">enums</a>,
<a href="items/structs.html">structs</a>, <a href="items/unions.html">unions</a>, and <a href="types/trait-object.html">trait objects</a>.</p>
<h3><a class="header" href="#object-safe-traits" id="object-safe-traits">Object safe traits</a></h3>
<p><a href="items/traits.html">Traits</a> that can be used as <a href="types/trait-object.html">trait objects</a>. Only traits that follow specific
<a href="items/traits.html#object-safety">rules</a> are object safe.</p>
<h3><a class="header" href="#prelude" id="prelude">Prelude</a></h3>
<p>Prelude, or The Rust Prelude, is a small collection of items - mostly traits - that are
imported into every module of every crate. The traits in the prelude are pervasive.</p>
<h3><a class="header" href="#scrutinee" id="scrutinee">Scrutinee</a></h3>
<p>A scrutinee is the expression that is matched on in <code>match</code> expressions and
similar pattern matching constructs. For example, in <code>match x { A =&gt; 1, B =&gt; 2 }</code>,
the expression <code>x</code> is the scrutinee.</p>
<h3><a class="header" href="#size" id="size">Size</a></h3>
<p>The size of a value has two definitions.</p>
<p>The first is that it is how much memory must be allocated to store that value.</p>
<p>The second is that it is the offset in bytes between successive elements in an
array with that item type.</p>
<p>It is a multiple of the alignment, including zero. The size can change
depending on compiler version (as new optimizations are made) and target
platform (similar to how <code>usize</code> varies per-platform).</p>
<p><a href="type-layout.html#size-and-alignment">More</a>.</p>
<h3><a class="header" href="#slice" id="slice">Slice</a></h3>
<p>A slice is dynamically-sized view into a contiguous sequence, written as <code>[T]</code>.</p>
<p>It is often seen in its borrowed forms, either mutable or shared. The shared
slice type is <code>&amp;[T]</code>, while the mutable slice type is <code>&amp;mut [T]</code>, where <code>T</code> represents
the element type.</p>
<h3><a class="header" href="#statement" id="statement">Statement</a></h3>
<p>A statement is the smallest standalone element of a programming language
that commands a computer to perform an action.</p>
<h3><a class="header" href="#string-literal" id="string-literal">String literal</a></h3>
<p>A string literal is a string stored directly in the final binary, and so will be
valid for the <code>'static</code> duration.</p>
<p>Its type is <code>'static</code> duration borrowed string slice, <code>&amp;'static str</code>.</p>
<h3><a class="header" href="#string-slice" id="string-slice">String slice</a></h3>
<p>A string slice is the most primitive string type in Rust, written as <code>str</code>. It is
often seen in its borrowed forms, either mutable or shared. The shared
string slice type is <code>&amp;str</code>, while the mutable string slice type is <code>&amp;mut str</code>.</p>
<p>Strings slices are always valid UTF-8.</p>
<h3><a class="header" href="#trait" id="trait">Trait</a></h3>
<p>A trait is a language item that is used for describing the functionalities a type must provide.
It allows a type to make certain promises about its behavior.</p>
<p>Generic functions and generic structs can use traits to constrain, or bound, the types they accept.</p>
<h3><a class="header" href="#uncovered-type" id="uncovered-type">Uncovered type</a></h3>
<p>A type which does not appear as an argument to another type. For example,
<code>T</code> is uncovered, but the <code>T</code> in <code>Vec&lt;T&gt;</code> is covered. This is only relevant for
type arguments.</p>
<h3><a class="header" href="#undefined-behavior" id="undefined-behavior">Undefined behavior</a></h3>
<p>Compile-time or run-time behavior that is not specified. This may result in,
but is not limited to: process termination or corruption; improper, incorrect,
or unintended computation; or platform-specific results.
<a href="behavior-considered-undefined.html">More</a>.</p>
<h3><a class="header" href="#uninhabited" id="uninhabited">Uninhabited</a></h3>
<p>A type is uninhabited if it has no constructors and therefore can never be instantiated. An
uninhabited type is “empty” in the sense that there are no values of the type. The canonical
example of an uninhabited type is the <a href="types/never.html">never type</a> <code>!</code>, or an enum with no variants
<code>enum Never { }</code>. Opposite of <a href="glossary.html#inhabited">Inhabited</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
