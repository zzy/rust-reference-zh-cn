<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Type layout - Rust 参考手册 - The Rust Language Reference</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Rust 参考手册, Rust 编程手册, Rust 编程语言, Rust 开发手册, Rust 开发指南">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        <script>
            var _hmt = _hmt || [];
            (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?5770bc327c3554e341930729aa8f9eb2";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
            })();
        </script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="introduction.html">介绍</a></li><li class="expanded "><a href="notation.html"><strong aria-hidden="true">1.</strong> 标记法</a></li><li class="expanded "><a href="lexical-structure.html"><strong aria-hidden="true">2.</strong> 词法结构</a></li><li><ol class="section"><li class="expanded "><a href="input-format.html"><strong aria-hidden="true">2.1.</strong> 输入格式</a></li><li class="expanded "><a href="keywords.html"><strong aria-hidden="true">2.2.</strong> 关键字</a></li><li class="expanded "><a href="identifiers.html"><strong aria-hidden="true">2.3.</strong> 标识符</a></li><li class="expanded "><a href="comments.html"><strong aria-hidden="true">2.4.</strong> 注释</a></li><li class="expanded "><a href="whitespace.html"><strong aria-hidden="true">2.5.</strong> 空白</a></li><li class="expanded "><a href="tokens.html"><strong aria-hidden="true">2.6.</strong> 记号</a></li><li class="expanded "><a href="paths.html"><strong aria-hidden="true">2.7.</strong> 路径</a></li></ol></li><li class="expanded "><a href="macros.html"><strong aria-hidden="true">3.</strong> 宏</a></li><li><ol class="section"><li class="expanded "><a href="macros-by-example.html"><strong aria-hidden="true">3.1.</strong> 声明宏</a></li><li class="expanded "><a href="procedural-macros.html"><strong aria-hidden="true">3.2.</strong> 过程宏</a></li></ol></li><li class="expanded "><a href="crates-and-source-files.html"><strong aria-hidden="true">4.</strong> crate 和源文件</a></li><li class="expanded "><a href="conditional-compilation.html"><strong aria-hidden="true">5.</strong> 条件编译</a></li><li class="expanded "><a href="items.html"><strong aria-hidden="true">6.</strong> 项</a></li><li><ol class="section"><li class="expanded "><a href="items/modules.html"><strong aria-hidden="true">6.1.</strong> 模块</a></li><li class="expanded "><a href="items/extern-crates.html"><strong aria-hidden="true">6.2.</strong> extern crate 声明</a></li><li class="expanded "><a href="items/use-declarations.html"><strong aria-hidden="true">6.3.</strong> use 声明</a></li><li class="expanded "><a href="items/functions.html"><strong aria-hidden="true">6.4.</strong> 函数</a></li><li class="expanded "><a href="items/type-aliases.html"><strong aria-hidden="true">6.5.</strong> 类型别名</a></li><li class="expanded "><a href="items/structs.html"><strong aria-hidden="true">6.6.</strong> 结构体</a></li><li class="expanded "><a href="items/enumerations.html"><strong aria-hidden="true">6.7.</strong> 枚举</a></li><li class="expanded "><a href="items/unions.html"><strong aria-hidden="true">6.8.</strong> 联合体</a></li><li class="expanded "><a href="items/constant-items.html"><strong aria-hidden="true">6.9.</strong> 常量项</a></li><li class="expanded "><a href="items/static-items.html"><strong aria-hidden="true">6.10.</strong> 静态项</a></li><li class="expanded "><a href="items/traits.html"><strong aria-hidden="true">6.11.</strong> trait</a></li><li class="expanded "><a href="items/implementations.html"><strong aria-hidden="true">6.12.</strong> 实现</a></li><li class="expanded "><a href="items/external-blocks.html"><strong aria-hidden="true">6.13.</strong> 外部块</a></li><li class="expanded "><a href="items/generics.html"><strong aria-hidden="true">6.14.</strong> 泛型：类型和生命周期参数</a></li><li class="expanded "><a href="items/associated-items.html"><strong aria-hidden="true">6.15.</strong> 关联项</a></li><li class="expanded "><a href="visibility-and-privacy.html"><strong aria-hidden="true">6.16.</strong> 可见性和私有性</a></li></ol></li><li class="expanded "><a href="attributes.html"><strong aria-hidden="true">7.</strong> 属性</a></li><li><ol class="section"><li class="expanded "><a href="attributes/testing.html"><strong aria-hidden="true">7.1.</strong> 测试属性</a></li><li class="expanded "><a href="attributes/derive.html"><strong aria-hidden="true">7.2.</strong> 派生属性</a></li><li class="expanded "><a href="attributes/diagnostics.html"><strong aria-hidden="true">7.3.</strong> 诊断属性</a></li><li class="expanded "><a href="attributes/codegen.html"><strong aria-hidden="true">7.4.</strong> 代码生成属性</a></li><li class="expanded "><a href="attributes/limits.html"><strong aria-hidden="true">7.5.</strong> limit 属性</a></li><li class="expanded "><a href="attributes/type_system.html"><strong aria-hidden="true">7.6.</strong> 类型系统属性</a></li></ol></li><li class="expanded "><a href="statements-and-expressions.html"><strong aria-hidden="true">8.</strong> 语句和表达式</a></li><li><ol class="section"><li class="expanded "><a href="statements.html"><strong aria-hidden="true">8.1.</strong> 语句</a></li><li class="expanded "><a href="expressions.html"><strong aria-hidden="true">8.2.</strong> 表达式</a></li><li><ol class="section"><li class="expanded "><a href="expressions/literal-expr.html"><strong aria-hidden="true">8.2.1.</strong> 字面量表达式</a></li><li class="expanded "><a href="expressions/path-expr.html"><strong aria-hidden="true">8.2.2.</strong> 路径表达式</a></li><li class="expanded "><a href="expressions/block-expr.html"><strong aria-hidden="true">8.2.3.</strong> 块表达式</a></li><li class="expanded "><a href="expressions/operator-expr.html"><strong aria-hidden="true">8.2.4.</strong> 运算符表达式</a></li><li class="expanded "><a href="expressions/grouped-expr.html"><strong aria-hidden="true">8.2.5.</strong> 组合表达式</a></li><li class="expanded "><a href="expressions/array-expr.html"><strong aria-hidden="true">8.2.6.</strong> 数组和索引表达式</a></li><li class="expanded "><a href="expressions/tuple-expr.html"><strong aria-hidden="true">8.2.7.</strong> 元组和索引表达式</a></li><li class="expanded "><a href="expressions/struct-expr.html"><strong aria-hidden="true">8.2.8.</strong> 结构体表达式</a></li><li class="expanded "><a href="expressions/enum-variant-expr.html"><strong aria-hidden="true">8.2.9.</strong> 枚举变量表达式</a></li><li class="expanded "><a href="expressions/call-expr.html"><strong aria-hidden="true">8.2.10.</strong> 调用表达式</a></li><li class="expanded "><a href="expressions/method-call-expr.html"><strong aria-hidden="true">8.2.11.</strong> 方法调用表达式</a></li><li class="expanded "><a href="expressions/field-expr.html"><strong aria-hidden="true">8.2.12.</strong> 字段存取表达式</a></li><li class="expanded "><a href="expressions/closure-expr.html"><strong aria-hidden="true">8.2.13.</strong> 闭包表达式</a></li><li class="expanded "><a href="expressions/loop-expr.html"><strong aria-hidden="true">8.2.14.</strong> 循环表达式</a></li><li class="expanded "><a href="expressions/range-expr.html"><strong aria-hidden="true">8.2.15.</strong> 区间表达式</a></li><li class="expanded "><a href="expressions/if-expr.html"><strong aria-hidden="true">8.2.16.</strong> if 和 if let 表达式</a></li><li class="expanded "><a href="expressions/match-expr.html"><strong aria-hidden="true">8.2.17.</strong> match 表达式</a></li><li class="expanded "><a href="expressions/return-expr.html"><strong aria-hidden="true">8.2.18.</strong> return 表达式</a></li><li class="expanded "><a href="expressions/await-expr.html"><strong aria-hidden="true">8.2.19.</strong> await 表达式</a></li></ol></li></ol></li><li class="expanded "><a href="patterns.html"><strong aria-hidden="true">9.</strong> 模式</a></li><li class="expanded "><a href="type-system.html"><strong aria-hidden="true">10.</strong> 类型系统</a></li><li><ol class="section"><li class="expanded "><a href="types.html"><strong aria-hidden="true">10.1.</strong> 类型</a></li><li><ol class="section"><li class="expanded "><a href="types/boolean.html"><strong aria-hidden="true">10.1.1.</strong> 布尔型</a></li><li class="expanded "><a href="types/numeric.html"><strong aria-hidden="true">10.1.2.</strong> 数值型</a></li><li class="expanded "><a href="types/textual.html"><strong aria-hidden="true">10.1.3.</strong> 字符型</a></li><li class="expanded "><a href="types/never.html"><strong aria-hidden="true">10.1.4.</strong> never 型</a></li><li class="expanded "><a href="types/tuple.html"><strong aria-hidden="true">10.1.5.</strong> 元组</a></li><li class="expanded "><a href="types/array.html"><strong aria-hidden="true">10.1.6.</strong> 数组</a></li><li class="expanded "><a href="types/slice.html"><strong aria-hidden="true">10.1.7.</strong> 切片</a></li><li class="expanded "><a href="types/struct.html"><strong aria-hidden="true">10.1.8.</strong> 结构体</a></li><li class="expanded "><a href="types/enum.html"><strong aria-hidden="true">10.1.9.</strong> 枚举</a></li><li class="expanded "><a href="types/union.html"><strong aria-hidden="true">10.1.10.</strong> union 型</a></li><li class="expanded "><a href="types/function-item.html"><strong aria-hidden="true">10.1.11.</strong> 函数项</a></li><li class="expanded "><a href="types/closure.html"><strong aria-hidden="true">10.1.12.</strong> 闭包</a></li><li class="expanded "><a href="types/pointer.html"><strong aria-hidden="true">10.1.13.</strong> 指针</a></li><li class="expanded "><a href="types/function-pointer.html"><strong aria-hidden="true">10.1.14.</strong> 函数指针</a></li><li class="expanded "><a href="types/trait-object.html"><strong aria-hidden="true">10.1.15.</strong> trait 对象</a></li><li class="expanded "><a href="types/impl-trait.html"><strong aria-hidden="true">10.1.16.</strong> impl trait</a></li><li class="expanded "><a href="types/parameters.html"><strong aria-hidden="true">10.1.17.</strong> 类型参数</a></li><li class="expanded "><a href="types/inferred.html"><strong aria-hidden="true">10.1.18.</strong> 推导型</a></li></ol></li><li class="expanded "><a href="dynamically-sized-types.html"><strong aria-hidden="true">10.2.</strong> Dynamically Sized Types</a></li><li class="expanded "><a href="type-layout.html" class="active"><strong aria-hidden="true">10.3.</strong> Type layout</a></li><li class="expanded "><a href="interior-mutability.html"><strong aria-hidden="true">10.4.</strong> Interior mutability</a></li><li class="expanded "><a href="subtyping.html"><strong aria-hidden="true">10.5.</strong> Subtyping and Variance</a></li><li class="expanded "><a href="trait-bounds.html"><strong aria-hidden="true">10.6.</strong> Trait and lifetime bounds</a></li><li class="expanded "><a href="type-coercions.html"><strong aria-hidden="true">10.7.</strong> Type coercions</a></li><li class="expanded "><a href="destructors.html"><strong aria-hidden="true">10.8.</strong> Destructors</a></li><li class="expanded "><a href="lifetime-elision.html"><strong aria-hidden="true">10.9.</strong> Lifetime elision</a></li></ol></li><li class="expanded "><a href="special-types-and-traits.html"><strong aria-hidden="true">11.</strong> Special types and traits</a></li><li class="expanded "><a href="memory-model.html"><strong aria-hidden="true">12.</strong> Memory model</a></li><li><ol class="section"><li class="expanded "><a href="memory-allocation-and-lifetime.html"><strong aria-hidden="true">12.1.</strong> Memory allocation and lifetime</a></li><li class="expanded "><a href="memory-ownership.html"><strong aria-hidden="true">12.2.</strong> Memory ownership</a></li><li class="expanded "><a href="variables.html"><strong aria-hidden="true">12.3.</strong> Variables</a></li></ol></li><li class="expanded "><a href="linkage.html"><strong aria-hidden="true">13.</strong> Linkage</a></li><li class="expanded "><a href="unsafety.html"><strong aria-hidden="true">14.</strong> Unsafety</a></li><li><ol class="section"><li class="expanded "><a href="unsafe-functions.html"><strong aria-hidden="true">14.1.</strong> Unsafe functions</a></li><li class="expanded "><a href="unsafe-blocks.html"><strong aria-hidden="true">14.2.</strong> Unsafe blocks</a></li><li class="expanded "><a href="behavior-considered-undefined.html"><strong aria-hidden="true">14.3.</strong> Behavior considered undefined</a></li><li class="expanded "><a href="behavior-not-considered-unsafe.html"><strong aria-hidden="true">14.4.</strong> Behavior not considered unsafe</a></li></ol></li><li class="expanded "><a href="const_eval.html"><strong aria-hidden="true">15.</strong> Constant Evaluation</a></li><li class="expanded "><a href="abi.html"><strong aria-hidden="true">16.</strong> Application Binary Interface</a></li><li class="expanded "><a href="runtime.html"><strong aria-hidden="true">17.</strong> The Rust runtime</a></li><li class="expanded "><a href="appendices.html"><strong aria-hidden="true">18.</strong> Appendices</a></li><li><ol class="section"><li class="expanded "><a href="macro-ambiguity.html"><strong aria-hidden="true">18.1.</strong> Macro Follow-Set Ambiguity Formal Specification</a></li><li class="expanded "><a href="influences.html"><strong aria-hidden="true">18.2.</strong> Influences</a></li><li class="expanded "><a href="glossary.html"><strong aria-hidden="true">18.3.</strong> Glossary</a></li></ol></li><li class="expanded "><a href="rust-glossary.html">Rust 语言术语中英文对照表</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust 参考手册 - The Rust Language Reference</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                            <a href="https://github.com/zzy/rust-reference-zh" title="Git repository" aria-label="Git repository">
                                <i id="git-repository-button" class="fa fa-github"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#type-layout" id="type-layout">Type Layout</a></h1>
<p>The layout of a type is its size, alignment, and the relative offsets of its
fields. For enums, how the discriminant is laid out and interpreted is also part
of type layout.</p>
<p>Type layout can be changed with each compilation. Instead of trying to document
exactly what is done, we only document what is guaranteed today.</p>
<h2><a class="header" href="#size-and-alignment" id="size-and-alignment">Size and Alignment</a></h2>
<p>All values have an alignment and size.</p>
<p>The <em>alignment</em> of a value specifies what addresses are valid to store the value
at. A value of alignment <code>n</code> must only be stored at an address that is a
multiple of n. For example, a value with an alignment of 2 must be stored at an
even address, while a value with an alignment of 1 can be stored at any address.
Alignment is measured in bytes, and must be at least 1, and always a power of 2.
The alignment of a value can be checked with the <a href="../std/mem/fn.align_of_val.html"><code>align_of_val</code></a> function.</p>
<p>The <em>size</em> of a value is the offset in bytes between successive elements in an
array with that item type including alignment padding. The size of a value is
always a multiple of its alignment. The size of a value can be checked with the
<a href="../std/mem/fn.size_of_val.html"><code>size_of_val</code></a> function.</p>
<p>Types where all values have the same size and alignment known at compile time
implement the <a href="../std/marker/trait.Sized.html"><code>Sized</code></a> trait and can be checked with the <a href="../std/mem/fn.size_of.html"><code>size_of</code></a> and
<a href="../std/mem/fn.align_of.html"><code>align_of</code></a> functions. Types that are not <a href="../std/marker/trait.Sized.html"><code>Sized</code></a> are known as <a href="dynamically-sized-types.html">dynamically
sized types</a>. Since all values of a <code>Sized</code> type share the same size and
alignment, we refer to those shared values as the size of the type and the
alignment of the type respectively.</p>
<h2><a class="header" href="#primitive-data-layout" id="primitive-data-layout">Primitive Data Layout</a></h2>
<p>The size of most primitives is given in this table.</p>
<table><thead><tr><th>Type</th><th><code>size_of::&lt;Type&gt;()</code></th></tr></thead><tbody>
<tr><td><code>bool</code></td><td>1</td></tr>
<tr><td><code>u8</code> / <code>i8</code></td><td>1</td></tr>
<tr><td><code>u16</code> / <code>i16</code></td><td>2</td></tr>
<tr><td><code>u32</code> / <code>i32</code></td><td>4</td></tr>
<tr><td><code>u64</code> / <code>i64</code></td><td>8</td></tr>
<tr><td><code>u128</code> / <code>i128</code></td><td>16</td></tr>
<tr><td><code>f32</code></td><td>4</td></tr>
<tr><td><code>f64</code></td><td>8</td></tr>
<tr><td><code>char</code></td><td>4</td></tr>
</tbody></table>
<p><code>usize</code> and <code>isize</code> have a size big enough to contain every address on the
target platform. For example, on a 32 bit target, this is 4 bytes and on a 64
bit target, this is 8 bytes.</p>
<p>Most primitives are generally aligned to their size, although this is
platform-specific behavior. In particular, on x86 u64 and f64 are only
aligned to 32 bits.</p>
<h2><a class="header" href="#pointers-and-references-layout" id="pointers-and-references-layout">Pointers and References Layout</a></h2>
<p>Pointers and references have the same layout. Mutability of the pointer or
reference does not change the layout.</p>
<p>Pointers to sized types have the same size and alignment as <code>usize</code>.</p>
<p>Pointers to unsized types are sized. The size and alignment is guaranteed to be
at least equal to the size and alignment of a pointer.</p>
<blockquote>
<p>Note: Though you should not rely on this, all pointers to
<abbr title="Dynamically Sized Types">DSTs</abbr> are currently twice the
size of the size of <code>usize</code> and have the same alignment.</p>
</blockquote>
<h2><a class="header" href="#array-layout" id="array-layout">Array Layout</a></h2>
<p>Arrays are laid out so that the <code>nth</code> element of the array is offset from the
start of the array by <code>n * the size of the type</code> bytes. An array of <code>[T; n]</code>
has a size of <code>size_of::&lt;T&gt;() * n</code> and the same alignment of <code>T</code>.</p>
<h2><a class="header" href="#slice-layout" id="slice-layout">Slice Layout</a></h2>
<p>Slices have the same layout as the section of the array they slice.</p>
<blockquote>
<p>Note: This is about the raw <code>[T]</code> type, not pointers (<code>&amp;[T]</code>, <code>Box&lt;[T]&gt;</code>,
etc.) to slices.</p>
</blockquote>
<h2><a class="header" href="#str-layout" id="str-layout"><code>str</code> Layout</a></h2>
<p>String slices are a UTF-8 representation of characters that have the same layout as slices of type <code>[u8]</code>.</p>
<h2><a class="header" href="#tuple-layout" id="tuple-layout">Tuple Layout</a></h2>
<p>Tuples do not have any guarantees about their layout.</p>
<p>The exception to this is the unit tuple (<code>()</code>) which is guaranteed as a
zero-sized type to have a size of 0 and an alignment of 1.</p>
<h2><a class="header" href="#trait-object-layout" id="trait-object-layout">Trait Object Layout</a></h2>
<p>Trait objects have the same layout as the value the trait object is of.</p>
<blockquote>
<p>Note: This is about the raw trait object types, not pointers (<code>&amp;Trait</code>,
<code>Box&lt;Trait&gt;</code>, etc.) to trait objects.</p>
</blockquote>
<h2><a class="header" href="#closure-layout" id="closure-layout">Closure Layout</a></h2>
<p>Closures have no layout guarantees.</p>
<h2><a class="header" href="#representations" id="representations">Representations</a></h2>
<p>All user-defined composite types (<code>struct</code>s, <code>enum</code>s, and <code>union</code>s) have a
<em>representation</em> that specifies what the layout is for the type. The possible
representations for a type are:</p>
<ul>
<li><a href="#the-default-representation">Default</a></li>
<li><a href="#the-c-representation"><code>C</code></a></li>
<li>The <a href="#primitive-representations">primitive representations</a></li>
<li><a href="#the-transparent-representation"><code>transparent</code></a></li>
</ul>
<p>The representation of a type can be changed by applying the <code>repr</code> attribute
to it. The following example shows a struct with a <code>C</code> representation.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct ThreeInts {
    first: i16,
    second: i8,
    third: i32
}
<span class="boring">}
</span></code></pre></pre>
<p>The alignment may be raised or lowered with the <code>align</code> and <code>packed</code> modifiers
respectively. They alter the representation specified in the attribute.
If no representation is specified, the default one is altered.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Default representation, alignment lowered to 2.
#[repr(packed(2))]
struct PackedStruct {
    first: i16,
    second: i8,
    third: i32
}

// C representation, alignment raised to 8
#[repr(C, align(8))]
struct AlignedStruct {
    first: i16,
    second: i8,
    third: i32
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: As a consequence of the representation being an attribute on the item,
the representation does not depend on generic parameters. Any two types with
the same name have the same representation. For example, <code>Foo&lt;Bar&gt;</code> and
<code>Foo&lt;Baz&gt;</code> both have the same representation.</p>
</blockquote>
<p>The representation of a type can change the padding between fields, but does
not change the layout of the fields themselves. For example, a struct with a
<code>C</code> representation that contains a struct <code>Inner</code> with the default
representation will not change the layout of <code>Inner</code>.</p>
<h3><a class="header" href="#the-default-representation" id="the-default-representation">The Default Representation</a></h3>
<p>Nominal types without a <code>repr</code> attribute have the default representation.
Informally, this representation is also called the <code>rust</code> representation.</p>
<p>There are no guarantees of data layout made by this representation.</p>
<h3><a class="header" href="#the-c-representation" id="the-c-representation">The <code>C</code> Representation</a></h3>
<p>The <code>C</code> representation is designed for dual purposes. One purpose is for
creating types that are interoperable with the C Language. The second purpose is
to create types that you can soundly perform operations on that rely on data
layout such as reinterpreting values as a different type.</p>
<p>Because of this dual purpose, it is possible to create types that are not useful
for interfacing with the C programming language.</p>
<p>This representation can be applied to structs, unions, and enums.</p>
<h4><a class="header" href="#reprc-structs" id="reprc-structs">#[repr(C)] Structs</a></h4>
<p>The alignment of the struct is the alignment of the most-aligned field in it.</p>
<p>The size and offset of fields is determined by the following algorithm.</p>
<p>Start with a current offset of 0 bytes.</p>
<p>For each field in declaration order in the struct, first determine the size and
alignment of the field. If the current offset is not a multiple of the field’s
alignment, then add padding bytes to the current offset until it is a multiple
of the field’s alignment. The offset for the field is what the current offset
is now. Then increase the current offset by the size of the field.</p>
<p>Finally, the size of the struct is the current offset rounded up to the nearest
multiple of the struct’s alignment.</p>
<p>Here is this algorithm described in pseudocode.</p>
<!-- ignore: pseudocode -->
<pre><code class="language-rust ignore">/// Returns the amount of padding needed after `offset` to ensure that the
/// following address will be aligned to `alignment`.
fn padding_needed_for(offset: usize, alignment: usize) -&gt; usize {
    let misalignment = offset % alignment;
    if misalignment &gt; 0 {
        // round up to next multiple of `alignment`
        alignment - misalignment
    } else {
        // already a multiple of `alignment`
        0
    }
}

struct.alignment = struct.fields().map(|field| field.alignment).max();

let current_offset = 0;

for field in struct.fields_in_declaration_order() {
    // Increase the current offset so that it's a multiple of the alignment
    // of this field. For the first field, this will always be zero.
    // The skipped bytes are called padding bytes.
    current_offset += padding_needed_for(current_offset, field.alignment);

    struct[field].offset = current_offset;

    current_offset += field.size;
}

struct.size = current_offset + padding_needed_for(current_offset, struct.alignment);
</code></pre>
<div class="warning">
<p>Warning: This pseudocode uses a naive algorithm that ignores overflow issues for
the sake of clarity. To perform memory layout computations in actual code, use
<a href="../std/alloc/struct.Layout.html"><code>Layout</code></a>.</p>
</div>
<blockquote>
<p>Note: This algorithm can produce zero-sized structs. This differs from
C where structs without data still have a size of one byte.</p>
</blockquote>
<h4><a class="header" href="#reprc-unions" id="reprc-unions">#[repr(C)] Unions</a></h4>
<p>A union declared with <code>#[repr(C)]</code> will have the same size and alignment as an
equivalent C union declaration in the C language for the target platform.
The union will have a size of the maximum size of all of its fields rounded to
its alignment, and an alignment of the maximum alignment of all of its fields.
These maximums may come from different fields.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
union Union {
    f1: u16,
    f2: [u8; 4],
}

assert_eq!(std::mem::size_of::&lt;Union&gt;(), 4);  // From f2
assert_eq!(std::mem::align_of::&lt;Union&gt;(), 2); // From f1

#[repr(C)]
union SizeRoundedUp {
   a: u32,
   b: [u16; 3],
}

assert_eq!(std::mem::size_of::&lt;SizeRoundedUp&gt;(), 8);  // Size of 6 from b,
                                                      // rounded up to 8 from
                                                      // alignment of a.
assert_eq!(std::mem::align_of::&lt;SizeRoundedUp&gt;(), 4); // From a
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#reprc-enums" id="reprc-enums">#[repr(C)] Enums</a></h4>
<p>For <a href="items/enumerations.html#custom-discriminant-values-for-fieldless-enumerations">C-like enumerations</a>, the <code>C</code> representation has the size and alignment of
the default <code>enum</code> size and alignment for the target platform’s C ABI.</p>
<blockquote>
<p>Note: The enum representation in C is implementation defined, so this is
really a “best guess”. In particular, this may be incorrect when the C code
of interest is compiled with certain flags.</p>
</blockquote>
<div class="warning">
<p>Warning: There are crucial differences between an <code>enum</code> in the C language and
Rust’s C-like enumerations with this representation. An <code>enum</code> in  C is
mostly a <code>typedef</code> plus some named constants; in other words, an object of an
<code>enum</code> type can hold any integer value. For example, this is often used for
bitflags in <code>C</code>. In contrast, Rust’s C-like enumerations can only legally hold
the discriminant values, everything else is undefined behaviour. Therefore,
using a C-like enumeration in FFI to model a C <code>enum</code> is often wrong.</p>
</div>
<p>It is an error for <a href="items/enumerations.html#zero-variant-enums">zero-variant enumerations</a> to have the <code>C</code> representation.</p>
<p>For all other enumerations, the layout is unspecified.</p>
<p>Likewise, combining the <code>C</code> representation with a primitive representation, the
layout is unspecified.</p>
<h3><a class="header" href="#primitive-representations" id="primitive-representations">Primitive representations</a></h3>
<p>The <em>primitive representations</em> are the representations with the same names as
the primitive integer types. That is: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>,
<code>usize</code>, <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, and <code>isize</code>.</p>
<p>Primitive representations can only be applied to enumerations.</p>
<p>For <a href="items/enumerations.html#custom-discriminant-values-for-fieldless-enumerations">C-like enumerations</a>, they set the size and alignment to be the same as the
primitive type of the same name. For example, a C-like enumeration with a <code>u8</code>
representation can only have discriminants between 0 and 255 inclusive.</p>
<p>It is an error for <a href="items/enumerations.html#zero-variant-enums">zero-variant enumerations</a> to have a primitive
representation.</p>
<p>For all other enumerations, the layout is unspecified.</p>
<p>Likewise, combining two primitive representations together is unspecified.</p>
<h3><a class="header" href="#the-alignment-modifiers" id="the-alignment-modifiers">The alignment modifiers</a></h3>
<p>The <code>align</code> and <code>packed</code> modifiers can be used to respectively raise or lower
the alignment of <code>struct</code>s and <code>union</code>s. <code>packed</code> may also alter the padding
between fields.</p>
<p>The alignment is specified as an integer parameter in the form of
<code>#[repr(align(x))]</code> or <code>#[repr(packed(x))]</code>. The alignment value must be a
power of two from 1 up to 2<sup>29</sup>. For <code>packed</code>, if no value is given,
as in <code>#[repr(packed)]</code>, then the value is 1.</p>
<p>For <code>align</code>, if the specified alignment is less than the alignment of the type
without the <code>align</code> modifier, then the alignment is unaffected.</p>
<p>For <code>packed</code>, if the specified alignment is greater than the type’s alignment
without the <code>packed</code> modifier, then the alignment and layout is unaffected.
The alignments of each field, for the purpose of positioning fields, is the
smaller of the specified alignment and the alignment of the field’s type.</p>
<p>The <code>align</code> and <code>packed</code> modifiers cannot be applied on the same type and a
<code>packed</code> type cannot transitively contain another <code>align</code>ed type. <code>align</code> and
<code>packed</code> may only be applied to the <a href="#the-default-representation">default</a> and <a href="#the-c-representation"><code>C</code></a> representations.</p>
<p>The <code>align</code> modifier can also be applied on an <code>enum</code>.
When it is, the effect on the <code>enum</code>‘s alignment is the same as if the <code>enum</code>
was wrapped in a newtype <code>struct</code> with the same <code>align</code> modifier.</p>
<div class="warning">
<p><em><strong>Warning:</strong></em> Dereferencing an unaligned pointer is <a href="behavior-considered-undefined.html">undefined behavior</a> and
it is possible to <a href="https://github.com/rust-lang/rust/issues/27060">safely create unaligned pointers to <code>packed</code> fields</a>.
Like all ways to create undefined behavior in safe Rust, this is a bug.</p>
</div>
<h3><a class="header" href="#the-transparent-representation" id="the-transparent-representation">The <code>transparent</code> Representation</a></h3>
<p>The <code>transparent</code> representation can only be used on <code>struct</code>s that have:</p>
<ul>
<li>a single field with non-zero size, and</li>
<li>any number of fields with size 0 and alignment 1 (e.g. <a href="special-types-and-traits.html#phantomdatat"><code>PhantomData&lt;T&gt;</code></a>).</li>
</ul>
<p>Structs with this representation have the same layout and ABI as the single
non-zero sized field.</p>
<p>This is different than the <code>C</code> representation because
a struct with the <code>C</code> representation will always have the ABI of a <code>C</code> <code>struct</code>
while, for example, a struct with the <code>transparent</code> representation with a
primitive field will have the ABI of the primitive field.</p>
<p>Because this representation delegates type layout to another type, it cannot be
used with any other representation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="dynamically-sized-types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="interior-mutability.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="dynamically-sized-types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="interior-mutability.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
